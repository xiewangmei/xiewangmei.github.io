<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiewangmei.github.io</id>
    <title>Blog-wmxie</title>
    <updated>2020-09-29T05:49:52.040Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiewangmei.github.io"/>
    <link rel="self" href="https://xiewangmei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响~</subtitle>
    <logo>https://xiewangmei.github.io/images/avatar.png</logo>
    <icon>https://xiewangmei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blog-wmxie</rights>
    <entry>
        <title type="html"><![CDATA[React小知识]]></title>
        <id>https://xiewangmei.github.io/post/react-xiao-zhi-shi/</id>
        <link href="https://xiewangmei.github.io/post/react-xiao-zhi-shi/">
        </link>
        <updated>2020-09-29T05:47:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react的程序流程">React的程序流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358552129.png" alt="React程序流程" loading="lazy"></figure>
<ul>
<li>在React中无论发生何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心。</li>
</ul>
<h3 id="virtual-dom">Virtual DOM</h3>
<ul>
<li>
<p>既然DOM树是对HTML的抽象，那<code>Virtual DOM</code>就是对DOM的抽象。<code>Virtual DOM</code>不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的<code>Virtual DOM</code>和上一次渲染的<code>Virtual DOM</code>，对比就会发现差别，然后修改真正的DOM树时就只要触及差别中的部分就行了。</p>
<ul>
<li>
<p>以ClickCouter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这次重新渲染，React通过<code>Virtual DOM</code>的对比发现其实只是id为clickCount的span元素中内容从0变成了1而已：</p>
<pre><code class="language-javascript">&lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;
</code></pre>
<p>React发现这次渲染要做的事情只是更换这个span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句就可以完成任务了：</p>
<pre><code class="language-javascript">document.getElementById(&quot;clickCount&quot;).innerHTML = &quot;1&quot;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="prop和state的对比">prop和state的对比</h3>
<ul>
<li><code>prop</code>用于定义外部接口，<code>state</code>用于记录内部状态</li>
<li><code>prop</code>的赋值在外部世界使用组件时，<code>state</code>的赋值在组件内部</li>
<li>组件不应该改变<code>prop</code>的值，而<code>state</code>存在的目的就是让组件来改变的</li>
</ul>
<h3 id="refrefs">ref&amp;refs</h3>
<ul>
<li>
<p><code>React</code>支持一种非常特殊的属性<font color='red'><code>ref</code></font>，可以用来绑定到render()输出的任何组件上</p>
<ul>
<li><code>ref</code>：绑定属性</li>
<li><code>refs</code>：调用的时候使用</li>
</ul>
</li>
<li>
<p>通过<code>refs</code>访问父组件方法</p>
<pre><code class="language-jsx">this.refs.subcomponents.subHandleClick();
</code></pre>
</li>
<li>
<p>为了获取真实DOM节点，html元素必须有一个<code>ref属性</code>，然后**<code>this.refs.[refName]</code>**就会返回这个真实的DOM节点。</p>
<blockquote>
<p><strong>注意</strong>：由于**this.refs.[refName]**属性获取的是真实DOM，所以必须等到虚拟DOM插入文档后，才能使用这个属性，否则获取不到。</p>
</blockquote>
</li>
</ul>
<h3 id="组件生命周期">组件生命周期</h3>
<ul>
<li>
<p><strong><code>constructor</code></strong>：构造函数是初始化状态的合适位置。若不初始化状态且不绑定方法，那就不需要为React组件定义一个构造函数。</p>
</li>
<li>
<p><strong><code>render</code></strong>：该方法是必须的，当被调用时，其应该检查<code>this.props</code>和<code>this.state</code>，并返回以下类型中的一个：</p>
<ul>
<li>
<p><strong>React元素</strong>：通常由JSX创建，该元素可能是一个原生DOM组件的表示，如<code>&lt;div/&gt;</code>，或者是一个自定义的合成组件。</p>
</li>
<li>
<p><strong>字符串或数字</strong>：这些将被渲染为DOM中的Text Node</p>
</li>
<li>
<p><strong><a href="https://segmentfault.com/a/1190000012325351">Portals</a></strong>：由<strong>ReactDOM.createPortal</strong>创建，可以将React子节点的DOM结构，渲染到React父节点之外的DOM中， portal 也一直存在于React 树上，无论它位于 DOM 树中的什么位置。</p>
<pre><code class="language-react">ReactDOM.createPortal(child, container)
</code></pre>
</li>
<li>
<p><strong>null</strong>：什么都不渲染</p>
</li>
<li>
<p><strong>布尔值</strong>：什么都不渲染，（通常存在于<code>return test &amp;&amp; &lt;child /&gt;</code>写法，其中<code>test</code>是布尔值。</p>
<p>当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong><code>componentWillMount</code></strong>：紧贴着自己组件的<code>render</code>函数之前被调用</p>
</li>
<li>
<p><strong><code>componentDidMount</code></strong>：不是紧跟着<code>render</code>之后调用，当所有的组件都调用完了，所有组件的<code>componentDidMount</code>才会一起被调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个<strong>适合实现网络请求的地方</strong>。在该方法里设置状态将<strong>会触发重渲</strong>。</p>
<blockquote>
<p>原因：<code>render</code>函数本身并不往DOM树上渲染或者装载内容，它只是返回一个<font color='blue'><code>JSX表示的对象</code></font>，然后由React库来根据返回对象决定如何渲染</p>
</blockquote>
</li>
</ul>
<h3 id="jsx">JSX</h3>
<ul>
<li>
<p>和原生HTML定义事件的唯一区别就是<code>JSX</code>采用<strong>驼峰</strong>写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，<strong>返回一个事件处理函数</strong>。React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在<strong>根节点document</strong>上为每种事件添加唯一的Listener，然后通过事件的<strong>target找到真实的触发元素</strong>。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React<strong>模拟事件系统</strong>。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。</p>
</li>
<li>
<p>在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，<strong>属性值不能是字符串而必须为对象</strong>。</p>
<pre><code class="language-jsx">&lt;div style={{color: '#ff0000', fontSize: 14}}&gt;Hello World.&lt;/div&gt;

{/*或者（注释要这么写）*/}  

var style = {
  color: '#ff0000',
  fontSize: 14
};

var node = &lt;div style={style}&gt;HelloWorld.&lt;/div&gt;;
</code></pre>
</li>
</ul>
<blockquote>
<p>**注意：**原生HTML元素名以小写字母开头，而自定义的React类名以<font color='red'><strong>大写字母</strong></font>开头，比如HelloMessage不能写成helloMessage，除此之外还需要注意组件类只能包含<font color='red'><strong>一个顶层标签</strong></font>，否则也会报错。</p>
</blockquote>
<h3 id="受控组件">受控组件</h3>
<h4 id="input标签">input标签</h4>
<ul>
<li>在React中，<code>&lt;input&gt;</code>会用<strong>value属性</strong>来代替子节点，value属性的值总是和文本输入框的最新内容一致，如果想要指定默认值，可以使用<strong>defaultValue属性</strong>。</li>
</ul>
<h4 id="textarea标签">textarea标签</h4>
<ul>
<li>在React中，<code>&lt;textarea&gt;</code>会用<strong>value属性</strong>来替代子节点。这样的话，表单中的<code>&lt;textarea&gt;</code>非常类似于使用单行输入的表单。</li>
</ul>
<h4 id="select标签">select标签</h4>
<ul>
<li>
<p>在React中，并不适用之前的<code>selected</code>属性，而是在根<code>select</code>标签上用<strong>value属性</strong>来表示选中的项。这在受控组件中更为方便。例如：</p>
<pre><code class="language-jsx">&lt;select value={this.state.value} onChange={this.handleChange}&gt;
    &lt;option value='grapefruit'&gt;Grapefruit&lt;/option&gt;
    &lt;option value='lime'&gt;Lime&lt;/option&gt;
    &lt;option value='coconut'&gt;Coconut&lt;/option&gt;
    &lt;option value='mango'&gt;Mango&lt;/option&gt;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>总结：</strong><code>&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;select&gt;</code>都十分类似——他们都通过传入一个<font color='red'><strong>value属性</strong></font>来实现对组件的控制。</p>
<h4 id="typescript中使用usedispatch">TypeScript中使用useDispatch</h4>
<pre><code class="language-javascript"> Promise.resolve(
    dispatch(
     	submitRegistryConfig(REGISTRY_DRAWER_STATEID, values, mode === &quot;edit&quot; ? &quot;PUT&quot; : &quot;POST&quot;)
 	)
 ).then(() =&gt; {
 	closeDrawer();
 	callback();
 });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React & Antd]]></title>
        <id>https://xiewangmei.github.io/post/react-and-antd/</id>
        <link href="https://xiewangmei.github.io/post/react-and-antd/">
        </link>
        <updated>2020-09-29T05:45:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>可以通过React.createContext中的Provider实现夸层级传递属性，避免繁琐的一层层传递</p>
<pre><code class="language-react">const { Provider } = React.createContext();
{......}
</code></pre>
</li>
<li>
<p>tab点击想要触发重新渲染，可以设置state里的数据发生变化，但是该state必须要使用，才会触发，不然就不会触发，可以将原本的对象返回一个新对象，比如</p>
<pre><code class="language-javascript">record={…record}
component: props =&gt; {
 return &lt;filterRoute.component {...props} /&gt;;
}
</code></pre>
</li>
<li>
<p>一行一个标签对应多个输入组件，这个需求很常见但在官方例子没看到合适的，因为官方建议：</p>
<blockquote>
<p>注意：一个 Form.Item 建议只放一个被 getFieldDecorator 装饰过的 child，当有多个被装饰过的 child 时，help required validateStatus 无法自动生成。</p>
</blockquote>
<p>所以可以通过在FormItem组件中再包一层FormItem，通过flex布局调整其布局，,这样校验的位置也是正确的，校验提示也能自动生成。</p>
<pre><code class="language-react">&lt;FormItem {...formItemLayout} label=&quot;IP地址段&quot;&gt;
     &lt;div style={{ display: &quot;flex&quot; }}&gt;
     	&lt;FormItem&gt;
        {getFieldDecorator(&quot;start&quot;, {
            rules: [{ required: true, message: &quot;该项为必填项&quot; }]
         })(
             &lt;Input style={{ width: 220 }}placeholder=&quot;请输入起始IP&quot;/&gt;
         )}
         &lt;/FormItem&gt;
		&lt;div className={styles[&quot;ip-range-div&quot;]}&gt;-&lt;/div&gt;
		&lt;FormItem&gt;
    	{getFieldDecorator(&quot;end&quot;, {
           	rules: [{ required: true, message: &quot;该项为必填项&quot; }]
   		 })(
        &lt;Input style={{ width: 220 }} placeholder=&quot;请输入结束IP&quot;/&gt;
        )}
        &lt;/FormItem&gt;
	&lt;/div&gt;
&lt;/FormItem&gt;
</code></pre>
</li>
<li>
<p>想要一个组件不被重新渲染，那么该组件的props都必须被校验为未修改才不会执行重渲染，函数执行返回的是一个新对象，比如说Drawer</p>
<pre><code class="language-React"> &lt;RegionManagerDrawer
     handleSubmitResult={this.handleSubmitResult}
     onClose={this.closeDrawer}
     // onClose={()=&gt;this.closeDrawer()}这种写法会触发重新渲染
     mode={mode}
     record={record}
     handleEdit={this.handleEdit}
 /&gt;
</code></pre>
<p>但是有一个问题：Modal 只要将destoryOnClose设置为true即可</p>
</li>
<li>
<p>antd的table控制是否展开，expandedRowKeys数组存放对应展开行的数据key，控制是否单独单元格放置展开图标<code>expandIconAsCell = {false}</code>，number设置展开图标所在的单元格索引，取一个不存在的索引可达到去掉预设图标的效果<code>expandIconColumnIndex = {-1}</code></p>
</li>
<li>
<p>table固定列的宽度，超出部分用<code>…</code>代替（针对普通table和antd）</p>
<ul>
<li>
<p>让溢出内容变成…，需要如下样式</p>
<pre><code class="language-css">overflow: hidden; //超出部分隐藏
text-overflow:ellipsis; //显示省略符来代表被修剪的文本
white-space: nowrap; //强制不换行
</code></pre>
<p>table的宽度我们并不能控制，内容会自动撑大表格列表宽度，需要给<code>table</code>加上一个样式：</p>
<pre><code class="language-css">table-layout:fixed;
</code></pre>
</li>
</ul>
</li>
<li>
<p>经过 <code>getFieldDecorator</code> 包装的控件，表单控件会自动添加 <code>value</code>，switch这种实际值不是value什么的，在form表单中可能设置不上值，需要通过<code>valuePropName</code>指定子节点的值的属性，如 Switch 的是 'checked'</p>
</li>
<li>
<p>在form中如果已经设置了initialValue:value，避免在componentDidMount（useEffect）等生命周期函数中使用this.props.form.setFieldsValue，否则会产生<code>Warning: You cannot set a form field before rendering a field associated with the value</code>，单一使用即可</p>
</li>
<li>
<p>form item的validator中必须要返回callback().，否则<code>validateFields（validateFieldsAndScroll ）</code>方法不生效</p>
<pre><code class="language-react">handleConfirmPassword = (rule, value, callback) =&gt; {
        const { getFieldValue } = this.props.form
        if (value &amp;&amp; value !== getFieldValue('newPassword')) {
            callback('两次输入不一致！')
        }

        // Note: 必须总是返回一个 callback，否则 validateFieldsAndScroll 无法响应
        callback()
 }
</code></pre>
</li>
<li>
<p>setState支持回调，可以在render之前进行dom focus系列的操作，hooks中的setXXX不支持回调，转变为在useEffect中进行操作，同时监听XXXstate，即可实现同样的效果</p>
</li>
<li>
<p>通过setFieldsValue的属性设置值时，该元素必须是紧接着FormItem的，不然没法设置成功，不能嵌套div之类的其他元素</p>
</li>
<li>
<p>create-react-app 报错 babel插件与实际安装的present-env版本不一致，是因为代理的问题，尝试去掉<code>用户\wmxie</code>下面的<code>.npmrc</code>文件，再重新执行，若不报错，则是代理的问题，尝试替换代理或不使用代理</p>
</li>
<li>
<p>Icon可以设置rotate来控制图标旋转的角度   <code>transform: rotate(45deg);</code></p>
</li>
<li>
<p>JavaScript之forEach循环遍历方法用于调用数组的每个元素，并将元素传递给回调数组，<code>forEach</code>是Array下的一个方法。</p>
<blockquote>
<p>注意：无法使用break等语句跳出遍历，直到所有元素都传递给调用的函数，但是可以抛出异常，提前终止循环。类似的还有map</p>
</blockquote>
</li>
<li>
<p>react-redux升级之后基本都变成了function组件，比如connect由class组件变成了function组件，需要传递ref</p>
<pre><code class="language-javascript">1. 组件是class，使用connect进行包裹
	connect(mapStateToProps,mapDispatchToProps,null,{forwardRef:true})
2. 组件是function，未使用connect
	 (1).使用forwardRef包裹组件
3. 组件是function，同时使用connect进行包裹
	 (1).使用forwardRef包裹function组件，同时connect中需要按照情况1的写法写
     (2).使用forwardRef包裹组件，使用useSelector，useDispatch，不使用connect
</code></pre>
</li>
<li>
<p>antd的FormItem在创建的时候会给组件传递ref，所以就会有15中的问题存在，需按照15中的方法执行</p>
</li>
<li>
<p>ref={ref} 这种形式 括号里的ref是React.createRef出来的 最终会被放到ref.current里</p>
<p>ref={function} 这种形式 不需要React.createRef</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native]]></title>
        <id>https://xiewangmei.github.io/post/react-native/</id>
        <link href="https://xiewangmei.github.io/post/react-native/">
        </link>
        <updated>2020-09-29T05:29:57.000Z</updated>
        <content type="html"><![CDATA[<center><h2>React Native</h2></center>
<h3 id="developer-menu">Developer Menu</h3>
<p>Andriod模拟器：可以通过Ctrl+M快键键快速打开</p>
<p>IOS模拟器：可以通过Ctrl+D快捷键快速打开</p>
<h3 id="flatlist">FlatList</h3>
<ul>
<li>FlatList会安排视图的渲染，只显示当前在屏幕上的那些元素。而那些已经渲染好了的但移动到了屏幕之外的元素，则会从原生视图结构中移除（以提高性能）</li>
</ul>
<h3 id="platform模块">Platform模块</h3>
<ul>
<li>
<p>Platform.OS上会返回<code>ios</code>，而在Android设备或模拟器上则会返回<code>android</code></p>
</li>
<li>
<p>有个实用的方法是Platform.select()，它可以以Platform.OS为key，从传入的对象中返回对应平台的值</p>
<pre><code class="language-react">import { Platform, StyleSheet } from &quot;react-native&quot;;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: &quot;red&quot;
      },
      android: {
        backgroundColor: &quot;blue&quot;
      }
    })
  }
});
</code></pre>
<p>该方法可以接受任何合法类型的参数，也可以直接用它针对不同平台返回不同的组件，</p>
<pre><code class="language-react">const Component = Platform.select({
	ios: () =&gt; require(&quot;ComponentIOS&quot;),
	android: () =&gt; require(&quot;CompnentAndroid&quot;)
})();
&lt;Component/&gt;
</code></pre>
</li>
<li>
<p>检测Android版本，在Android上，<code>Version</code>属性是一个数字，表示Android的api level：</p>
<pre><code class="language-react">import {Platform} from 'react-native';
if(Platform.Version === 25){
	console.log(&quot;Running on Nougat&quot;);
}
</code></pre>
</li>
<li>
<p>检测iOS版本，在iOS上<code>Version</code>属性是<code>-[UIDevice systemVersion]</code>的返回值，具体形式为一个表示当前系统版本的字符串，比如可能是“10.3”</p>
<pre><code class="language-react">import { Platform } from &quot;react-native&quot;;
const majorVersionIOS = parseInt(Platform.Version, 10);
if(majorVersionIOS &lt;= 9) {
	console.log(&quot;Work around a change in behavior&quot;);
}
</code></pre>
</li>
</ul>
<h3 id="特定平台扩展名">特定平台扩展名</h3>
<ul>
<li>
<p>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native会检测某个文件是否具有<code>.ios.</code>或.<code>android.</code>的扩展名，然后根据当前运行的平台自动加载正确对应的文件。比如可以创建这种组件，然后去掉平台扩展名直接引用：</p>
<pre><code class="language-javascript">BigButton.ios.js
BigButton.android.js

import BigButton from './BigButton'
</code></pre>
<p>React Native会根据运行平台的不同自动引入正确对应的组件。</p>
</li>
<li>
<p>如果希望在web端复用React Native的代码，那么还可以使用<code>.native.js</code>的扩展名。此时iOS和Android会使用<code>BigButton.native.js</code>文件，而web端会使用<code>BigButton.js</code></p>
</li>
</ul>
<h3 id="图片">图片</h3>
<h4 id="静态图片资源">静态图片资源</h4>
<ul>
<li>
<p>可以使用<code>@2x</code>，<code>@3x</code>这样的文件名后缀，来为不同的屏幕精度提供图片。比如说，iPhone7会使用check@2x.png，而iPhone 7 plus或是Nexus 5上则会使用check@3x.png。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片</p>
<p><em>注意：如果添加图片的时候packager正在运行，则可能需要重启packager以便能正确引入新添加的图片</em></p>
</li>
</ul>
<h3 id="textinput">TextInput</h3>
<ul>
<li>
<p>placeholderTextColor 设置占位文字字体颜色</p>
<pre><code class="language-jsx">&lt;TextInput placeholderTextColor=&quot;#a5a5a5&quot; /&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日积月累]]></title>
        <id>https://xiewangmei.github.io/post/日积月累/</id>
        <link href="https://xiewangmei.github.io/post/日积月累/">
        </link>
        <updated>2020-09-29T05:23:55.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>接口请求Status(blocked:other)，出现这种情况是被浏览器插件（如AdBlock插件）当广告拦截了</p>
</li>
<li>
<p>jquery 解决favicon.ico 404找不到的问题，可以在html头部添加&lt;link <em>rel</em>=&quot;shortcut icon&quot; <em>href</em>=&quot;#&quot;/&gt;</p>
</li>
<li>
<p>for..of ES6提供可以直接遍历值而不是数组下标</p>
<pre><code class="language-javascript">var myArray = [1,2,3];
for(var v of myArray){
    console.log(v);
}
//1
//2
//3
</code></pre>
<p>for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值</p>
</li>
<li>
<p>K8s kubelet &amp; kubeadm &amp; kubectl 介绍</p>
<ul>
<li>kubelet: 运行在cluster所有节点上，负责启动POD和容器</li>
<li>kubeadm: 用于初始化cluster</li>
<li>kubectl: kubenetes命令行工作，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</li>
</ul>
</li>
<li>
<p>npx create-react-app 报网络错误时，可以尝试将之前安装的npm create-react-app删掉（<code>npm uninstall -g create-react-app</code>），同时修改registry为淘宝镜像</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode常用快捷键]]></title>
        <id>https://xiewangmei.github.io/post/vscode/</id>
        <link href="https://xiewangmei.github.io/post/vscode/">
        </link>
        <updated>2020-09-29T03:33:22.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ctrl+Alt+I  插入作者注释</li>
<li>F1  打开命令面板</li>
<li>Ctrl+Shift+D 切换到调试视图</li>
<li>Ctrl+~ 打开终端调试窗口</li>
<li>F1 打开命令行</li>
</ul>
]]></content>
    </entry>
</feed>