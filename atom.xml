<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiewangmei.github.io</id>
    <title>Blog-wmxie</title>
    <updated>2020-10-09T02:33:36.627Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiewangmei.github.io"/>
    <link rel="self" href="https://xiewangmei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响~</subtitle>
    <logo>https://xiewangmei.github.io/images/avatar.png</logo>
    <icon>https://xiewangmei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blog-wmxie</rights>
    <entry>
        <title type="html"><![CDATA[React Diff]]></title>
        <id>https://xiewangmei.github.io/post/react-diff/</id>
        <link href="https://xiewangmei.github.io/post/react-diff/">
        </link>
        <updated>2020-09-29T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="虚拟dom">虚拟DOM</h2>
<p>虚拟DOM是和真实DOM相对应的。真实DOM也就是平时我们所说的DOM，它是对结构化文本的抽象表达。在web环境中，其实就是对HTML文本的一种抽象表述，每一个HTML元素对应一个DOM节点，HTML元素的层级关系也会体现在DOM节点的层级上，所有的这些DOM节点构成一棵DOM树。</p>
<p>在传统前端开发中，通过浏览器提供的一组API直接对DOM执行增删改查操作，例如<code>getElementById</code>，<code>insertBefore</code>等。这些操作看似只执行一条<code>JavaScript</code>语句，但它们的执行效率要比执行一条普通的<code>JavaScript</code>语句慢得多，尤其是对DOM进行增删改操作，每一次对DOM的修改都会引起浏览器对页面的重新布局和重新渲染，这个过程是很耗时的。所以前端性能优化里面有一条原则：<strong>尽量减少DOM操作</strong>。</p>
<p>既然直接操作DOM效率低下，那么有什么办法可以解决这个问题呢？在软件开发中，有这么一句话，<strong>软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决</strong>。DOM效率低下的这个问题同样可以通过增加一层抽象解决，<code>虚拟DOM</code>就是对真实DOM的抽象。这里需要注意，虚拟DOM并非React独有，它是一个独立的技术，只不过React使用了这项技术来提高自身的性能。</p>
<p>虚拟DOM使用<code>普通的JavaScript对象</code>来描述DOM元素，对象的结构和<code>React.CreateElement()</code>参数类似。例如，我们有下面这样的一个DOM结构：</p>
<pre><code class="language-html">&lt;div class = 'foo'&gt;
    &lt;h1&gt;
        Hello React
    &lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>相对应的虚拟DOM就可以用下面这样的对象来描述：</p>
<pre><code class="language-javascript">const virtualDom = {
    type: 'div',
    props: {
        className: 'foo',
        children: [{
            type: 'h1',
            props: {
                children: ['Hello React']    
            }
        }]    
    },
    
};
</code></pre>
<p>有了虚拟DOM这层抽象，当我们需要操作真实DOM时，就可以操作虚拟DOM这个<code>JavaScript对象</code>，速度当然要比操作真实DOM快得多。</p>
<h2 id="diff算法">Diff算法</h2>
<p>React采用声明式的API描述UI结构(JSX)，每次组件的状态或属性更新，组件的<code>render</code>方法都会返回一个新的虚拟DOM对象用来描述新的UI结构。如果每次都直接使用新的虚拟DOM结构来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响程序执行效率。事实上，React会通过比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高执行效率。这一过程就是React的调和过程<code>(Reconciliation)</code>，其中的关键就是<code>diff算法</code>。</p>
<h3 id="react-diff算法的三大策略">React-diff算法的三大策略</h3>
<h4 id="1-tree-diff-web-ui中dom节点跨层级的移动操作特别少可以忽略不计"><strong>1. Tree Diff —— Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计</strong></h4>
<p>React把树按照层级分解，在对新旧虚拟DOM进行比较时，只会对同层进行比较（节点类型，属性）。这是React-diff算法的关键点（<strong>因为组件是树形结构，需要基于该策略做diff</strong>）。</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358709820.png" alt="同层比较" loading="lazy"></figure>
<p>如图所示，React只会相互比较相同颜色框内的节点，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。由此一来，最直接的提升就是复杂度变为线型增长而不是原先的指数增长。</p>
<p>前面我们提到了同层比较，那当我们的节点发生跨层级移动，diff算法会是什么表现呢？</p>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1601358737506.png" alt="跨层级操作" loading="lazy"></figure>
<p>B节点连同它的子节点一起移动到A节点之下，直观的考虑DOM Diff应该是</p>
<pre><code class="language-jsx">R.remove(B); 
A.append(B);
</code></pre>
<p>但是，实际上<code>React</code>只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有<code>创建</code>和<code>删除</code>操作，所以当根节点发现B节点消失了，就会删除B节点及其子节点，当A发现多了一个子节点B，就会创建新的B作为其子节点，这样DOM Diff就变成：</p>
<pre><code class="language-javascript">B.destroy();
C = new C();
D = new D();
B = new B();
B.append(C);
B.append(D);
A.append(B);
</code></pre>
<p>换句话说，这里进行了较多的DOM操作，因此，我们在开发组件时，尽量保持DOM结构稳定是一种不错的选择。</p>
<h4 id="2-componnet-diff-相同类型的组件会生成相似的树形结构不同类型的两个组件将会生成不同的树形结构"><strong>2. Componnet Diff —— 相同类型的组件会生成相似的树形结构，不同类型的两个组件将会生成不同的树形结构</strong></h4>
<ul>
<li>
<p><strong>同类型组件</strong>：按照前面所说的<code>Tree Diff策略</code>继续比较虚拟DOM。需要注意的是，在这种情况下，如果用户能确定新旧虚拟DOM之间没有任何变化，React给了我们一个<code>shouldComponentUpdate()</code>方法，通过设置返回值<code>true</code>和<code>false</code>可以决定组件是否进行diff操作，用得好的话， 可以节省大量的 diff 运算时间。</p>
</li>
<li>
<p><strong>不同类型组件</strong>：该组件判定为<code>dirty componnet</code>，替换掉整个组件包括其子节点</p>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 的这种直接删除再重新创建的机制会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://xiewangmei.github.io/post-images/1601358776690.png" alt="相似组件" loading="lazy"></figure>
<h4 id="3-对于同一层级的一组兄弟节点可以通过唯一的key值来进行区分"><strong>3. 对于同一层级的一组兄弟节点，可以通过唯一的Key值来进行区分</strong></h4>
<p>当一个节点有多个子节点时，默认情况下，React只会按照顺序逐一比较两棵树上的对应子节点，一旦新旧虚拟DOM相同位置的节点对应不上，就会进行修改操作。</p>
<p>乍一看貌似没什么问题？看个栗子：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
    &lt;li&gt;javascript&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这里我们在列表最后添加一个<code>javascript</code>，对比的时候,<code>php</code>，<code>java</code>都能匹配上，然后在最后新增<code>javascript</code>，一切顺利。那我们把<code>javascript</code>加到列表首项，像这样：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li&gt;javascript&lt;/li&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这时候的结果就是：<code>php</code>更新为<code>javascript</code>，<code>java</code>更新为<code>php</code>，最后新增<code>java</code>项，<strong>每一个节点</strong>都发生了修改。</p>
<p>为了解决这种低效的更新方式，React提供了一个Key属性，用来匹配新旧虚拟DOM的子节点，在每次渲染之后，只要子节点的Key值没有变化，React就会认为这是同一个节点。上面的例子我们这样改：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li key='javascript'&gt;javascript&lt;/li&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这样React就能判断出<code>&lt;li key='javascript'&gt;javascript&lt;/li&gt;</code>节点是新增节点，其他两个节点没有发生变化，最终只需要进行一次新增节点操作即可。</p>
<p><strong>注意</strong>：有时候我们会通过数组的map方法将每个数组成员映射到一个列表元素，这里应该尽量避免用数组的index来作为Key值。因为数组中的成员顺序一旦发生改变，可能会导致大量的Key值失效，进而引起大量的修改操作。</p>
<p>避免这种写法：</p>
<pre><code class="language-jsx">&lt;ul&gt;
    (list.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;))
&lt;/ul&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>1.开发组件时，尽量保持DOM结构的稳定，有助于提升性能。例如，可以通过设置样式来控制元素的显示隐藏，而不是真正移除或添加DOM节点。</p>
<p>2.用好<code>shouldComponentUpdate()</code>方法，减少不必要的diff计算。</p>
<p>3.在一组兄弟节点中，设置合适的Key值来帮助React识别相同节点，减少不必要的DOM操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React小知识]]></title>
        <id>https://xiewangmei.github.io/post/react-knowledge/</id>
        <link href="https://xiewangmei.github.io/post/react-knowledge/">
        </link>
        <updated>2020-09-29T05:47:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react的程序流程">React的程序流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358552129.png" alt="React程序流程" loading="lazy"></figure>
<ul>
<li>在React中无论发生何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心。</li>
</ul>
<h3 id="virtual-dom">Virtual DOM</h3>
<ul>
<li>
<p>既然DOM树是对HTML的抽象，那<code>Virtual DOM</code>就是对DOM的抽象。<code>Virtual DOM</code>不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的<code>Virtual DOM</code>和上一次渲染的<code>Virtual DOM</code>，对比就会发现差别，然后修改真正的DOM树时就只要触及差别中的部分就行了。</p>
<ul>
<li>
<p>以ClickCouter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这次重新渲染，React通过<code>Virtual DOM</code>的对比发现其实只是id为clickCount的span元素中内容从0变成了1而已：</p>
<pre><code class="language-javascript">&lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;
</code></pre>
<p>React发现这次渲染要做的事情只是更换这个span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句就可以完成任务了：</p>
<pre><code class="language-javascript">document.getElementById(&quot;clickCount&quot;).innerHTML = &quot;1&quot;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="prop和state的对比">prop和state的对比</h3>
<ul>
<li><code>prop</code>用于定义外部接口，<code>state</code>用于记录内部状态</li>
<li><code>prop</code>的赋值在外部世界使用组件时，<code>state</code>的赋值在组件内部</li>
<li>组件不应该改变<code>prop</code>的值，而<code>state</code>存在的目的就是让组件来改变的</li>
</ul>
<h3 id="refrefs">ref&amp;refs</h3>
<ul>
<li>
<p><code>React</code>支持一种非常特殊的属性<font color='red'><code>ref</code></font>，可以用来绑定到render()输出的任何组件上</p>
<ul>
<li><code>ref</code>：绑定属性</li>
<li><code>refs</code>：调用的时候使用</li>
</ul>
</li>
<li>
<p>通过<code>refs</code>访问父组件方法</p>
<pre><code class="language-jsx">this.refs.subcomponents.subHandleClick();
</code></pre>
</li>
<li>
<p>为了获取真实DOM节点，html元素必须有一个<code>ref属性</code>，然后**<code>this.refs.[refName]</code>**就会返回这个真实的DOM节点。</p>
<blockquote>
<p><strong>注意</strong>：由于**this.refs.[refName]**属性获取的是真实DOM，所以必须等到虚拟DOM插入文档后，才能使用这个属性，否则获取不到。</p>
</blockquote>
</li>
</ul>
<h3 id="组件生命周期">组件生命周期</h3>
<ul>
<li>
<p><strong><code>constructor</code></strong>：构造函数是初始化状态的合适位置。若不初始化状态且不绑定方法，那就不需要为React组件定义一个构造函数。</p>
</li>
<li>
<p><strong><code>render</code></strong>：该方法是必须的，当被调用时，其应该检查<code>this.props</code>和<code>this.state</code>，并返回以下类型中的一个：</p>
<ul>
<li>
<p><strong>React元素</strong>：通常由JSX创建，该元素可能是一个原生DOM组件的表示，如<code>&lt;div/&gt;</code>，或者是一个自定义的合成组件。</p>
</li>
<li>
<p><strong>字符串或数字</strong>：这些将被渲染为DOM中的Text Node</p>
</li>
<li>
<p><strong><a href="https://segmentfault.com/a/1190000012325351">Portals</a></strong>：由<strong>ReactDOM.createPortal</strong>创建，可以将React子节点的DOM结构，渲染到React父节点之外的DOM中， portal 也一直存在于React 树上，无论它位于 DOM 树中的什么位置。</p>
<pre><code class="language-react">ReactDOM.createPortal(child, container)
</code></pre>
</li>
<li>
<p><strong>null</strong>：什么都不渲染</p>
</li>
<li>
<p><strong>布尔值</strong>：什么都不渲染，（通常存在于<code>return test &amp;&amp; &lt;child /&gt;</code>写法，其中<code>test</code>是布尔值。</p>
<p>当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong><code>componentWillMount</code></strong>：紧贴着自己组件的<code>render</code>函数之前被调用</p>
</li>
<li>
<p><strong><code>componentDidMount</code></strong>：不是紧跟着<code>render</code>之后调用，当所有的组件都调用完了，所有组件的<code>componentDidMount</code>才会一起被调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个<strong>适合实现网络请求的地方</strong>。在该方法里设置状态将<strong>会触发重渲</strong>。</p>
<blockquote>
<p>原因：<code>render</code>函数本身并不往DOM树上渲染或者装载内容，它只是返回一个<font color='blue'><code>JSX表示的对象</code></font>，然后由React库来根据返回对象决定如何渲染</p>
</blockquote>
</li>
</ul>
<h3 id="jsx">JSX</h3>
<ul>
<li>
<p>和原生HTML定义事件的唯一区别就是<code>JSX</code>采用<strong>驼峰</strong>写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，<strong>返回一个事件处理函数</strong>。React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在<strong>根节点document</strong>上为每种事件添加唯一的Listener，然后通过事件的<strong>target找到真实的触发元素</strong>。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React<strong>模拟事件系统</strong>。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。</p>
</li>
<li>
<p>在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，<strong>属性值不能是字符串而必须为对象</strong>。</p>
<pre><code class="language-jsx">&lt;div style={{color: '#ff0000', fontSize: 14}}&gt;Hello World.&lt;/div&gt;

{/*或者（注释要这么写）*/}  

var style = {
  color: '#ff0000',
  fontSize: 14
};

var node = &lt;div style={style}&gt;HelloWorld.&lt;/div&gt;;
</code></pre>
</li>
</ul>
<blockquote>
<p>**注意：**原生HTML元素名以小写字母开头，而自定义的React类名以<font color='red'><strong>大写字母</strong></font>开头，比如HelloMessage不能写成helloMessage，除此之外还需要注意组件类只能包含<font color='red'><strong>一个顶层标签</strong></font>，否则也会报错。</p>
</blockquote>
<h3 id="受控组件">受控组件</h3>
<h4 id="input标签">input标签</h4>
<ul>
<li>在React中，<code>&lt;input&gt;</code>会用<strong>value属性</strong>来代替子节点，value属性的值总是和文本输入框的最新内容一致，如果想要指定默认值，可以使用<strong>defaultValue属性</strong>。</li>
</ul>
<h4 id="textarea标签">textarea标签</h4>
<ul>
<li>在React中，<code>&lt;textarea&gt;</code>会用<strong>value属性</strong>来替代子节点。这样的话，表单中的<code>&lt;textarea&gt;</code>非常类似于使用单行输入的表单。</li>
</ul>
<h4 id="select标签">select标签</h4>
<ul>
<li>
<p>在React中，并不适用之前的<code>selected</code>属性，而是在根<code>select</code>标签上用<strong>value属性</strong>来表示选中的项。这在受控组件中更为方便。例如：</p>
<pre><code class="language-jsx">&lt;select value={this.state.value} onChange={this.handleChange}&gt;
    &lt;option value='grapefruit'&gt;Grapefruit&lt;/option&gt;
    &lt;option value='lime'&gt;Lime&lt;/option&gt;
    &lt;option value='coconut'&gt;Coconut&lt;/option&gt;
    &lt;option value='mango'&gt;Mango&lt;/option&gt;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>总结：</strong><code>&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;select&gt;</code>都十分类似——他们都通过传入一个<font color='red'><strong>value属性</strong></font>来实现对组件的控制。</p>
<h4 id="typescript中使用usedispatch">TypeScript中使用useDispatch</h4>
<pre><code class="language-javascript"> Promise.resolve(
    dispatch(
     	submitRegistryConfig(REGISTRY_DRAWER_STATEID, values, mode === &quot;edit&quot; ? &quot;PUT&quot; : &quot;POST&quot;)
 	)
 ).then(() =&gt; {
 	closeDrawer();
 	callback();
 });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React & Antd]]></title>
        <id>https://xiewangmei.github.io/post/react-and-antd/</id>
        <link href="https://xiewangmei.github.io/post/react-and-antd/">
        </link>
        <updated>2020-09-29T05:45:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>可以通过React.createContext中的Provider实现夸层级传递属性，避免繁琐的一层层传递</p>
<pre><code class="language-react">const { Provider } = React.createContext();
{......}
</code></pre>
</li>
<li>
<p>tab点击想要触发重新渲染，可以设置state里的数据发生变化，但是该state必须要使用，才会触发，不然就不会触发，可以将原本的对象返回一个新对象，比如</p>
<pre><code class="language-javascript">record={…record}
component: props =&gt; {
 return &lt;filterRoute.component {...props} /&gt;;
}
</code></pre>
</li>
<li>
<p>一行一个标签对应多个输入组件，这个需求很常见但在官方例子没看到合适的，因为官方建议：</p>
<blockquote>
<p>注意：一个 Form.Item 建议只放一个被 getFieldDecorator 装饰过的 child，当有多个被装饰过的 child 时，help required validateStatus 无法自动生成。</p>
</blockquote>
<p>所以可以通过在FormItem组件中再包一层FormItem，通过flex布局调整其布局，,这样校验的位置也是正确的，校验提示也能自动生成。</p>
<pre><code class="language-react">&lt;FormItem {...formItemLayout} label=&quot;IP地址段&quot;&gt;
     &lt;div style={{ display: &quot;flex&quot; }}&gt;
     	&lt;FormItem&gt;
        {getFieldDecorator(&quot;start&quot;, {
            rules: [{ required: true, message: &quot;该项为必填项&quot; }]
         })(
             &lt;Input style={{ width: 220 }}placeholder=&quot;请输入起始IP&quot;/&gt;
         )}
         &lt;/FormItem&gt;
		&lt;div className={styles[&quot;ip-range-div&quot;]}&gt;-&lt;/div&gt;
		&lt;FormItem&gt;
    	{getFieldDecorator(&quot;end&quot;, {
           	rules: [{ required: true, message: &quot;该项为必填项&quot; }]
   		 })(
        &lt;Input style={{ width: 220 }} placeholder=&quot;请输入结束IP&quot;/&gt;
        )}
        &lt;/FormItem&gt;
	&lt;/div&gt;
&lt;/FormItem&gt;
</code></pre>
</li>
<li>
<p>想要一个组件不被重新渲染，那么该组件的props都必须被校验为未修改才不会执行重渲染，函数执行返回的是一个新对象，比如说Drawer</p>
<pre><code class="language-React"> &lt;RegionManagerDrawer
     handleSubmitResult={this.handleSubmitResult}
     onClose={this.closeDrawer}
     // onClose={()=&gt;this.closeDrawer()}这种写法会触发重新渲染
     mode={mode}
     record={record}
     handleEdit={this.handleEdit}
 /&gt;
</code></pre>
<p>但是有一个问题：Modal 只要将destoryOnClose设置为true即可</p>
</li>
<li>
<p>antd的table控制是否展开，expandedRowKeys数组存放对应展开行的数据key，控制是否单独单元格放置展开图标<code>expandIconAsCell = {false}</code>，number设置展开图标所在的单元格索引，取一个不存在的索引可达到去掉预设图标的效果<code>expandIconColumnIndex = {-1}</code></p>
</li>
<li>
<p>table固定列的宽度，超出部分用<code>…</code>代替（针对普通table和antd）</p>
<ul>
<li>
<p>让溢出内容变成…，需要如下样式</p>
<pre><code class="language-css">overflow: hidden; //超出部分隐藏
text-overflow:ellipsis; //显示省略符来代表被修剪的文本
white-space: nowrap; //强制不换行
</code></pre>
<p>table的宽度我们并不能控制，内容会自动撑大表格列表宽度，需要给<code>table</code>加上一个样式：</p>
<pre><code class="language-css">table-layout:fixed;
</code></pre>
</li>
</ul>
</li>
<li>
<p>经过 <code>getFieldDecorator</code> 包装的控件，表单控件会自动添加 <code>value</code>，switch这种实际值不是value什么的，在form表单中可能设置不上值，需要通过<code>valuePropName</code>指定子节点的值的属性，如 Switch 的是 'checked'</p>
</li>
<li>
<p>在form中如果已经设置了initialValue:value，避免在componentDidMount（useEffect）等生命周期函数中使用this.props.form.setFieldsValue，否则会产生<code>Warning: You cannot set a form field before rendering a field associated with the value</code>，单一使用即可</p>
</li>
<li>
<p>form item的validator中必须要返回callback().，否则<code>validateFields（validateFieldsAndScroll ）</code>方法不生效</p>
<pre><code class="language-react">handleConfirmPassword = (rule, value, callback) =&gt; {
        const { getFieldValue } = this.props.form
        if (value &amp;&amp; value !== getFieldValue('newPassword')) {
            callback('两次输入不一致！')
        }

        // Note: 必须总是返回一个 callback，否则 validateFieldsAndScroll 无法响应
        callback()
 }
</code></pre>
</li>
<li>
<p>setState支持回调，可以在render之前进行dom focus系列的操作，hooks中的setXXX不支持回调，转变为在useEffect中进行操作，同时监听XXXstate，即可实现同样的效果</p>
</li>
<li>
<p>通过setFieldsValue的属性设置值时，该元素必须是紧接着FormItem的，不然没法设置成功，不能嵌套div之类的其他元素</p>
</li>
<li>
<p>create-react-app 报错 babel插件与实际安装的present-env版本不一致，是因为代理的问题，尝试去掉<code>用户\wmxie</code>下面的<code>.npmrc</code>文件，再重新执行，若不报错，则是代理的问题，尝试替换代理或不使用代理</p>
</li>
<li>
<p>Icon可以设置rotate来控制图标旋转的角度   <code>transform: rotate(45deg);</code></p>
</li>
<li>
<p>JavaScript之forEach循环遍历方法用于调用数组的每个元素，并将元素传递给回调数组，<code>forEach</code>是Array下的一个方法。</p>
<blockquote>
<p>注意：无法使用break等语句跳出遍历，直到所有元素都传递给调用的函数，但是可以抛出异常，提前终止循环。类似的还有map</p>
</blockquote>
</li>
<li>
<p>react-redux升级之后基本都变成了function组件，比如connect由class组件变成了function组件，需要传递ref</p>
<pre><code class="language-javascript">1. 组件是class，使用connect进行包裹
	connect(mapStateToProps,mapDispatchToProps,null,{forwardRef:true})
2. 组件是function，未使用connect
	 (1).使用forwardRef包裹组件
3. 组件是function，同时使用connect进行包裹
	 (1).使用forwardRef包裹function组件，同时connect中需要按照情况1的写法写
     (2).使用forwardRef包裹组件，使用useSelector，useDispatch，不使用connect
</code></pre>
</li>
<li>
<p>antd的FormItem在创建的时候会给组件传递ref，所以就会有15中的问题存在，需按照15中的方法执行</p>
</li>
<li>
<p>ref={ref} 这种形式 括号里的ref是React.createRef出来的 最终会被放到ref.current里</p>
<p>ref={function} 这种形式 不需要React.createRef</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native]]></title>
        <id>https://xiewangmei.github.io/post/react-native/</id>
        <link href="https://xiewangmei.github.io/post/react-native/">
        </link>
        <updated>2020-09-29T05:29:57.000Z</updated>
        <content type="html"><![CDATA[<center><h2>React Native</h2></center>
<h3 id="developer-menu">Developer Menu</h3>
<p>Andriod模拟器：可以通过Ctrl+M快键键快速打开</p>
<p>IOS模拟器：可以通过Ctrl+D快捷键快速打开</p>
<h3 id="flatlist">FlatList</h3>
<ul>
<li>FlatList会安排视图的渲染，只显示当前在屏幕上的那些元素。而那些已经渲染好了的但移动到了屏幕之外的元素，则会从原生视图结构中移除（以提高性能）</li>
</ul>
<h3 id="platform模块">Platform模块</h3>
<ul>
<li>
<p>Platform.OS上会返回<code>ios</code>，而在Android设备或模拟器上则会返回<code>android</code></p>
</li>
<li>
<p>有个实用的方法是Platform.select()，它可以以Platform.OS为key，从传入的对象中返回对应平台的值</p>
<pre><code class="language-react">import { Platform, StyleSheet } from &quot;react-native&quot;;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: &quot;red&quot;
      },
      android: {
        backgroundColor: &quot;blue&quot;
      }
    })
  }
});
</code></pre>
<p>该方法可以接受任何合法类型的参数，也可以直接用它针对不同平台返回不同的组件，</p>
<pre><code class="language-react">const Component = Platform.select({
	ios: () =&gt; require(&quot;ComponentIOS&quot;),
	android: () =&gt; require(&quot;CompnentAndroid&quot;)
})();
&lt;Component/&gt;
</code></pre>
</li>
<li>
<p>检测Android版本，在Android上，<code>Version</code>属性是一个数字，表示Android的api level：</p>
<pre><code class="language-react">import {Platform} from 'react-native';
if(Platform.Version === 25){
	console.log(&quot;Running on Nougat&quot;);
}
</code></pre>
</li>
<li>
<p>检测iOS版本，在iOS上<code>Version</code>属性是<code>-[UIDevice systemVersion]</code>的返回值，具体形式为一个表示当前系统版本的字符串，比如可能是“10.3”</p>
<pre><code class="language-react">import { Platform } from &quot;react-native&quot;;
const majorVersionIOS = parseInt(Platform.Version, 10);
if(majorVersionIOS &lt;= 9) {
	console.log(&quot;Work around a change in behavior&quot;);
}
</code></pre>
</li>
</ul>
<h3 id="特定平台扩展名">特定平台扩展名</h3>
<ul>
<li>
<p>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native会检测某个文件是否具有<code>.ios.</code>或.<code>android.</code>的扩展名，然后根据当前运行的平台自动加载正确对应的文件。比如可以创建这种组件，然后去掉平台扩展名直接引用：</p>
<pre><code class="language-javascript">BigButton.ios.js
BigButton.android.js

import BigButton from './BigButton'
</code></pre>
<p>React Native会根据运行平台的不同自动引入正确对应的组件。</p>
</li>
<li>
<p>如果希望在web端复用React Native的代码，那么还可以使用<code>.native.js</code>的扩展名。此时iOS和Android会使用<code>BigButton.native.js</code>文件，而web端会使用<code>BigButton.js</code></p>
</li>
</ul>
<h3 id="图片">图片</h3>
<h4 id="静态图片资源">静态图片资源</h4>
<ul>
<li>
<p>可以使用<code>@2x</code>，<code>@3x</code>这样的文件名后缀，来为不同的屏幕精度提供图片。比如说，iPhone7会使用check@2x.png，而iPhone 7 plus或是Nexus 5上则会使用check@3x.png。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片</p>
<p><em>注意：如果添加图片的时候packager正在运行，则可能需要重启packager以便能正确引入新添加的图片</em></p>
</li>
</ul>
<h3 id="textinput">TextInput</h3>
<ul>
<li>
<p>placeholderTextColor 设置占位文字字体颜色</p>
<pre><code class="language-jsx">&lt;TextInput placeholderTextColor=&quot;#a5a5a5&quot; /&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日积月累]]></title>
        <id>https://xiewangmei.github.io/post/日积月累/</id>
        <link href="https://xiewangmei.github.io/post/日积月累/">
        </link>
        <updated>2020-09-29T05:23:55.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>接口请求Status(blocked:other)，出现这种情况是被浏览器插件（如AdBlock插件）当广告拦截了</p>
</li>
<li>
<p>jquery 解决favicon.ico 404找不到的问题，可以在html头部添加&lt;link <em>rel</em>=&quot;shortcut icon&quot; <em>href</em>=&quot;#&quot;/&gt;</p>
</li>
<li>
<p>for..of ES6提供可以直接遍历值而不是数组下标</p>
<pre><code class="language-javascript">var myArray = [1,2,3];
for(var v of myArray){
    console.log(v);
}
//1
//2
//3
</code></pre>
<p>for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值</p>
</li>
<li>
<p>K8s kubelet &amp; kubeadm &amp; kubectl 介绍</p>
<ul>
<li>kubelet: 运行在cluster所有节点上，负责启动POD和容器</li>
<li>kubeadm: 用于初始化cluster</li>
<li>kubectl: kubenetes命令行工作，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</li>
</ul>
</li>
<li>
<p>npx create-react-app 报网络错误时，可以尝试将之前安装的npm create-react-app删掉（<code>npm uninstall -g create-react-app</code>），同时修改registry为淘宝镜像</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode常用快捷键]]></title>
        <id>https://xiewangmei.github.io/post/vscode/</id>
        <link href="https://xiewangmei.github.io/post/vscode/">
        </link>
        <updated>2020-09-29T03:33:22.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ctrl+Alt+I  插入作者注释</li>
<li>F1  打开命令面板</li>
<li>Ctrl+Shift+D 切换到调试视图</li>
<li>Ctrl+~ 打开终端调试窗口</li>
<li>F1 打开命令行</li>
</ul>
]]></content>
    </entry>
</feed>