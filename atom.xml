<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiewangmei.github.io</id>
    <title>Blog-wmxie</title>
    <updated>2020-10-15T02:14:25.127Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiewangmei.github.io"/>
    <link rel="self" href="https://xiewangmei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响~</subtitle>
    <logo>https://xiewangmei.github.io/images/avatar.png</logo>
    <icon>https://xiewangmei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blog-wmxie</rights>
    <entry>
        <title type="html"><![CDATA[SSE（Server Sent Events）简介]]></title>
        <id>https://xiewangmei.github.io/post/server-sent-events-introduce/</id>
        <link href="https://xiewangmei.github.io/post/server-sent-events-introduce/">
        </link>
        <updated>2020-10-15T02:12:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常见的web端即时通信技术">常见的Web端即时通信技术</h2>
<ul>
<li>
<p>短轮询</p>
<p>浏览器每隔一段时间向后台发请求，服务端在收到请求后，无论是否有数据更新，都直接进行响应。这种方式在我们的日常开发中还是比较常见的，例如HSM首页时间轴，智源大屏等。</p>
<p>这种方式的优点是比较简单，易于理解，实现起来也没有难度；缺点是数据非实时，并且需要不断地建立HTTP连接，严重浪费了服务器和客户端的资源，例如：大量用户同时位于基于短轮询的应用中，每一个用户都会不停地向服务器发请求，导致服务器压力倍增，用户越多，服务器压力越大，最终崩溃。</p>
</li>
<li>
<p>长轮询（Comet）</p>
<p>浏览器向服务器发起一个请求，当服务器收到发来的请求后，先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)后关闭连接。短轮询和长轮询的区别是：短轮询中服务器对请求立即响应，而长轮询中服务器等待新的数据到来才响应，因此实现了服务器端实时推送，减少了页面的请求次数。主要应用场景有体育比赛比分和股票报价等。</p>
</li>
<li>
<p>Websocket</p>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。它的出现使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。</p>
<p>WebSocket的优点是实现了双向通信，缺点是服务器端的逻辑比较复杂。</p>
</li>
<li>
<p>SSE</p>
<p>SSE的原理也是HTML5新增的一个功能，它的基本原理是客户端向服务器发送一个HTTP请求，保持长连接，服务器在必要时（例如：数据发生变化）<strong>单向</strong>地向客户端推送“信息”。</p>
<p>SSE的优势很明显，它不需要频繁建立客户端与服务端的连接，节省了网络资源。</p>
</li>
</ul>
<h2 id="sse的本质">SSE的本质</h2>
<p>严格地说，HTTP 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。</p>
<p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p>
<p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE，其他浏览器都支持。</p>
<h2 id="如何使用">如何使用</h2>
<h3 id="客户端">客户端</h3>
<p>对于客户端来说，要想使用SSE，需要借助于<code>EventSource</code>对象，如果浏览器不支持<code>EventSource</code>，可以加一个<a href="https://github.com/EventSource/eventsource">polyfill</a>。</p>
<pre><code class="language-javascript">const eventSource = new EventSource(url);
</code></pre>
<p>上面的<code>url</code>可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开<code>withCredentials</code>属性，表示是否一起发送 Cookie。</p>
<pre><code class="language-javascript">const eventSource = new EventSource(url, { withCredentials: true });
</code></pre>
<p><code>EventSource</code>实例的<code>readyState</code>属性，表明连接的当前状态。该属性只读，可以取以下值：</p>
<ul>
<li>0：相当于常量<code>EventSource.CONNECTING</code>，表示连接还未建立，或者断线正在重连。</li>
<li>1：相当于常量<code>EventSource.OPEN</code>，表示连接已经建立，可以接受数据。</li>
<li>2：相当于常量<code>EventSource.CLOSED</code>，表示连接已断，且不会重连。</li>
</ul>
<p><code>EventSource</code>实例在创建时，就会尝试跟服务器连接，当连接成功建立，会触发<code>open</code>事件，我们可以对其进行监听：</p>
<pre><code class="language-javascript">eventSource.onopen = event =&gt; console.log(&quot;成功建立连接&quot;);
// 或者
eventSource.addEventListener(&quot;open&quot;, event =&gt; console.log(&quot;成功建立连接&quot;), false);
</code></pre>
<p>连接建立成功后，客户端准备就绪，时刻接收服务器推送过来的数据，收到一条数据就会触发一次<code>message</code>事件，同样地，可以监听该事件：</p>
<pre><code class="language-javascript">eventSource.ommessage = event =&gt; console.log(event.data);
</code></pre>
<p>上述代码中，<code>event</code>的<code>data</code>属性就是服务端向客户端推送的数据，注意这里的数据都是<strong>文本格式</strong>。如果项目中要求数据结构规范，可以在服务器端选择返回JSON串，前端再利用<code>JSON.parse</code>转成JSON对象。</p>
<p>如果发生通信错误（例如连接中断），就会触发<code>error</code>事件，同样地，可以监听该事件：</p>
<pre><code class="language-javascript">eventSource.onerror = event =&gt; console.log(&quot;发生错误&quot;);
</code></pre>
<p>当客户端不再需要接收服务端的推送数据时，可以通过<code>close</code>方法关闭连接</p>
<pre><code class="language-javascript">eventSource.close();
</code></pre>
<p>默认情况下，服务器推送的数据，总是会触发<code>EventSource</code>的<code>message</code>事件。除此之外，SSE还支持自定义事件，这时收到的数据不会触发<code>message</code>事件，添加监听只能通过<code>addEventListener</code>的方式。</p>
<pre><code class="language-javascript">// 对push事件进行监听
eventSource.addEventListener(&quot;push&quot;, event =&gt; console.log(event.data), false);
</code></pre>
<h3 id="服务端">服务端</h3>
<p>服务端向客户端发送的数据，必须是UTF-8编码的文本，具有如下的HTTP头信息：</p>
<pre><code class="language-markup">Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
</code></pre>
<p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是如下格式：</p>
<pre><code class="language-csharp">[field]: value\n
</code></pre>
<p>上面的<code>field</code>可以取四个值：</p>
<pre><code class="language-csharp">data  //数据项
event //事件项 默认message
id    //数据标识符用id字段表示，相当于每一条数据的编号
retry //重连时间
</code></pre>
<p>此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。</p>
<pre><code class="language-javascript">: This is a comment
</code></pre>
<h4 id="data字段">data字段</h4>
<p>数据内容用<code>data</code>字段表示：</p>
<pre><code class="language-javascript">data: hello world\n\n
</code></pre>
<p>如果数据较长，可以分成多行，最后一行用<code>\n\n</code>结尾，前面行都用<code>\n</code>结尾：</p>
<pre><code class="language-javascript">data: first line data\n
data: second line data\n
</code></pre>
<h4 id="event字段">event字段</h4>
<p><code>event</code>字段表示自定义的事件，默认是<code>message</code>事件</p>
<pre><code class="language-javascript">event: greeting\n      //greeting事件
data: Hello, xyqiu\n\n //greeting事件数据: Hello, xyqiu

data: Hello, xyiqu\n\n //message事件,数据: Hello, xyqiu

event: goodbye\n       //goodbye事件
data: Bye, xyqiu\n\n   //goodbye事件数据: Bye, xyqiu
</code></pre>
<h4 id="id字段">id字段</h4>
<p>数据标识符用<code>id</code>字段表示，相当于每一条数据的编号。</p>
<pre><code class="language-javascript">id: msg1\n
data: message\n\n
</code></pre>
<p>浏览器用<code>lastEventId</code>属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的<code>Last-Event-ID</code>头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p>
<h4 id="retry字段">retry字段</h4>
<p>服务器可以用<code>retry</code>字段，指定浏览器重新发起连接的时间间隔。</p>
<pre><code class="language-javascript">retry: 10000\n
</code></pre>
<h3 id="实战">实战</h3>
<p>实现一个React时钟组件，时间由服务端推送。</p>
<p>考虑到一个Web应用中可能会有多处需要使用推送，我们实现一个<code>EventSource</code>容器组件：</p>
<pre><code class="language-jsx">// EventSourceContainer.js
import { useEffect } from &quot;react&quot;;
export default ({
  url,
  onOpen = _ =&gt; _,
  onMessage = _ =&gt; _,
  onError = _ =&gt; _,
  children
}) =&gt; {
  useEffect(() =&gt; {
    const source = new EventSource(url);
    source.onopen = onOpen;
    source.onmessage = onMessage;
    source.onerror = onError;
  }, [url]);
  return children;
};
</code></pre>
<p>在时钟组件中引入<code>EventSource</code>容器组件：</p>
<pre><code class="language-jsx">// Clock.js
import React, { useState } from &quot;react&quot;;
import EventSource from &quot;./EventSourceContainer&quot;;
export default () =&gt; {
  const [time, setTime] = useState(null);
  return (
    &lt;EventSource 
      url=&quot;http://localhost:9999/event-source&quot;
      onMessage={({ data }) =&gt; setTime(data)}
    &gt;
      当前时间：{time}
    &lt;/EventSource&gt;
  );
};
</code></pre>
<p>后台我们用Node来实现：</p>
<pre><code class="language-javascript">// Server.js
const http = require(&quot;http&quot;);

http
  .createServer(function(req, res) {
    if (req.url === &quot;/event-source&quot;) {
      res.writeHead(200, {
        &quot;Content-Type&quot;: &quot;text/event-stream&quot;,
        &quot;Cache-Control&quot;: &quot;no-cache&quot;,
        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
        Connection: &quot;keep-alive&quot;
      });
      res.write(&quot;retry: 10000\n&quot;);
      res.write(&quot;data: &quot; + new Date() + &quot;\n\n&quot;);

      interval = setInterval(function() {
        res.write(&quot;data: &quot; + new Date() + &quot;\n\n&quot;);
      }, 1000);

      req.connection.addListener(&quot;close&quot;, () =&gt; clearInterval(interval), false);
    }
  })
  .listen(9999);
</code></pre>
<p>启动服务器：</p>
<pre><code class="language-bash">node ./Server.js
</code></pre>
<p>效果</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602728030468.gif" alt="Clock" loading="lazy"></figure>
<p>在有些项目中，往往会要求全局推送，使得项目中的任意组件在需要时都能获取到最新数据，这时，可以考虑结合redux，各自从store中获取最新数据，感兴趣的同学可以尝试一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reselect 简介]]></title>
        <id>https://xiewangmei.github.io/post/reselect-introduce/</id>
        <link href="https://xiewangmei.github.io/post/reselect-introduce/">
        </link>
        <updated>2020-10-15T02:10:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我们平时在使用<code>react-redux</code>时，用到最多的函数大概就是<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。其中，</p>
<p><code>mapStateToProps</code>函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上，它的第一个参数就是 Redux 的整个状态树(state)：</p>
<pre><code class="language-jsx">const Counter = props =&gt; &lt;div&gt;Count: {props.count}&lt;/div&gt;;
const mapStateToProps = state =&gt; ({ count: state.count });
export default connect(mapStateToProps)(Counter);
</code></pre>
<p>上述代码里，我们从<code>state</code>中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>Counter</code>组件的<code>props</code>中会有一个 <code>count</code>字段。</p>
<p>一切看起来很完美。但是仔细想一下，每次状态树更新之后，redux 都会调用一次<code>mapStateToProps</code>，当我们的应用足够大，组件众多时，这里面的大量冗余计算就值得重视了。</p>
<p><strong>这个时候就需要 Reselect 出马了</strong></p>
<h2 id="正文">正文</h2>
<p>我们先看一个小栗子：</p>
<p>假设我们有一组复选框，用来罗列各个商品的名称和价钱，底部用来展示我们选择商品的总价，我们用 redux 实现：</p>
<pre><code class="language-javascript">const getItems = state =&gt; state.items;

const getTotal1 = createSelector(
  getItems,
  items =&gt; {
    console.log(&quot;total-with-reselect 将要计算&quot;);
    return items.reduce(
      (acc, item) =&gt; acc + (item.checked ? item.price : 0),
      0
    );
  }
);

const getTotal2 = state =&gt; {
  console.log(&quot;total-without-reselect 将要计算&quot;);
  return state.items.reduce(
    (acc, item) =&gt; acc + (item.checked ? item.price : 0),
    0
  );
};

const mapStateToProps = state =&gt; ({
  total1: getTotal1(state),
  total2: getTotal2(state)
});
</code></pre>
<p>我们通过<code>createSelector</code>创建了一个记忆选择器<code>getTotal1</code>，另外创建了一个不带缓存的求和函数<code>getTotal2</code>。另外，我们在页面中加一个 input 输入框，并且将其值绑定到 redux 的 state 中，用作干扰项。</p>
<p>结果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602727927376.gif" alt="实验结果" loading="lazy"></figure>
<p><strong>对比发现，从 state 中取值的方式有一些细微改变</strong>：<code>getTotal1</code>是通过<code>getItems</code>提取 state 中的源数据，然后再通过一个包装后的函数计算总和；<code>getTotal2</code>则是直接从 state 中拿值并计算总和。</p>
<p>前者的好处是：<code>getItems</code>返回值不变时，计算函数不会重新执行。也就是说，当 state 中的<code>items</code>没有变化时，reselect 会直接返回上一次计算缓存的结果，避免多余的重复计算。</p>
<p>那么<code>reselect</code>是如何实现这一机制的呢？看一下源码：</p>
<pre><code class="language-javascript">/**
 * 默认的比较函数
 * @param {*} a 待比较项
 * @param {*} b 待比较项
 */
function defaultEqualityCheck(a, b) {
  return a === b;
}

/**
 * 参数是否浅等
 * @param {Function} equalityCheck 比较函数
 * @param {Object} prev 前一次参数
 * @param {Object} next 后一次参数
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  const length = prev.length;
  for (let i = 0; i &lt; length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

/**
 * 默认的记忆函数(核心)
 * @param {Function} func 计算结果函数
 * @param {Function} equalityCheck 比较函数
 */
export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) {
  // 缓存上次的参数
  let lastArgs = null;
  // 缓存上次的结果
  let lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function() {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

/**
 * 获取input-selectors数组
 * @param {Array} funcs input-selectors数组
 */
function getDependencies(funcs) {
  // input-selectors数组可以有两种形式:
  // 1.[input-selector1, input-selector2...]
  // 2.[[input-selector1, input-selector2...]]
  const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(dep =&gt; typeof dep === &quot;function&quot;)) {
    const dependencyTypes = dependencies.map(dep =&gt; typeof dep).join(&quot;, &quot;);
    throw new Error(
      &quot;Selector creators expect all input-selectors to be functions, &quot; +
        `instead received the following types: [${dependencyTypes}]`
    );
  }

  return dependencies;
}

/**
 * 选择器创建器创建方法
 * @param {Function} memoize 记忆函数
 * @param  {...any} memoizeOptions 记忆函数参数(可不传)
 */
export function createSelectorCreator(memoize, ...memoizeOptions) {
  // funcs: 创建选择器传入的input-selectors和resultFunc
  return (...funcs) =&gt; {
    let recomputations = 0;
    const resultFunc = funcs.pop();
    const dependencies = getDependencies(funcs);

    // 真正的记忆函数
    // createSelector方法中,memoize就是defaultMemoize
    const memoizedResultFunc = memoize(function() {
      recomputations++;
      // apply arguments instead of spreading for performance.
      // 这里arguments是各个依赖项(input-selector)执行结果的数组(下文的params)
      return resultFunc.apply(null, arguments);
    }, ...memoizeOptions);

    // 内部二次优化: 使用完全相同的参数(state)调用选择器，则不需要再次遍历依赖项(input-selectors)
    // 因为reducer是不一定会返回一个新的state，所以state没变的时候，真正的记忆函数就不用被调用。
    const selector = memoize(function() {
      const params = [];
      const length = dependencies.length;

      for (let i = 0; i &lt; length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        // 这里arguments是state
        // 根据传入的state计算每个input-selector结果, 并将结果push到params数组中
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      // 调用真正的记忆函数, 并返回结果
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.dependencies = dependencies;
    selector.recomputations = () =&gt; recomputations;
    selector.resetRecomputations = () =&gt; (recomputations = 0);
    return selector;
  };
}

// 默认的选择器创建方法
export const createSelector = createSelectorCreator(defaultMemoize);

export function createStructuredSelector(
  selectors,
  selectorCreator = createSelector
) {
  if (typeof selectors !== &quot;object&quot;) {
    throw new Error(
      &quot;createStructuredSelector expects first argument to be an object &quot; +
        `where each property is a selector, instead received a ${typeof selectors}`
    );
  }
  const objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(key =&gt; selectors[key]), (...values) =&gt; {
    return values.reduce((composition, value, index) =&gt; {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}
</code></pre>
<p>阅读完源码发现，这个库的代码量很小，主要就是采用了闭包 + 高阶函数来实现，核心方法其实就是<code>defaultMemoize</code>。</p>
<h2 id="思考">思考</h2>
<p>由于 Reselect 缓存结果这一特性，我们可以将其延伸一下，不一定非要结合 redux 使用。</p>
<p>例如，给定一组坐标数据绘制图表：</p>
<pre><code class="language-javascript">const data = [
  { x: 1, y: 3 },
  { x: 2, y: 7 },
  { x: 3, y: 2 },
  { x: 4, y: 9 },
  { x: 5, y: 3 }
];
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1602727891483.png" alt="绘图" loading="lazy"></figure>
<h3 id="普通写法"><code>普通写法</code></h3>
<pre><code class="language-javascript">// 假定有一个画图API:DrawAPI
const drawFn = DrawAPI.draw;
</code></pre>
<p>普通写法，每次后台来了新数据时，无论具体的值是否发生变化都重新绘制，势必会造成不必要的性能浪费。</p>
<h3 id="进阶写法"><code>进阶写法</code></h3>
<pre><code class="language-javascript">import { defaultMemoize } from &quot;reselect&quot;;

const checkEqualFn = (oldData, newData) =&gt; {
  if (oldData.length !== newData.length) {
    return false;
  } else {
    const length = oldData.length;
    for (let i = 0; i &lt; length; i++) {
      const { x: xOld, y: yOld } = oldData[i];
      const { x: xNew, y: yNew } = newData[i];
      if (xOld !== xNew || yOld !== yNew) {
        return false;
      }
    }
    return true;
  }
};

const drawFn = defaultMomize(DrawAPI.draw, checkEqualFn);
</code></pre>
<p>进阶写法，只有当后台给的数据发生变化时，才重新绘制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reselect库介绍]]></title>
        <id>https://xiewangmei.github.io/post/reselect-middleware/</id>
        <link href="https://xiewangmei.github.io/post/reselect-middleware/">
        </link>
        <updated>2020-10-15T02:08:20.000Z</updated>
        <content type="html"><![CDATA[<p><code>Reselect</code>是redux官方社区的一个选择器库，它有以下几个特点：</p>
<ul>
<li>选择器可以计算派生数据，允许store存储最小化的state。</li>
<li>选择器是高效的，只有参数变了它才会去重新计算。</li>
<li>选择器支持组合，可以当做其他选择器的输入。</li>
</ul>
<p>下面是一个<code>reselect</code>库的实例：</p>
<pre><code class="language-jsx">import { createSelector } from 'reselect';

const shopItemSelector = state =&gt; state.shop.items;
const taxPercentSelector = state =&gt; state.shop.taxPercent;

const subTotalSelector = createSelector(
    shopItemSelector,
    items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)
);

const taxSelector = createSelector(
    subtotalSelector,
    taxPercentSelector,
    (subtotal, tax) =&gt; subtotal * (taxPercent / 100)
);

export const totalSelector = createSelector(
    subtotalSelector,
    taxSelector,
    (subtotal, tax) =&gt; ({ total: subtotal + tax })
);

const exampleState = {
    shop: {
        taxPercent: 8,
        items: [
            { name: 'apple', value: 1.20 },
            { name: 'orange', value: 0.95 }
        ]
    }
};

console.log(subTotalSelector(exampleState));//2.15
console.log(taxSelector(exampleState));//0.172
console.log(totalSelector(exampleState));//{ total: 2.322 }
</code></pre>
<h2 id="为什么需要选择器">为什么需要选择器</h2>
<p>本节的例子是基于redux官方文档的TodoList应用进行修改：</p>
<h4 id="containersvisibletodolistjs"><code>containers/VisibleTodoList.js</code></h4>
<pre><code class="language-jsx">import { connect } from 'react-redux';
import { toggleTodo } from '../actions';
import TodoList from '../components/TodoList';

const getVisibleTodos = (todos, filter) =&gt; {
    switch (filter) {
        case &quot;SHOW_ALL&quot;:
            return todos;
        case &quot;SHOW_COMPLETED&quot;:
            return todos.filter(t =&gt; t.completed);
        case &quot;SHOW_ACTIVE&quot;:
            return todos.filter(t =&gt; !t.completed);
    }
};

const mapStateToProps = state =&gt; {
    return {
        todos: getVisibleTodos(state.todos, state.visiblityFilter)
    };
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        onTodoClick: id =&gt; dispatch(toggleTodo(id))
    };
};

export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
</code></pre>
<p>在上面的例子中，<code>mapStateToProps</code>调用<code>getVisibleTodos</code>来计算<code>todos</code>。这种做法的确奏效，不过有个弊端：每次state树更新之后<code>todos</code>都要重新计算，如果状态树很大或者计算开销很大，这种模式就会带来性能问题。<code>Resekect</code>库可以避免这些不必要的重复计算。</p>
<h3 id="创建一个记忆选择器">创建一个记忆选择器</h3>
<p>我们将用一个<code>记忆选择器</code>替换<code>getVisibleTodos</code>方法，该选择器在<code>state.todos</code>或者<code>state.visibilityFilter</code>值更改时重新计算<code>todos</code>，但在状态树的其它不相关部分发生更改时不重新计算<code>todos</code>。</p>
<p><code>Reselect</code>提供了一个<code>createSelector()</code>方法用来创建<code>记忆选择器</code>。<code>createSelector()</code>接收一个<strong>输入选择器数组</strong>和一个<strong>转换函数</strong>作为参数。如果状态树的变化导致某个输入选择器的值发生变化，选择器将使用输入选择器的值作为参数来调用其转换函数，并返回结果。如果输入选择器的值与上一次调用相同，则选择器会返回上一次计算的值，而不是调用转换函数。</p>
<p>现在我们来定义一个名为<code>getVisibleTodos</code>的记忆选择器来替换上面的非记忆版本：</p>
<h4 id="selectorsindexjs"><code>selectors/index.js</code></h4>
<pre><code class="language-javascript">import { createSelector } from 'reselect';

const getVisibilityFilter = state =&gt; state.visibilityFilter;
const getTodos = state =&gt; state.todos;

export const getVisibleTodos = createSelector(
    [getVisibilityFilter, getTodos],
    (visibilityFilter, todos) =&gt; {
        switch (visibilityFilter) {
            case 'SHOW_ALL':
                return todos;
            case 'SHOW_COMPLETED':
                return todos.filter(t =&gt; t.completed);
            case 'SHOW_ACTIVE':
                return todos.filter(t =&gt; !t.completed);
        }
    }
);
</code></pre>
<p>在上面的例子中，<code>getVisibilityFilter</code>和<code>getTodos</code>都是输入选择器。它们被创建为普通的非记忆选择器，因为他们不对所选数据进行转换。而<code>getVisibleTodos</code>就是一个记忆选择器，它以<code>getVisibilityFilter</code>和<code>getTodos</code>为输入选择器，并且接收一个转换函数用来计算过滤后的待办事项列表。</p>
<h3 id="选择器组合">选择器组合</h3>
<p>记忆选择器本身可以是另一个记忆选择器的输入选择器，像下面例子中的<code>getVisibleTodos</code>就是另一个选择器(该选择器通过关键字进一步过滤todos)的输入选择器：</p>
<pre><code class="language-javascript">const getKeyword = state =&gt; state.keyword;
const getVisibleTodosFilteredByKeyword = createSelector(
  [getVisibleTodos, getKeyword],
  (visibleTodos, keyword) =&gt; visibleTodos.filter(todos =&gt; todo.text.includes(keyword))
);
</code></pre>
<h3 id="连接选择器到redux-store">连接选择器到Redux Store</h3>
<p>如果开发人员用了React Redux的话，可以在<code>mapStateToProps</code>中像普通函数一样调用selectors：</p>
<h4 id="containersvisibletodolistjs-2"><code>containers/VisibleTodoList.js</code></h4>
<pre><code class="language-javascript">import { connect } from 'react-redux';
import { toggleTodo } from '../actions';
import TodoList from '../components/TodoList';
import { getVisibleTodos } from '../selectors';

const mapStateToProps = state =&gt; ({ todos: getVisibleTodos(state) });
const mapDispatchToProps = dispatch =&gt; ({ onTodoClick: id =&gt; dispatch(toggleTodo(id)) });
const VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);

export default VisibleTodoList;
</code></pre>
<h3 id="在选择器中访问props">在选择器中访问props</h3>
<p>到目前为止，我们只见过选择器接收state为参数，但是它也可以接收props。</p>
<p>下面的例子里<code>App</code>组件中渲染了三个<code>VisibleTodoList</code>组件，每个都包含一个<code>listId</code>属性：</p>
<h4 id="componentsappjs"><code>components/App.js</code></h4>
<pre><code class="language-jsx">import React from 'react';
import Footer from './Footer';
import AddTodo from '../containers/AddTodo';
import VisibleTodoList from '../containers/VisibleTodoList';

const App = () =&gt; (
  &lt;div&gt;
    &lt;VisibleTodoList listId='1' /&gt;
    &lt;VisibleTodoList listId='2' /&gt;
    &lt;VisibleTodoList listId='3' /&gt;
  &lt;/div&gt;
)
</code></pre>
<p>每个<code>VisibleTodoList</code>容器应该根据不同的<code>listId</code>属性来选择不同的状态切片，所以我们来改下<code>getVisibilityFilter</code>和<code>getTodos</code>让它们接收props参数：</p>
<h4 id="selectorstodoselectorsjs">selectors/todoSelectors.js</h4>
<pre><code class="language-javascript">import { createSelector } from 'reselect';

const getVisibilityFilter =  (state, props) =&gt; {
    return state.todoLists[props.listId].VisibilityFilter;
};
const getTodos = (state, props) =&gt; {
    return state.todoLists[props.listId].todos;
};
const getVisibilityTodos = createSelector(
    [ getVisibilityFilter, getTodos ],
    (visibilityFilter, todos) =&gt; {
        switch (visibilityFilter) {
            case 'SHOW_COMPLETED':
                return todos.filter(todo =&gt; todo.completed);
            case 'SHOW_ACTIVE':
                return todos.filter(todo =&gt; !todo.completed);
            default:
                return todos;
        }
    }
);

export defaults getVisibleTodos;
</code></pre>
<p><code>props</code>可以从<code>mapStateToProps</code>中传给<code>getVisibleTodos</code>：</p>
<pre><code class="language-javascript">const mapStateToProps = (state, props) =&gt; ({ todos: getVisibleTodos(state, props)});
</code></pre>
<p>所以现在<code>getVisibleTodos</code>访问到<code>props</code>，而且一切看似很OK。</p>
<p><strong>但是有一个问题！</strong></p>
<p>将<code>getVisibleTodos</code>选择器和多个<code>VisibleTodoList</code>容器实例一起使用时将不会正确记忆：</p>
<h4 id="containersvisibletodolistjs-3"><code>containers/VisibleTodoList.js</code></h4>
<pre><code class="language-javascript">import { connect } from 'react-redux';
import { toggleTodo } from '../actions';
import TodoList from '../components/TodoList';
import { getVisibleTodos } from '../selectors';

const mapStateToProps = (state, props) =&gt; {
    return {
        // WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE
        todos: getVisibleTodos(state,props)
    }
};
const maoDispatchToProps = dispatch =&gt; {
    return {
        onTodoClick: id =&gt; dispatch(toggleTodo(id));
    };
};
const VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);

export default VisibleTodoList;
</code></pre>
<p>使用<code>createSelector</code>创建的选择器的缓存大小为1，并且只有当其参数集与前一组参数集相同时才返回缓存的值。如果我们来回交替渲染<code>&lt;VisibleTodoList listId='1' /&gt;</code>和<code>&lt;VisibleTodoList listId='2 /&gt;'</code>，那么共享选择器会交替接收<code>listId:1</code>和<code>listId:2</code>作为其props参数。这将会导致每次调用都是不同的参数，所以选择器将总是重新计算而不是返回缓存值。在下一节中我们将了解如何克服这一限制。</p>
<h3 id="跨多个组件实例共享带props的选择器">跨多个组件实例共享带props的选择器</h3>
<p>要在多个<code>VisibleTodoList</code>实例之间共享选择器，同时传入props并保留缓存，组件的每个实例都需要一份私有的选择器副本。</p>
<p>让我们创建一个名为<code>makeGetVisibleTodos</code>的函数，该函数每次调用时都返回<code>getVisibleTodos</code>选择器的新副本：</p>
<h4 id="selectorstodoselectorsjs-2"><code>selectors/todoSelectors.js</code></h4>
<pre><code class="language-javascript">import { createSelector } from 'reselect';

const getVisibilityFilter =  (state, props) =&gt; {
    return state.todoLists[props.listId].VisibilityFilter;
};
const getTodos = (state, props) =&gt; {
    return state.todoLists[props.listId].todos;
};
const makeGetVisibleTodos = () =&gt; {
    return createSelector(
        [ getVisibilityFilter, getTodos],
        (visibilityFilter, todos) =&gt; {
            switch (visibilityFilter) {
                case 'SHOW_COMPLETED':
                    return todos.filter(todo =&gt; todo.completed);
                case 'SHOW_ACTIVE':
                    return todos.filter(todo =&gt; !todo.completed);
                default:
                    return todos;
            }
        }
    );
};

export default makeGetVisibleTodos;
</code></pre>
<p>我们还需要一种方法，让容器的每个实例都可以访问它自己的私有选择器。<code>connect</code>方法的<code>mapStateToProps</code>参数可以起作用。</p>
<p><strong>如果传给<code>connect</code>的<code>mapStateToProps</code>参数返回一个函数而不是一个对象，它将用于给容器的每个实例创建一个单独的<code>mapStateToProps</code>函数。</strong></p>
<p>下面的例子中，<code>makeMapStateToProps</code>创建一个新的<code>getVisibleTodos</code>选择器，并且返回一个对新选择器具有独占访问权的<code>mapStateToProps</code>函数：</p>
<pre><code class="language-javascript">const makeMapStateToProps = () =&gt; {
    const getVisibleTodos = makeGetVisibleTodos();
    const mapStateToProps = (state, props) =&gt; ({ todos: getVisibleTodos(state, props) });
    // 这里返回mapStateToProps函数
    return mapStateToProps;
}
</code></pre>
<p>如果我们将<code>makeMapStateToProps</code>给<code>connect</code>方法，每一个<code>VisibleTodoList</code>容器实例都会得到一个包含私有的<code>getVisibleTodos</code>选择器的<code>mapStateToProps</code>方法。现在无论<code>VisibleTodosList</code>容器的渲染顺序如何，缓存机制都可以正确运作。</p>
<h4 id="containersvisibletodolistjs-4"><code>containers/VisibleTodoList.js</code></h4>
<pre><code class="language-javascript">import { connect } from 'react-redux';
import { toggleTodo } from '../actions';
import TodoList from '../components/TodoList';
import { makeGetVisibleTodos } from '../selectors';

const makeMapStateToProps = () =&gt; {
    const getVisibkeTodos = makeGetVisibleTodos();
    const mapStateToProps = (state, props) =&gt; ({ todos: getVisibleTodos(state, props) });
    return mapStateToProps;
};

const mapDispatchToProps = dispatch =&gt; ({ onTodoClick: id =&gt; dispatch(toggleTodo(id)) });

const VisibleTodoList = connect(makeMapStateToProps, mapDispatchToProps)(TodoList);

export default VisibleTodoList;
</code></pre>
<h2 id="api">API</h2>
<h3 id="createselectorinputselectors-inputselectors-resultfunc">createSelector(...inputSelectors | [inputSelectors], resultFunc)</h3>
<p>接收一个/多个选择器，或者一个选择器数组，计算它们的值并将其作为参数传递给<code>resultFunc</code>。</p>
<p><code>createSelector</code>采用引用相等<code>===</code>来确定输入选择器的值在多次调用之间是否发生了更改。</p>
<p>由<code>createSelector</code>创建的选择器缓存大小为1。这意味着当<code>输入选择器</code>的值发生更改的时候，他们总是重新计算，因为选择器只会存储每个<code>输入选择器</code>的前一个值。</p>
<pre><code class="language-javascript">const mySelector = creatSelector(
    state =&gt; state.values.value1,
    state =&gt; state.values.value2,
    (value1, value2) =&gt; value1 + value2
);

// 也可以传一个selector数组
const totalSelector = createSelector(
    [
        state =&gt; state.values.value1,
        state =&gt; state.values.value2
    ],
    (value1, value2) =&gt; value1 + value2
);
</code></pre>
<p>从选择器中访问组件的props可能很有用。当一个选择器通过<code>connect</code>连接到组件时，组件的props就会作为第二个参数传给selector：</p>
<pre><code class="language-javascript">const abSelector = (state, props) =&gt; state.a * props.b;

// 只有props(忽略state参数)
const cSelector = (_, props) =&gt; props.c;

// 只有state(props参数被省略，因为不需要)
const dSelector = state =&gt; satte.d;

const totalSelector = createSelector(
    abSelector,
    cSelector,
    dSelector,
    (ab, c, d) =&gt; ({ total: ab + c + d })
);
</code></pre>
<h3 id="defaultmemoizefunc-equalitycheck-defaultequalitycheck">defaultMemoize(func, equalityCheck = defaultEqualityCheck)</h3>
<p><code>defaultMemoize</code> 会记住传进来的<code>func</code>参数。它是<code>createSelector</code>使用的记忆函数。</p>
<p><code>defaultMemoize</code>的缓存大小为1。这意味着当参数值改变时它总是会重新计算。</p>
<p><code>defaultMemoize</code>通过调用<code>equalityCheck</code>函数来确定一个参数是否发生变化。由于<code>defaultMemoize</code>方法被设计成配合不可变数据使用，所以默认的<code>equalityCheck</code>函数通过引用相等来检查变更：</p>
<pre><code class="language-javascript">function defaultEqualityCheck(currentVal, previousVal) {
    return currentVal === previousVal;
}
</code></pre>
<p><code>defaultMemoize</code>可以配合<code>createSelectorCreator</code>使用来自定义<code>equalityCheck</code>函数。</p>
<h3 id="createselectorcreatormemoize-memoizeoptions">createSelectorCreator(memoize, ...memoizeOptions)</h3>
<p><code>createSelectorCreator</code>可以用来创建自定义的<code>createSelector</code>。</p>
<p>参数<code>memoize</code>是一个记忆函数，用来替代默认的<code>defaultMemoize</code>。</p>
<p>剩下的<code>...memoizeOptions</code>参数是一个或多个传给<code>memoizeFunc</code>函数的配置项。选择器的<code>resultFunc</code>作为第一个参数传给<code>memoize</code>，<code>memoizeOptions</code>作为第二个参数，第三个参数...依次传入：</p>
<pre><code class="language-javascript">const customSelectorCreator = createSelectorCreator(
    customMemoize, // 用来记忆'resultFunc'的函数
    option1, // option1作为customMemoize的第二个参数
    option2, // option2作为customMemoize的第三个参数
    option3, // option3作为customMemoize的第四个参数
);

const customSelector =customSelectorCreator(
    input1,
    input2,
    resultFunc // 'resultFunc'作为customMemoize第一个参数
):
</code></pre>
<p><code>customSelector</code>在内部像下面这样调用记忆函数：</p>
<pre><code class="language-javascript">customMemoize(resultFunc, option1, option2, option3);

</code></pre>
<p>下面是一些<code>createSelectorCreator</code>可能的使用场景示例：</p>
<h4 id="定制defaultmemoize的equalitycheck-方法">定制<code>defaultMemoize</code>的<code>equalityCheck</code> 方法</h4>
<pre><code class="language-javascript">import { createSelectorCreator, defaultMemoize } from 'reselect';
import isEqual from 'lodash.isEqual';

// 创建一个&quot;选择器创建器&quot;，用&quot;lodash.isEqual&quot;来代替&quot;===&quot;&quot;
const createDeepEqualSelector = createSelectorCreator(defaultMemoize, isEqual);

// 用新的&quot;选择器创建器&quot;来创建一个选择器
const mySelector = createDeepEqualSelector(
    state =&gt; state.values.filter(val =&gt; val &lt; 5 ),
    values =&gt; values.reduce((acc, val) =&gt; acc + val, 0)
);

</code></pre>
<h4 id="对无限缓存使用lodash的memoize函数">对无限缓存使用lodash的<code>memoize</code>函数</h4>
<pre><code class="language-javascript">import { createSelectorCreator } from 'reselect';
import memoize from 'lodash.meomize';

let called = 0;
const hashFn = (...arg) =&gt; args.reduce(
    (acc, val) =&gt; acc + '-' + JSON.stringify(val),
    ''
);

const customSelectorCreator = createSelectorCreator(memoize, hashFn);
const selector = customSelectorCreator(
    state =&gt; state.a,
    state =&gt; state.b,
    (a, b) =&gt; {
        called++;
        return a + b;
    }
);

</code></pre>
<h3 id="createstructuredselectorinputselectors-selectorcreator-createselector">createStructuredSelector({inputSelectors}, selectorCreator = createSelector)</h3>
<p><code>createStructuredSelector</code>是使用<code>reselect</code>库是出现的通用模式的方便函数。传递给<code>connect</code>装饰器的选择器通常只获取其输入选择器的值，并将其映射到对象中的键：</p>
<pre><code class="language-javascript">const mySelectorA = state =&gt; state.a;
const mySelectorB = state =&gt; state.b;

// 下方选择器中的结果函数只是简单地根据输入选择器构造一个对象
const structuredSelector = createSelector(
    mySelectorA,
    mySelectorB,
    (a, b) =&gt; ({a, b})
);

</code></pre>
<p><code>createStructuredSelector</code>接收一个对象，该对象的属性是输入选择器，返回一个结构化选择器。结构化选择器返回一个对象，该对象的key和<code>inputSelectors</code>参数的key相同，但是每个key对应的值都被替换为最终结果。</p>
<pre><code class="language-javascript">const mySelectorA = state =&gt; state.a;
const mySelectorB = state =&gt; state.b;

const structuredSelector = createStructuredSelector({
    x: mySelectorA,
    y: mySelectorB
});

const result = structuredSelector({ a: 1, b: 2 });// 输出{ x: 1, y: 2 }

</code></pre>
<p>结构化选择器可以嵌套：</p>
<pre><code>const nestedSelector = createStructuredSelector({
    subA: createStructuredSelector({ selectorA, selectorB }),
    subB: createStructuredSelector({ selectorC, selectorD })
});

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise简介]]></title>
        <id>https://xiewangmei.github.io/post/promise-introduce/</id>
        <link href="https://xiewangmei.github.io/post/promise-introduce/">
        </link>
        <updated>2020-10-15T02:05:15.000Z</updated>
        <content type="html"><![CDATA[<p>所谓Promise，简单来说就是一个容器，里面保存着未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息，例如请求成功后返回的数据，请求失败后的错误信息等。Promise提供统一的API，各种异步操作都可以用同样的方式进行处理。</p>
<h2 id="promise的特点">Promise的特点</h2>
<ul>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise（承诺）这个名字的由来，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：<code>pending → fulfilled</code>和<code>pending → rejected</code>。一旦状态发生改变，就会一直保持其终态不再改变。如果改变已经发生，再对Promise添加回调函数，也会立即得到这个结果。这与事件不同，事件一旦错过了，再去监听，是得不到结果的。</li>
</ul>
<p>下面是一个状态转变的例子：</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602727622438.png" alt="状态转变" loading="lazy"></figure>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>
Promise也有一些缺点。首先，无法取消Promise，<strong>一旦新建它就会立即执行</strong>，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h2 id="promise的基本用法">Promise的基本用法</h2>
<h3 id="语法">语法</h3>
<pre><code class="language-javascript">new Promise( function(resolve, reject) {...} /* executor */  );
</code></pre>
<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<pre><code class="language-jsx">promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
</code></pre>
<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
<p><strong>注意，下面两种方式是等价的：</strong></p>
<pre><code class="language-jsx">promise.then(null, function(error) {
  // failure
});
promise.catch(function(error) {
  // failure
});
</code></pre>
<h3 id="实例">实例</h3>
<h4 id="异步加载图片">异步加载图片</h4>
<pre><code class="language-jsx">const loadImageAsync = url =&gt; {
    return new Promise((resolve, reject) =&gt; {
        const image = new Image();
        // 加载成功, resolve
        image.onload = () =&gt; resolve(image);
        // 加载失败, reject
        image.onerror = () =&gt; reject(new Error(&quot;Image load failed at &quot; + url));
        image.src = url;
    });  
};
</code></pre>
<h4 id="实现一个简单ajax">实现一个简单Ajax</h4>
<pre><code class="language-jsx">const Ajax = function(url) {
  return new Promise(function(resolve, reject) {
    const onReadyStateChange = function() {
      if (this.readyState !== 4) return;
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = onReadyStateChange;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
  });
};
</code></pre>
<p>上述代码对原生<code>XMLHttpRequest</code>对象做了一次封装，用于发送一个Get请求，并且返回一个<code>Promise</code>对象。在<code>onReadyStateChange</code>函数体中，根据请求状态分别调用<code>resolve</code>和<code>reject</code>并传入对应的返回数据或错误信息，这时候如果通过<code>then</code>添加回调函数，那么<code>resolve</code>和<code>reject</code>的参数会被传递给各自对应的回调函数<code>onFulfilled</code>和<code>onRejected</code>。</p>
<p>使用：</p>
<pre><code class="language-jsx">// Node在8888端口起一个node服务
Ajax(&quot;http://localhost:8888/user/list&quot;).then(
    json =&gt; console.log(json),
    error =&gt; console.log(error)
);
</code></pre>
<p>效果：</p>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1602727648090.png" alt="Ajax" loading="lazy"></figure>
<h4 id="resolve参数是promise">Resolve参数是Promise</h4>
<p><code>resolve</code>函数的参数除了正常值外，还可能是另一个<code>Promise</code>对象：</p>
<pre><code class="language-jsx">const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
</code></pre>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。<strong>如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变</strong>；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<pre><code class="language-jsx">const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000);
});
const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 1000);
});
p2.then(console.log).catch(console.log);
</code></pre>
<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态本该在 1 秒时改变，但由于<code>resolve</code>方法接收的参数是<code>p1</code>，而在 1 秒这个时机，<code>p1</code>的状态还是<code>pending</code>，所以会等待<code>p1</code>的状态改变，此时<code>p2</code>自己的状态无效，由<code>p1</code>的状态决定，并且<code>p2</code>的<code>then</code>语句都变成针对<code>p1</code>。再经过 2 秒，<code>p1</code>变为<code>rejected</code>，触发<code>catch</code>方法指定的回调函数。</p>
<p>思考下面这三种情形，是什么结果？</p>
<pre><code class="language-jsx">// 情形一
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000);
});
const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 10000);// 时间改为10S
});
p2.then(console.log).catch(console.log);

// 情形二
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000);
}).catch(console.log);
const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 10000);// 时间改为10S
});
p2.then(console.log).catch(console.log);

// 情形三
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; reject(new Error('fail')), 3000);
});
p1.catch(console.log);
const p2 = new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(p1), 10000);// 时间改为10S
});
p2.then(console.log).catch(console.log);
</code></pre>
<h4 id="executor函数执行特点">Executor函数执行特点</h4>
<pre><code class="language-jsx">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
  console.log(2);
}).then(console.log);
console.log(3);
// 2
// 3
// 1
</code></pre>
<p><code>Promise</code>对象在创建时，<code>executor</code>函数会<strong>立即执行</strong>，又因为<code>resolve</code>或者<code>reject</code>并<strong>不会终止</strong><code>executor</code>函数的执行，所以2最先输出；<code>then</code>方法是异步的，所以不用等到<code>then</code>方法的输出，直接会执行同步代码<code>console.log(3)</code>，最后才会执行<code>then</code>中的回调，输出<code>resolve</code>的参数。</p>
<p>一般来讲，调用<code>resolve</code>或者<code>reject</code>后，<code>Promise</code>状态发生改变，使命就算完成，后续操作应该放到<code>then</code>方法中，而不应该在写在<code>executor</code>函数中的<code>resolve</code>和<code>reject</code>之后。</p>
<h4 id="promiseprototypethen">Promise.prototype.then()</h4>
<p><code>Promise</code>实例具有<code>then</code>方法，它的作用是给<code>Promise</code>实例添加状态改变时的回调函数。<code>then</code>方法参数是可选的，共有两个参数<code>onFulfilled</code>和<code>onRejected</code>，分别对应<code>pending → fulfilled</code>和<code>pending → rejected</code>两种状态变化的回调。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来的那个<code>Promise</code>实例），这也是<code>Promise</code>支持链式写法的原因。</p>
<pre><code class="language-jsx">const promise1 = new Promise((resolve, reject) =&gt; resolve([&quot;kzhang&quot;, &quot;xiaozhang&quot;]));
const promise2 = promise1.then(console.log);// [&quot;kzhang&quot;, &quot;xiaozhang&quot;]
console.log(promise1 === promise2);// false

// 链式调用
const promise3 = promise1.then(users =&gt; users[0]).then(console.log);// kzhang
</code></pre>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<pre><code class="language-jsx">const promiseA = Promise.resolve();
const promiseB = promiseA.then(() =&gt; Ajax(&quot;combo/options/list&quot;));
const promiseC = promiseB.then(comboList =&gt; Ajax(`config/${comboList[0]}`));
const promiseD = promiseC.then(console.log);
// 等价于:
Promise.resolve()
    .then(() =&gt; Ajax(&quot;combo/options/list&quot;))
    .then(comboList =&gt; Ajax(`config/${comboList[0]}`))
    .then(console.log);
</code></pre>
<p>上面代码中，第一个<code>then</code>指定的回调函数是发送一个<code>Ajax</code>请求，第二个<code>then</code>会等待该请求完成后，拿取第一条数据继续发送第二个请求，最后一个<code>then</code>则等待第二个请求完成后，直接打印结果。</p>
<h4 id="promiseprototypecatch">Promise.prototype.catch()</h4>
<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<pre><code class="language-jsx">Ajax(&quot;user/list&quot;).then(users =&gt; loadUserTable(users)).catch(err =&gt; {
  console.log(&quot;醒醒, 你的代码报错了&quot;, err);
});
</code></pre>
<p>上面代码中，发送一个请求获取用户列表，如果请求正常返回，执行<code>then</code>方法指定的回调来加载表格数据，否则执行<code>catch</code>方法指定的回调来打印错误信息。另外，如果<code>then</code>方法指定的回调在运行中抛出错误，也会被<code>catch</code>方法捕获。</p>
<pre><code class="language-jsx">const promise = new Promise((resolve, reject) =&gt; {throw new Error(&quot;报错啦&quot;);});
promise.catch(console.log);// Error: 报错啦
</code></pre>
<p>上面代码中，<code>Promise</code>内部抛出一个错误，就被<code>catch</code>方法指定的回调函数捕获，这种写法和下面两种写法等价：</p>
<pre><code class="language-jsx">// 写法一
const promise = new Promise((resolve, reject) =&gt; {
  try {
    throw new Error(&quot;报错啦&quot;);
  } catch(e) {
    reject(e);
  }
});
promise.catch(console.log);

// 写法二
const promise = new Promise((resolve, reject) =&gt; {
  reject(new Error(&quot;报错啦&quot;));
});
promise.catch(console.log);
</code></pre>
<p>如果<code>Promise</code>的状态已经变成<code>fulfilled</code>，再抛出错误则是无效的，这是因为<code>Promise</code>状态一旦发生改变后，就会一直保持该终态，例如：</p>
<pre><code class="language-jsx">const promise = new Promise((resolve, reject) =&gt; { 
  resolve(&quot;fulfilled&quot;);
  throw new Error(&quot;报错啦&quot;);
});
promise.then(console.log).catch(console.log);
// fulfilled
</code></pre>
<p><code>Promise</code>的错误具有“冒泡”性质，会一直向后传递，知道被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。例如，<code>promise.then(...).then(...).catch(...)</code>，两个<code>then</code>中任意一个发生错误，都会被最后的<code>catch</code>捕获。</p>
<p>一般来说，用<code>catch</code>来指定<code>rejected</code>状态的回调要优于用<code>then(null, onRejected)</code>的方式，因为<code>catch</code>方式能捕获前面的<code>then</code>方法执行中的错误，也更接近于同步的写法（<code>try/catch</code>）。</p>
<p><code>catch</code>方法返回的还是一个<code>Promise</code>对象，因此后面还是可以接着调用<code>then</code>方法：</p>
<pre><code class="language-jsx">const promise1 = new Promise((resolve, reject) =&gt; reject(new Error(&quot;报错啦&quot;)));
const promise2 = promise1.catch(err =&gt; {
  console.log(err);
  return &quot;错误catch住, 并处理完成&quot;
});
promise2.then(console.log);
</code></pre>
<p>上面代码中，<code>promise1</code>变为<code>rejected</code>态，调用<code>catch</code>回调，并返回一段文本，供<code>promise2</code>的<code>then</code>回调打印。若<code>promise1</code>没有报错，则会跳过<code>catch</code>。</p>
<pre><code class="language-jsx">Promise.resolve().catch(console.log).then(() =&gt; console.log('carry on'));
</code></pre>
<p>上面这段代码，由于没有报错，所以会跳过<code>catch</code>直接执行<code>then</code>。</p>
<h4 id="promiseprototypefinally">Promise.prototype.finally()</h4>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>
<pre><code class="language-jsx">Ajax(&quot;http://localhost:8888/user/list&quot;)
  .then(users =&gt; {
    loadUserTable(users);
    setMask(false);
   })
  .catch(err =&gt; {
    console.log(err);
    setMask(false);  
  });
</code></pre>
<p>上面这段代码，不管请求是否成功，在结束后都会调用<code>setMask(false)</code>操作来去除遮罩。显然，<code>setMask(false)</code>是一个必然执行的操作，可以放到<code>finally</code>中：</p>
<pre><code class="language-jsx">Ajax(&quot;http://localhost:8888/user/list&quot;)
  .then(loadUserTable)
  .catch(console.log)
  .finally(() =&gt; setMask(false));
</code></pre>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的<code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果。</p>
<h4 id="promiseall">Promise.all()</h4>
<p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="language-jsx">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是<code>Promise</code>实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为<code>Promise</code>实例，再进一步处理。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li>
</ul>
<pre><code class="language-jsx">// 连接数据库
const databasePromise = connectDatabase();
// 查询所有书籍
const booksPromise = databasePromise.then(findAllBooks);
// 查询当前登录用户
const userPromise = databasePromise.then(getCurrentUser);
// 返回针对该用户的推荐书籍
Promise.all([booksPromise, userPromise]).then(
    ([books, user]) =&gt; pickTopRecommentations(books, user)
);
</code></pre>
<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p>
<pre><code class="language-jsx">const p1 = new Promise((resolve, reject) =&gt; resolve('hello'))
             .then(result =&gt; result)
             .catch(e =&gt; e);
const p2 = new Promise((resolve, reject) =&gt; { throw new Error('报错了'); })
             .then(result =&gt; result)
             .catch(e =&gt; e);
Promise.all([p1, p2])
    .then(result =&gt; console.log(result))// [&quot;hello&quot;, Error: 报错了]
    .catch(e =&gt; console.log(e));
</code></pre>
<p>上面这段代码，并没有在最后一行的<code>catch</code>中打印结果，这是因为<code>p2</code>对象指定了<code>catch</code>回调，而<code>catch</code>返回的又是一个正常的<code>Promise</code>对象，所以<code>Promise.all</code>接收了两个<code>fulfilled</code>状态的<code>Promise</code>，自然就触发<code>Promise.all</code>的<code>then</code>方法。</p>
<p>改写一下，去掉<code>p2</code>的<code>catch</code>回调，则可以触发<code>Promise.all</code>的<code>catch</code>回调：</p>
<pre><code class="language-jsx">const p1 = new Promise((resolve, reject) =&gt; resolve('hello')).then(result =&gt; result);
const p2 = new Promise((resolve, reject) =&gt; { throw new Error('报错了');})
             .then(result =&gt; result);
Promise.all([p1, p2])
    .then(result =&gt; console.log(result))
    .catch(e =&gt; console.log(e));// Error: 报错了
</code></pre>
<h4 id="promiserace">Promise.race()</h4>
<p><code>Promise.race</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code class="language-jsx">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<pre><code class="language-jsx">const p = Promise.race([
  Ajax(&quot;/long-time-request&quot;),// 耗时请求
  new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000);
  })
]);
p.then(console.log).catch(console.error);
</code></pre>
<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h4 id="promiseresolve">Promise.resolve()</h4>
<p><code>Promise.resolve(value)</code>方法返回一个根据<code>value</code>解析后的<code>Promise</code>对象。</p>
<p>有以下几种情况：</p>
<ul>
<li>
<p>如果<code>value</code>为<code>promise</code>，返回这个<code>promise</code></p>
<pre><code class="language-jsx">const p1 = Promise.resolve(&quot;xyqiu&quot;);
const p2 = Promise.resolve(p1);
console.log(p1 === p2);// true
p2.then(value =&gt; console.log(value));// 'xyqiu'
</code></pre>
</li>
<li>
<p>如果<code>value</code>是<code>thenable</code>对象（即带有<code>then</code>方法），返回的<code>promise</code>会“跟随”这个<code>thenable</code>对象，采用它的最终状态</p>
<pre><code class="language-jsx">const p1 = Promise.resolve({ then: (resolve, reject) =&gt; resolve(&quot;xyqiu&quot;) });
const p2 = Promise.resolve({ then: (resolve, reject) =&gt; reject(&quot;Error&quot;) });
p1.then(console.log);// 'xyqiu'
p2.catch(console.log);// 'Error'
</code></pre>
</li>
<li>
<p>如果<code>value</code>不是<code>thenable</code>对象，返回的<code>promise</code>将以此值完成</p>
<pre><code class="language-jsx">const p1 = Promise.resolve(&quot;xyqiu1&quot;);
const p2 = Promise.resolve({ name: &quot;xyqiu2&quot; });
p1.then(console.log);// 'xyqiu1'
p2.then(console.log);// { name: &quot;xyqiu2&quot; }
</code></pre>
</li>
</ul>
<h4 id="promisereject">Promise.reject()</h4>
<p><code>Promise.reject(reason)</code>方法也会返回一个新的<code>Promise</code>实例，该实例的状态为<code>rejected</code>。</p>
<pre><code class="language-jsx">// 下面两种方式等价
const p1 = Promise.reject(&quot;报错了&quot;);
const p2 = new Promise((resolve, reject) =&gt; reject(&quot;报错了&quot;));
</code></pre>
<p><code>Promise.reject()</code>方法的参数，会<strong>原封不动</strong>地作为<code>reject</code>的理由，变为后续方法的参数。这一点与<code>Promise.resolve()</code>方法不一致。</p>
<pre><code class="language-jsx">const thenable = { then: (resolve, reject) =&gt; reject('报错了') };
Promise.reject(thenable).catch(e =&gt; console.log(e === thenable));// true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学会写正则]]></title>
        <id>https://xiewangmei.github.io/post/learn-regexp/</id>
        <link href="https://xiewangmei.github.io/post/learn-regexp/">
        </link>
        <updated>2020-10-15T02:01:44.000Z</updated>
        <content type="html"><![CDATA[<p>1.正则表达式<code>/\d{3}-\d{8}|\d{4}-\d{7,8}/</code>代表什么含义：</p>
<p>首先观察到表达式中有一个选择符<code>|</code>，而选择符的两边没有圆括号成对出现，那么可以推断出该表达式是匹配<code>\d{3}-\d{8}</code>或<code>\d{4}-\{7,8}</code>两种模式。</p>
<p>模式<code>\d{3}-\d{8}</code>：三位数字和八位数字，中间以<code>-</code>连接，例：010-88888888</p>
<p>模式<code>\d{4}-\d{7,8}</code>：四位数字和七(八)位数字，中间以<code>-</code>连接，例：0512-88888888</p>
<p>到现在应该可以看出，这个正则是匹配座机号码。</p>
<p>但是，中国的座机号是按一定的规律组成，上面的表达式不完全正确。例如：000-00000000 明显不是一个合法的座机号。<strong>思考如何改进</strong>？</p>
<p>2.正则表达式<code>/(?=.{8,31})(?=.*\d.*\d.*)(?=.*[a-z].*[a-z].*)(?=.*[A-Z].*[A-Z].*)(?=.*[^a-zA-Z0-9].*[^a-zA-Z0-9].*)/</code>代表什么含义（拷贝自智源项目）：</p>
<p>观察正则表达式的结构，发现其是由五个<code>先行断言</code>组成。<code>(?=正则)</code>表示在这个位置之后的字符串必须符合<code>?=</code>之后的正则。而我们知道先行断言有一个特点：不消耗字符串。那么也就是说在这之后的正则还是从同一位置开始匹配。</p>
<p><code>(?=.{8,31})</code>：字符串长度为 8-31</p>
<p><code>(?=.*\d.*\d.*)</code>：必须包含两个数字</p>
<p><code>(?=.*[a-z].*[a-z].*)</code>：必须包含两个小写字母</p>
<p><code>(?=.*[A-Z].*[A-Z].*)</code>：必须包含两个大写字母</p>
<p><code>(?=.*[^a-zA-Z0-9].*[^a-zA-Z0-9].*)</code>必须包含两个特殊字符</p>
<p>显而易见，这是用来校验密码强度的正则。</p>
<p><strong>小结：</strong></p>
<p>我们拿到一个正则表达式，不管它有多复杂，千万不要被吓到，需要一步步地将其分解为多个子表达式，然后分析每个子表达式匹配的是何种模式，必要时尝试着举几个例子来验证自己的想法是否正确，最终纵观整体一般都能理解正则表达式的含义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RegExp 对象]]></title>
        <id>https://xiewangmei.github.io/post/regexp/</id>
        <link href="https://xiewangmei.github.io/post/regexp/">
        </link>
        <updated>2020-10-15T01:58:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>RegExp</code>对象提供正则表示式的功能。</p>
<h2 id="概述">概述</h2>
<p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<pre><code class="language-javascript">var regex = /xyz/;
</code></pre>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<pre><code class="language-javascript">var regex = new RegExp('xyz');
</code></pre>
<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<pre><code class="language-javascript">var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
</code></pre>
<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h2 id="实例属性">实例属性</h2>
<p>正则对象的实例属性分成两类。</p>
<p>一类是修饰符相关，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>上面四个属性都是只读的。</p>
<pre><code class="language-javascript">var r = /abc/igm;

r.ignoreCase // true
r.global // true
r.multiline // true
r.flags // 'gim'
</code></pre>
<p>另一类是与修饰符无关的属性，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<pre><code class="language-javascript">var r = /abc/igm;

r.lastIndex // 0
r.source // &quot;abc&quot;
</code></pre>
<h2 id="实例方法">实例方法</h2>
<h3 id="regexpprototypetest">RegExp.prototype.test()</h3>
<p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<pre><code class="language-javascript">/cat/.test('cats and dogs') // true
</code></pre>
<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
<pre><code class="language-javascript">var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
</code></pre>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<pre><code class="language-javascript">var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false

r.lastIndex // 0
r.test(s)
</code></pre>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>。</p>
<p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
<pre><code class="language-javascript">var r = /bb/g;
r.test('bb') // true
r.test('-bb-') // false
</code></pre>
<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。</p>
<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>
<pre><code class="language-javascript">var count = 0;
while (/a/g.test('babaa')) count++;
</code></pre>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<pre><code class="language-javascript">new RegExp('').test('abc')
// true
</code></pre>
<h3 id="regexpprototypeexec">RegExp.prototype.exec()</h3>
<p>正则实例对象的<code>exec</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // [&quot;x&quot;]
r2.exec(s) // null
</code></pre>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r = /_(x)/;

r.exec(s) // [&quot;_x&quot;, &quot;x&quot;]
</code></pre>
<p>上面代码的<code>exec</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</p>
<p><code>exec</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：整个模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<pre><code class="language-javascript">var r = /a(b+)a/;
var arr = r.exec('_abbba_aba_');

arr // [&quot;abbba&quot;, &quot;bbb&quot;]

arr.index // 1
arr.input // &quot;_abbba_aba_&quot;
</code></pre>
<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<pre><code class="language-javascript">var reg = /a/g;
var str = 'abc_abc_abc'

var r1 = reg.exec(str);
r1 // [&quot;a&quot;]
r1.index // 0
reg.lastIndex // 1

var r2 = reg.exec(str);
r2 // [&quot;a&quot;]
r2.index // 4
reg.lastIndex // 5

var r3 = reg.exec(str);
r3 // [&quot;a&quot;]
r3.index // 8
reg.lastIndex // 9

var r4 = reg.exec(str);
r4 // null
reg.lastIndex // 0
</code></pre>
<p>上面代码连续用了四次<code>exec</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<pre><code class="language-javascript">var reg = /a/g;
var str = 'abc_abc_abc'

while(true) {
  var match = reg.exec(str);
  if (!match) break;
  console.log('#' + match.index + ':' + match[0]);
}
// #0:a
// #4:a
// #8:a
</code></pre>
<p>上面代码中，只要<code>exec</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>
<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>
<h2 id="字符串的实例方法">字符串的实例方法</h2>
<p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="stringprototypematch">String.prototype.match()</h3>
<p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

s.match(r1) // [&quot;x&quot;]
s.match(r2) // null

</code></pre>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<pre><code class="language-javascript">var s = 'abba';
var r = /a/g;

s.match(r) // [&quot;a&quot;, &quot;a&quot;]
r.exec(s) // [&quot;a&quot;]

</code></pre>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>
<pre><code class="language-javascript">var r = /a|b/g;
r.lastIndex = 7;
'xaxb'.match(r) // ['a', 'b']
r.lastIndex // 0

</code></pre>
<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h3 id="stringprototypesearch">String.prototype.search()</h3>
<p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>
<pre><code class="language-javascript">'_x_x'.search(/x/)
// 1

</code></pre>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h3 id="stringprototypereplace">String.prototype.replace()</h3>
<p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<pre><code class="language-javascript">str.replace(search, replacement)

</code></pre>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<pre><code class="language-javascript">'aaa'.replace('a', 'b') // &quot;baa&quot;
'aaa'.replace(/a/, 'b') // &quot;baa&quot;
'aaa'.replace(/a/g, 'b') // &quot;bbb&quot;

</code></pre>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>b</code>都被替换掉了。</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<pre><code class="language-javascript">var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')
// &quot;#id div.class&quot;

</code></pre>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$`</code>：匹配结果前面的文本。</li>
<li><code>$'</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<pre><code class="language-javascript">'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// &quot;world hello&quot;

'abc'.replace('b', '[$`-$&amp;-$\']')
// &quot;a[a-b-c]c&quot;

</code></pre>
<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<pre><code class="language-javascript">'3 and 5'.replace(/[0-9]+/g, function (match) {
  return 2 * match;
})
// &quot;6 and 10&quot;

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.

</code></pre>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<pre><code class="language-javascript">var prices = {
  'p1': '$1.99',
  'p2': '$9.99',
  'p3': '$5.00'
};

var template = '&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;';

template.replace(
  /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);
// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot;

</code></pre>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h3 id="stringprototypesplit">String.prototype.split()</h3>
<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<pre><code class="language-javascript">str.split(separator, [limit])

</code></pre>
<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<pre><code class="language-javascript">// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]

</code></pre>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<pre><code class="language-javascript">// 例一
'aaa*a*'.split(/a*/)
// [ '', '*', '*' ]

// 例二
'aaa**a*'.split(/a*/)
// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]

</code></pre>
<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<pre><code class="language-javascript">'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]

</code></pre>
<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>
<h2 id="匹配规则">匹配规则</h2>
<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符">字面量字符和元字符</h3>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<pre><code class="language-javascript">/dog/.test('old dog') // true

</code></pre>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<p><strong>（1）点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code class="language-javascript">/c.t/

</code></pre>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<p><strong>（2）位置字符</strong></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<pre><code class="language-javascript">// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false

</code></pre>
<p><strong>（3）选择符（<code>|</code>）</strong></p>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<pre><code class="language-javascript">/11|22/.test('911') // true

</code></pre>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<pre><code class="language-javascript">// 匹配fred、barney、betty之中的一个
/fred|barney|betty/

</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<pre><code class="language-javascript">/a( |\t)b/.test('a\tb') // true

</code></pre>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<h3 id="转义符">转义符</h3>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="language-javascript">/1+1/.test('1+1')
// false

/1\+1/.test('1+1')
// true

</code></pre>
<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<pre><code class="language-javascript">(new RegExp('1\+1')).test('1+1')
// false

(new RegExp('1\\+1')).test('1+1')
// true

</code></pre>
<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h3 id="特殊字符">特殊字符</h3>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h3 id="字符类">字符类</h3>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<pre><code class="language-javascript">/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true

</code></pre>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<p><strong>（1）脱字符（^）</strong></p>
<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<pre><code class="language-javascript">/[^abc]/.test('hello world') // true
/[^abc]/.test('bbc') // false

</code></pre>
<p>上面代码中，字符串<code>hello world</code>不包含字母<code>a</code>、<code>b</code>、<code>c</code>中的任一个，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的字母，所以返回<code>false</code>。</p>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<pre><code class="language-javascript">var s = 'Please yes\nmake my day!';

s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']

</code></pre>
<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<p><strong>（2）连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<pre><code class="language-javascript">/a-z/.test('b') // false
/[a-z]/.test('b') // true

</code></pre>
<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<pre><code class="language-javascript">[0-9.,]
[0-9a-fA-F]
[a-zA-Z0-9-]
[1-31]

</code></pre>
<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<pre><code class="language-javascript">var str = &quot;\u0130\u0131\u0132&quot;;
/[\u0128-\uFFFF]/.test(str)
// true

</code></pre>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<pre><code class="language-javascript">/[A-z]/.test('\\') // true

</code></pre>
<p>上面代码中，由于反斜杠（'\'）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h3 id="预定义模式">预定义模式</h3>
<p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<p>下面是一些例子。</p>
<pre><code class="language-javascript">// \s 的例子
/\s\w*/.exec('hello world') // [&quot; world&quot;]

// \b 的例子
/\bworld/.test('hello world') // true
/\bworld/.test('hello-world') // true
/\bworld/.test('helloworld') // false

// \B 的例子
/\Bworld/.test('hello-world') // false
/\Bworld/.test('helloworld') // true

</code></pre>
<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<pre><code class="language-javascript">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;

/.*/.exec(html)[0]
// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;

</code></pre>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<pre><code class="language-javascript">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;

/[\S\s]*/.exec(html)[0]
// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;

</code></pre>
<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h3 id="重复类">重复类</h3>
<p>模式的精确匹配次数，使用大括号（<code>{}</code>）表示。<code>{n}</code>表示恰好重复<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<pre><code class="language-javascript">/lo{2}k/.test('look') // true
/lo{2,5}k/.test('looook') // true

</code></pre>
<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h3 id="量词符">量词符</h3>
<p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</li>
</ul>
<pre><code class="language-javascript">// t 出现0次或1次
/t?est/.test('test') // true
/t?est/.test('est') // true

// t 出现1次或多次
/t+est/.test('test') // true
/t+est/.test('ttest') // true
/t+est/.test('est') // false

// t 出现0次或多次
/t*est/.test('test') // true
/t*est/.test('ttest') // true
/t*est/.test('tttest') // true
/t*est/.test('est') // true

</code></pre>
<h3 id="贪婪模式">贪婪模式</h3>
<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<pre><code class="language-javascript">var s = 'aaa';
s.match(/a+/) // [&quot;aaa&quot;]

</code></pre>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<pre><code class="language-javascript">var s = 'aaa';
s.match(/a+?/) // [&quot;a&quot;]

</code></pre>
<p>上面代码中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。</p>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）和非贪婪模式的问号（<code>?</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<pre><code class="language-javascript">'abb'.match(/ab*b/) // [&quot;abb&quot;]
'abb'.match(/ab*?b/) // [&quot;ab&quot;]

'abb'.match(/ab?b/) // [&quot;abb&quot;]
'abb'.match(/ab??b/) // [&quot;ab&quot;]

</code></pre>
<h3 id="修饰符">修饰符</h3>
<p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<pre><code class="language-javascript">// 单个修饰符
var regex = /test/i;

// 多个修饰符
var regex = /test/ig;

</code></pre>
<p><strong>（1）g 修饰符</strong></p>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<pre><code class="language-javascript">var regex = /b/;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // true

</code></pre>
<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<pre><code class="language-javascript">var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false

</code></pre>
<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<p><strong>（2）i 修饰符</strong></p>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<pre><code class="language-javascript">/abc/.test('ABC') // false
/abc/i.test('ABC') // true

</code></pre>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<p><strong>（3）m 修饰符</strong></p>
<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<pre><code class="language-javascript">/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true

</code></pre>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<pre><code class="language-javascript">/^b/m.test('a\nb') // true

</code></pre>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>b</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h3 id="组匹配">组匹配</h3>
<p><strong>（1）概述</strong></p>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<pre><code class="language-javascript">/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true

</code></pre>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<pre><code class="language-javascript">var m = 'abcabc'.match(/(.)b(.)/);
m
// ['abc', 'a', 'c']

</code></pre>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<pre><code class="language-javascript">var m = 'abcabc'.match(/(.)b(.)/g);
m // ['abc', 'abc']

</code></pre>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<pre><code class="language-javascript">var str = 'abcabc';
var reg = /(.)b(.)/g;
while (true) {
  var result = reg.exec(str);
  if (!result) break;
  console.log(result);
}
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]

</code></pre>
<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<pre><code class="language-javascript">/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)
// true

</code></pre>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<pre><code class="language-javascript">/y(..)(.)\2\1/.test('yabccab') // true

</code></pre>
<p>括号还可以嵌套。</p>
<pre><code class="language-javascript">/y((..)\2)\1/.test('yabababab') // true

</code></pre>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<pre><code class="language-javascript">var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;

tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]
// 'b'

</code></pre>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<pre><code class="language-javascript">var html = '&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;';
var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;

var match = tag.exec(html);

match[1] // &quot;b&quot;
match[2] // &quot; class=&quot;hello&quot;&quot;
match[3] // &quot;Hello&quot;

match = tag.exec(html);

match[1] // &quot;i&quot;
match[2] // &quot;&quot;
match[3] // &quot;world&quot;

</code></pre>
<p><strong>（2）非捕获组</strong></p>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo){1, 2}/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo){1, 2}/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<pre><code class="language-javascript">var m = 'abc'.match(/(?:.)b(.)/);
m // [&quot;abc&quot;, &quot;c&quot;]

</code></pre>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<pre><code class="language-javascript">// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]

</code></pre>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>（3）先行断言</strong></p>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-javascript">var m = 'abc'.match(/b(?=c)/);
m // [&quot;b&quot;]

</code></pre>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<p><strong>（4）先行否定断言</strong></p>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<pre><code class="language-javascript">/\d+(?!\.)/.exec('3.14')
// [&quot;14&quot;]

</code></pre>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-javascript">var m = 'abd'.match(/b(?!c)/);
m // ['b']

</code></pre>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式基础]]></title>
        <id>https://xiewangmei.github.io/post/regular-expression-base/</id>
        <link href="https://xiewangmei.github.io/post/regular-expression-base/">
        </link>
        <updated>2020-10-15T01:56:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="正则表达式真香">正则表达式“真香”</h2>
<p>开始学习正则表达式之前，我们先看一个简单的编程题：</p>
<p>已知一个字符串'bfb2134rqf5676gur35bgbqd544oihf'，要求提取出字符串中的所有连续数字段，即输出[2134, 5676, 35, 544]。</p>
<p>传统思路：</p>
<pre><code class="language-javascript">function findNumBlock(str) {
    var temp = '';
    var result = [];
    for (var i = 0; i &lt; str.length; i++) {
        var currentChar = str.charAt(i);
        if (str.charAt(i) &lt;= '9' &amp;&amp; str.charAt(i) &gt;= '0') {
            temp += currentChar;
        } else {
            if (temp) {
                result.push(temp);
                temp = '';
            }
        }
    }
    return result;
}
var str = 'bfb2134rqf5676gur35bgbqd544oihf';
findNumBlock(str);
</code></pre>
<p><strong>思考：这段代码有没有什么问题？</strong></p>
<p>正则思路：</p>
<pre><code class="language-javascript">var reg = /\d+/g;
var str = 'bfb2134rqf5676gur35bgbqd544oihf';
str.match(reg)
</code></pre>
<p>显而易见，有时候在处理字符串的问题上，利用好正则会方便很多。</p>
<h2 id="正则表达式的基本概念">正则表达式的基本概念</h2>
<h3 id="定义">定义</h3>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<h3 id="作用">作用</h3>
<p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p>
<ul>
<li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）</li>
<li>可以通过正则表达式，从字符串中获取我们想要的特定部分</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>灵活性、逻辑性和功能性非常的强；</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>
<li>对于刚接触的人来说，比较晦涩难懂。</li>
</ul>
<p><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark>分割线</mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></p>
<h2 id="正则表达式的创建">正则表达式的创建</h2>
<p>新建正则表达式有两种方式：</p>
<ul>
<li>使用<code>字面量</code>，以斜杠表示开始和结束</li>
</ul>
<pre><code class="language-javascript">var regex = /abc/;
</code></pre>
<ul>
<li>使用<code>RegExp</code>构造函数</li>
</ul>
<pre><code class="language-javascript">var regex = new RegExp('abc');
</code></pre>
<p>这两种方式是等价的，都新建了一个内容为<code>\d+</code>的正则表达式对象。<br>
**主要区别：**第一种方法在引擎编译代码时就会新建正则表达式，第二种则在运行时才去新建，所以比较下来前者的效率比较高。此外，第一种方法也比较便利和直观，实际使用中，基本上都是采用第一种方式。</p>
<p><code>RegExp</code>构造函数还可以接收第二个参数，用于表示<code>修饰符</code>：</p>
<pre><code class="language-javascript">var regex = /abc/i;
// 等价于
var regex = new RegExp('abc', 'i');
</code></pre>
<p>有些正则表达式用构造函数形式需要<code>转义</code>，例如文首的程序题中的正则表达式替换后：</p>
<pre><code class="language-javascript">var regex = new RegExp('\\d+', 'g');
</code></pre>
<p>这里再次验证了通过字面量创建正则表达式的便利性。</p>
<h2 id="正则对象的实例属性">正则对象的实例属性</h2>
<p>正则对象的实例属性分为两类。</p>
<p>一类是<code>修饰符</code>相关，用于了解设置了什么<code>修饰符</code>：</p>
<ul>
<li><code>RegExp.prototype.global</code>： 返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.protptype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>以上四个属性都是只读的</p>
<pre><code class="language-javascript">var regex = /abc/gim;
console.log(regex.global);//true
console.log(regex.ignoreCase);//true
console.log(regex.multiline);//true
console.log(regex.flags);//&quot;gim&quot;
</code></pre>
<p>另一类是与<code>修饰符无关</code>的属性，主要是下面两种：</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示<strong>下一次开始搜索的位置</strong>。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<pre><code class="language-javascript">var regex = /abc/gim;
console.log(regex.lastIndex);//0
console.log(regex.source);//abc
</code></pre>
<h2 id="正则对象的实例方法">正则对象的实例方法</h2>
<h3 id="regexpprototypetest">RegExp.prototype.test()</h3>
<p>正则对象的<code>test</code>方法返回一个布尔值，表示当前字符串能否匹配参数字符串。</p>
<pre><code class="language-javascript">// 验证参数字符串中是否包含&quot;hillstone&quot;，结果为true
/hillstone/.test('hillstone network');
</code></pre>
<p>如果正则表达式带有<code>g</code>修饰符，那么每一次<code>test</code>方法都从上次结束的位置开始向后匹配。</p>
<pre><code class="language-javascript">// 匹配字符串中是否包含字母'n'
var regex = /n/g;
var str = 'hillstone network';

console.log(regex.lastIndex);//0
console.log(regex.test(str));//第一次test结果：true

console.log(regex.lastIndex);//8
console.log(regex.test(str));//第二次test结果：true

console.log(regex.lastIndex);//11
console.log(regex.test(str));//第三次test结果：false
</code></pre>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是<code>全局搜索</code>，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是<code>上一次匹配的后一个位置</code>。</p>
<p>前面在介绍<code>lastIndex</code>属性时有提到过，该属性是可读写的，因此带有<code>g</code>修饰符的正则对象，可以通过<code>lastIndex</code>属性指定开始搜索的位置。</p>
<pre><code class="language-javascript">// 匹配字符串中是否包含字母'i'
var regex = /i/g;
var str = 'hillstone network';
regex.lastIndex = 2;//从index:2的位置开始匹配
console.log(regex.test(str));//第一次test结果：false
console.log(regex.test(str));//第二次test结果：true
</code></pre>
<p>观察上面连续两次的匹配结果发现：第一次匹配失败，第二次却成功了？</p>
<p>这是因为正则表达式在匹配失败后，会将<code>lastIndex</code>重置为0，这样第二次匹配时从0开始就可以匹配到字母'i'了。</p>
<p><strong>注意</strong>：带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性值，这时<strong>不应该替换带匹配的字符串</strong>，否则会出现一些难以察觉的错误。</p>
<pre><code class="language-javascript">var regex = /aa/g;
console.log(regex.test('aa'));//第一次test结果：true
console.log(regex.lastIndex);//lastIndex置为2
console.log(regex.test('-aa-'));//第二次test结果：false
</code></pre>
<p><code>lastIndex</code>只对同一个正则表达式有效：</p>
<pre><code class="language-javascript">var count = 0 ;
while(/a/g.test('bab')) {
    count++;
}
console.log(count);
</code></pre>
<p>这段代码看起来意图&quot;很明显&quot;：循环调用正则表达式<code>/a/g</code>的<code>test</code>方法来匹配一个字符串，直到匹配结果为false，退出循环，输出匹配到的个数。但是实际情况是，这里形成了一个<strong>死循环</strong>。原因是<code>while</code>循环的每次匹配条件都是一个<strong>新的正则对象实例</strong>，导致<code>lastIndex</code>属性始终为0。</p>
<p>用<code>构造函数</code>改写一下就能很容易看出问题所在：</p>
<pre><code class="language-javascript">var count = 0 ;
while(new RegExp('a', 'g').test('bab')) {//每次都是一个新的正则对象
    count++;
}
console.log(count);
</code></pre>
<p>如果正则模式是一个空字符串，则匹配所有的字符串：</p>
<pre><code class="language-javascript">var regex = new RegExp('');
console.log(regex.test('a'));//true
console.log(regex.test('b'));//true
</code></pre>
<h3 id="regexpprototypeexec">RegExp.prototype.exec()</h3>
<p>正则对象的<code>exec</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则，返回<code>null</code>。</p>
<pre><code class="language-javascript">var str = 'hillstone';
var regex1 = /hillstone/;
var regex2 = /network/;
console.log(regex1.exec(str));//['hillstone']
console.log(regex2.exec(str));//null
</code></pre>
<p>上述代码中，<code>regex1</code>匹配成功，返回一个数组，成员是匹配结果；<code>regex2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表达式包含圆括号（包含“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<pre><code class="language-javascript">var str = '_x_x';
var regex = /_(x)_/;
console.log(regex.exec(s));//匹配结果：['_x_', 'x']
</code></pre>
<p>结果数组的第一个成员为整个匹配的结果，第二个成员为组匹配的结果。</p>
<p><code>exec</code>方法的返回数组中还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个待匹配字符串。</li>
<li><code>index</code>：整个正则匹配成功的开始位置（从0开始计数）。</li>
</ul>
<pre><code class="language-javascript">var regex = /a(b+)a/;
var arr = r.exec('_abbba_aba_');
console.log(arr);//['abbbx', 'bbb']
console.log(arr.index);//1
console.log(arr.input);//'_abbba_aba_'
</code></pre>
<p>上述代码中<code>index</code>值为1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置<strong>从上一次匹配成功结束的位置开始</strong>：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abc_abc_abc';

var firstMatch = regex.exec(str);
console.log(firstMatch);//['a']
console.log(firstMatch.index);//0
console.log(regex.lastIndex);//1

var secondMatch = regex.exec(str);
console.log(secondMatch);//['a']
console.log(secondMatch.index);//4
console.log(regex.lastIndex);//5

var thirdMatch = regex.exec(str);
console.log(thirdMatch);//['a']
console.log(thirdMatch.index);//8
console.log(regex.lastIndex);//9

var forthMatch = regex.exec(str);
console.log(forthMatch);//null
console.log(regex.lastIndex);//0
</code></pre>
<p>上述代码连续调用四次<code>exec</code>方法，前三次匹配成功，找出了字符串中所有字母'a'，第四次匹配失败，正则表达式的<code>lastIndex</code>重置为0，这时候我们调用<code>exec</code>则再次匹配成功。</p>
<p>考虑到<code>g</code>修饰符允许多次匹配的特点，我们对上述代码进行改造，即可实现循环找出所有匹配项：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abc_abc_abc';
while(true) {
    var result = regex.exec(str);
    if(!result) break;
    console.log('Current matched index is: ' + result.index);
}
</code></pre>
<p>此外，指定正则对象的<code>lastIndex</code>属性在这里同样适用，<code>exec</code>方法会从指定的<code>lastIndex</code>开始向后匹配。</p>
<h2 id="字符串的实例方法">字符串的实例方法</h2>
<p>字符串的实例方法，有四种与正则表达式有关：</p>
<ul>
<li>String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</li>
<li>String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li>String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li>String.prototype.split()：按照给定的正则表达式进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="stringprototypematch">String.prototype.match()</h3>
<p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<pre><code class="language-javascript">var str = 'hillstone network';
var regex1 = /n/;
var regex2 = /a/;
console.log(str.match(regex1));//['n']
console.log(str.match(regex2));//null
</code></pre>
<p>从上述代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式包含<code>g</code>修饰符，则<code>match</code>方法与正则对象的<code>exec</code>方法行为有所区别：<strong>会一次性返回包含所有匹配结果的数组</strong>：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abcabc';
console.log(regex.exec(str));//['a']
console.log(str.match(regex));//['a', 'a']
</code></pre>
<p>设置正则对象的<code>lastIndex</code>属性，对<code>match</code>方法<strong>无效</strong>，匹配总是从字符串的第一个字符开始：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abcabc';
regex.lastIndex = 4;
console.log(str.match(regex));//['a', 'a']
console.log(regex.lastIndex);//0
</code></pre>
<h3 id="stringprototypesearch">String.prototype.search()</h3>
<p>字符串实例对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置，如果没有任何匹配，则返回<code>-1</code>。</p>
<pre><code class="language-javascript">var regex1 = /a/;
var regex2 = /b/;
var str = 'account';
console.log(str.search(regex1));//字符串index=0的位置匹配到'a',返回0
console.log(str.search(regex2));//字符串匹配不到'b'，返回-1
</code></pre>
<h3 id="stringprototypereplace">String.prototype.replace()</h3>
<p>字符串实例对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式；第二个是是替换的内容。</p>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值：</p>
<pre><code class="language-javascript">console.log('aaa'.replace('a', 'b'));//'baa'
console.log('aaa'.replace(/a/, 'b'));//'baa'
console.log('aaa'.replace(/a/g, 'b'));//'bbb'
</code></pre>
<p>最后一个表达式中，带了<code>g</code>修饰符，故字符串中的'a'全部替换为'b'。</p>
<p><code>replace</code>方法的一个应用就是消除字符串首尾空格：</p>
<pre><code class="language-javascript">var str = '  #id div.class  ';
console.log(str.replace(/^\s+|\s+$/g, ''));//'#id div.class'
</code></pre>
<p><strong>思考：上面的正则不带<code>g</code>修饰符会是什么结果？</strong></p>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容：</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$`</code>：匹配结果前面的文本。</li>
<li><code>$'</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<pre><code class="language-javascript">var str = 'How to use Regex Expression in the replace method.';
// 结果为How to use &quot;Regex Expression&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$&amp;&quot;'));
// 结果为How to use &quot;How to use&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$`&quot;'));
// 结果为How to use &quot; in the replace method.&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$\'&quot;'));
// 结果为How to use replace method in the Regex Expression.
console.log(str.replace(/(Regex Expression) in the (replace method)/, '$2 in the $1'))；
// 结果为How to use $ in the Regex Expression.
console.log(str.replace(/Regex Expression/, '$$'))；
</code></pre>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换成函数的返回值：</p>
<pre><code class="language-javascript">// 字符串中的整数乘以2
'1 and 12 and 123'.replace(/\d+/g, function(match) {
    return match * 2;
});
// 字符串中的单词首字母大写
'hillstone network'.replace(/\b\w|\s\w/g, function(match) {
    return match.toUpperCase();
});
</code></pre>
<p>作为<code>replace</code>方法第二个参数的函数，可以接受多个参数。其中，第一个参数是匹配到的内容，第二个参数是匹配到的组（有多少个匹配到的组，就有多少个对应的参数）。此外，最后还能有两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。下面是一个网页模板替换的例子：</p>
<pre><code class="language-javascript">const prices = {
    p1: '$1.99',
    p2: '$9.99',
    p3: '$3.68'
};
const template = `&lt;div&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
&lt;/div&gt;`;
template.replace(/(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g, function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
});
</code></pre>
<p>结果如下：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h3 id="stringprototypesplit">String.prototype.split()</h3>
<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各部分组成的数组。该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数（可选）是返回数组的最大成员数。</p>
<pre><code class="language-javascript">var str = 'a, b,c, d';

// 非正则分割
console.log(str.split(','));
// [ 'a', '  b', 'c', ' d' ]

// 正则分割，去除多余空格
console.log(str.split(/, */));
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
console.log(str.split(/, */, 2));
// [ 'a', 'b' ]
</code></pre>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<pre><code class="language-javascript">// 例一
console.log('aaa*a*'.split(/a*/));//['', '*', '*']
// 例二
console.log('aaa**a'.split(/a*/));//['', '*', '*', '']
</code></pre>
<p>上述代码的分割规则是：<strong>0次或多次的a</strong>，由于正则默认是<code>贪婪匹配</code>，所以例一中有两个分隔符：<code>aaa</code>和<code>a</code>，例二中有三个分隔符：<code>aaa</code>和<code>''</code>和<code>a</code>。</p>
<p>另外，如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回：</p>
<pre><code class="language-javascript">console.log('aaa*a*'.split(/(a*)/));//['', 'aaa', '*', 'a', '*']
</code></pre>
<p>上述代码中，最终返回数组的第二项<code>'aaa'</code>和第四项<code>'a'</code>就是组匹配的结果。</p>
<h2 id="匹配规则">匹配规则</h2>
<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符">字面量字符和元字符</h3>
<h4 id="字面量字符">字面量字符</h4>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”。</p>
<pre><code class="language-javascript">/dog/.test('dog and cat');//true
</code></pre>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起，所以测试字符串匹配成功。</p>
<h4 id="元字符">元字符</h4>
<p>除了字面量字符，还有一部分字符有特殊含义，不代表字面的意思。它们叫做<code>元字符</code>，主要有以下几个：</p>
<h5 id="1-点字符">(1) 点字符<code>.</code></h5>
<p>点字符<code>.</code>匹配除回车<code>\r</code>、换行<code>\n</code>、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code class="language-javascript">/b.g/.test('bag');//true
/b.g/.test('bug');//true
/b.g/.test('b g');//true
/b.g/.test('b.g');//true
/b.g/.test('buug');//false
</code></pre>
<h5 id="2-位置字符和">(2) 位置字符<code>^</code>和<code>$</code></h5>
<p>位置字符用来提示字符所处的位置，主要有两个字符：</p>
<ul>
<li><code>^</code>：字符串的开始位置。</li>
<li><code>$</code>：字符串的结束位置。</li>
</ul>
<pre><code class="language-javascript">/^hillstone/.test('hillstone network');//true
/hillstone$/.test('suzhou hillstone');//true
/^hillstone$/.test('hillstone network');//false
/^hillstone$/.test('hillstone');//true
</code></pre>
<h5 id="3-选择符">(3) 选择符<code>|</code></h5>
<p>竖线符号<code>|</code>在正则中表示“或”关系，例如<code>suzhou|beijing</code>匹配<code>suzhou</code>或<code>beijing</code>。</p>
<pre><code class="language-javascript">/suzhou|beijing/.test('suzhou hillstone');//true
/suzhou|beijing/.test('beijing hillstone');//true
</code></pre>
<p>多个选择符可以联合使用：</p>
<pre><code class="language-javascript">var regex = /apple|banana|orange/;//匹配&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;的任意一项
</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号：</p>
<pre><code class="language-javascript">/a( |\t)b/.test('a\tb');//true
/a( |\t)b/.test('a b');//true
</code></pre>
<p>上述代码表示<code>a</code>和<code>b</code>之间有一个空格或一个制表符。</p>
<h5 id="4-其它元字符">(4) 其它元字符</h5>
<p>另外还有一些元字符，如：<code>\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文介绍。</p>
<h4 id="转义符">转义符</h4>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面加上反斜杠<code>\</code>。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="language-javascript">/1+1/.test('1+1');//false
/1\+1/.test('1+1');//true
</code></pre>
<p>上述第一个表达式中，<code>+</code>是元字符，所以在正则中不代表其字面含义，需要匹配<code>+</code>本身时，需要对其进行一次转义，所以第二个表达式匹配成功。</p>
<p>正则表达式中，需要反斜杠<code>\</code>转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\</code>。需要特别注意的是，<strong>如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠</strong>，因为字符串内部会先转义一次。</p>
<pre><code class="language-javascript">new RegExp('1\+1').test('1+1');//false
new RegExp('1\\+1').test('1+1');//true
</code></pre>
<p>上述代码中，通过<code>RegExp</code>构造函数创建一个正则对象，而构造函数的参数是一个字符串。而在字符串内部，反斜杠<code>\</code>也是转义字符，所以<code>+</code>会被字符串转义一次，然后再被正则转义一次，最终才创建出正确的正则对象。</p>
<p>在Chrome的Console中分别输入<code>'1\+1'</code>和<code>'1\\+1'</code>，看看最终得到的字符串是什么？</p>
<h4 id="特殊字符">特殊字符</h4>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h4 id="字符类">字符类</h4>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[abc]</code>表示<code>a</code>、<code>b</code>、<code>c</code>中任选一个匹配：</p>
<pre><code class="language-javascript">/[abc]/.test('bug');//true
/[abc]/.test('egg');//false
</code></pre>
<p>有两个字符在字符类中有特殊含义：脱字符<code>^</code>和连字符<code>-</code>。</p>
<h5 id="脱字符">脱字符<code>^</code></h5>
<p>如果方括号内的第一个字符是<code>^</code>，则表示匹配<strong>至少包含</strong>一个<strong>不在字符类中的字符</strong>的字符串。换句话说，如果方括号内通过脱字符<code>^</code>指定了一堆字符，那么这些字符以外的其它字符都可以匹配。</p>
<pre><code class="language-javascript">/[^a]/.test('a');//false：不包含a以外的字符
/[^a]/.test('b');//true：包含a以外的字符
/[^ab]/.test('a');//false：不包含a、b以外的字符
/[^ab]/.test('ac');//true：包含a、b以外的字符c
/[^ab]/.test('c');//true：包含a、b以外的字符c
</code></pre>
<p>如果方括号内没有其他字符，即<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，上文中介绍的点字符<code>.</code>是不包括换行符的。</p>
<pre><code class="language-javascript">/hillstone[^]network/.test('hillstone network');//true
/hillstone[^]network/.test('hillstone.network');//true
/hillstone[^]network/.test('hillstone\rnetwork');//true
/hillstone.network/.test('hillstone network');//true
/hillstone.network/.test('hillstone.network');//true
/hillstone.network/.test('hillstone\rnetwork');//false
</code></pre>
<blockquote>
<p>注意，脱字符只有在<strong>字符类的第一个位置</strong>才有特殊含义，否则就是字面含义。</p>
</blockquote>
<h5 id="连字符-">连字符<code>-</code></h5>
<p>某些情况下，对于连续序列的字符，连字符<code>-</code>用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以简写成<code>[a-c]</code>，<code>[0123456789]</code>可以简写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母</p>
<pre><code class="language-javascript">/a-z/.test('b');//false
/[a-z]/.test('b');//true
</code></pre>
<p>上述代码中，第一个例子匹配失败，原因是连字符<code>-</code>若不是出现在方括号<code>[]</code>中，则不具备简写的作用，只代表字面意义，所以只匹配包含<code>a-z</code>这三个字符的字符串。只有当连字符用在方括号中，才表示连续的字符序列。</p>
<p>常见的字符类简写形式有：<code>/[0-9]/</code>、<code>/[a-z]/</code>、<code>/[A-Z]/</code>、<code>/[0-9a-zA-Z]/</code>。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则有可能会匹配到一些意料之外的字符。例如：<code>/[A-z]/</code>可能第一眼会认为匹配大写的<code>A</code>到小写的<code>z</code>这52个字母，但是由于在ASCII编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果：</p>
<pre><code class="language-javascript">// 反斜杠&quot;\&quot;的ASCII码在大写字母和小写字母之间
/[A-z]/.test('\\');//true
// 改写方案一：
/[A-Za-z]/.test('\\');//false
// 改写方案二：
/[A-Z]/i.test('\\');//false
</code></pre>
<h4 id="预定义模式">预定义模式</h4>
<p>预定义模式指的是某些常见模式的简写方式：</p>
<ul>
<li><code>\d</code>：匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code>：匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code>：匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]。</code></li>
<li><code>\W</code>：匹配除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code>：匹配空格（包括换行符、制表符、空格符等），相当于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code>：匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code>：匹配单词的边界字符。</li>
<li><code>\B</code>：匹配单词的非边界字符。</li>
</ul>
<p>下面是一些例子：</p>
<pre><code class="language-javascript">// \s的例子
'hillstone network'.match('\\s\\w+');//[&quot; network&quot;]

// \b的例子
'hillstone network'.match('\\bnetwork');//[&quot;network&quot;]
'hillstone-network'.match('\\bnetwork');//[&quot;network&quot;]
'hillstonenetwork'.match('\\bnetwork');//null

// \B 的例子
'hillstone-network'.match('\\Bnetwork');//null
'hillstonenetwork'.match('\\Bnetwork');//network
</code></pre>
<p>通常，正则表达式遇到换行符<code>\n</code>就会停止匹配：</p>
<pre><code class="language-javascript">//匹配结果为：“&lt;b&gt;hillstone&lt;/b&gt;&quot;
/.*/.exec('&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;')[0];
</code></pre>
<p>上述代码中，字符串中包含一个换行符<code>\n</code>，导致点字符<code>.</code>无法匹配整个字符串。利用<code>\s</code>和<code>\S</code>这两个预定义模式进行改写，就能完全匹配：</p>
<pre><code class="language-javascript">//匹配结果为：&quot;&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;&quot;
/[\s\S]*/.exec('&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;')[0];
</code></pre>
<p>上述代码中，<code>[\s\S]</code>指代一切字符。</p>
<p>至此，我们已经知道有两种方式可以用来匹配一切字符：<code>[^]</code>和<code>[\s\S]</code>。</p>
<h4 id="重复类">重复类</h4>
<p>模式的精确匹配次数，使用大括号<code>{}</code>表示，<code>{n}</code>表示恰好出现<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复次数不少于<code>n</code>次且不多于<code>m</code>次：</p>
<pre><code class="language-javascript">/lo{2}k/.test('look');//true
/lo{2,}k/.test('look');//true
/lo{2,}k/.test('loook');//true
/lo{2,4}k/.test('loook');//true
/lo{2,4}k/.test('loooook');//false
/lo{2,4}/.test('loooook');//true：这里为什么是true？
</code></pre>
<h4 id="量词符">量词符</h4>
<p>量词符用来表示某个模式出现的次数：</p>
<ul>
<li><code>?</code>：表示某个模式出现0次或1次，等价于<code>{0,1}</code>。</li>
<li><code>*</code>：表示某个模式出现0次或多次，等价于<code>{0,}</code>。</li>
<li><code>+</code>：表示某个模式出现1次或多次，等价于<code>{1,}</code>。</li>
</ul>
<pre><code class="language-javascript">// ?：出现0次或1次
/go?d/.test('gd');//true
/go?d/.test('god');//true
/go?d/.test('goooood');//false

// *：出现0次或多次
/go*d/.test('gd');//true
/go*d/.test('god');//true
/go*d/.test('goooood');//true

// +：出现1次或多次
/go+d/.test('gd');//false
/go+d/.test('god');//true
/go+d/.test('goooood');//true
</code></pre>
<h4 id="贪婪模式">贪婪模式</h4>
<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这种模式叫做<code>贪婪模式</code>。</p>
<pre><code class="language-javascript">/o?/.exec('oooooo')[0];//'o'
/o*/.exec('oooooo')[0];//'oooooo'
/o+/.exec('oooooo')[0];//'oooooo'
</code></pre>
<p>上面的正则表示匹配<code>至少1个o</code>形式的字符串，由于正则默认是<code>贪婪匹配</code>，那么会一直匹配到不出现<code>o</code>为止。</p>
<p>如果要改为<code>非贪婪模式</code>，在量词符后加上一个<code>?</code>即可，这样一旦条件满足就不再往下匹配：</p>
<pre><code class="language-javascript">/o??/.exec('oooooo')[0];//''
/o*?/.exec('oooooo')[0];//''
/o+?/.exec('oooooo')[0];//'o'
</code></pre>
<h4 id="修饰符">修饰符</h4>
<p><code>修饰符</code>表示模式的附加规则，放在正则模式的最尾部，总共有三种：</p>
<ul>
<li><code>g</code>修饰符：表示全局匹配。</li>
<li><code>i</code>修饰符：表示忽略大小写。</li>
<li><code>m</code>修饰符：表示匹配多行。</li>
</ul>
<p>这些修饰符可以单独使用，也可以多个一起使用：</p>
<pre><code class="language-javascript">'Hillstone'.match(/hillstone/i);//['Hillstone']
'Hillstone hillstone'.match(/hillstone/gi);//['Hillstone', 'hillstone']
</code></pre>
<h5 id="g修饰符"><code>g</code>修饰符</h5>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配，加上它之后，正则对象将匹配全部符合条件的结果，主要用于<strong>搜索</strong>和<strong>替换</strong>。</p>
<pre><code class="language-javascript">var regex1 = /o/;
var regex2 = /o/g;
var str = 'oop';

// 不加g修饰符
regex1.test(str);//true
regex1.test(str);//true
regex1.test(str);//true

// 加g修饰符
regex2.test(str);//true
regex2.test(str);//true
regex2.test(str);//false
</code></pre>
<p>上述代码中连续执行三次<code>regex1.test(str)</code>和<code>regex2.test(str)</code>。前者三次都匹配成功，是因为每次都是从字符串的开始位置开始匹配；后者前两次匹配成功，最后一次失败，是因为每次匹配都是从<code>lastIndex</code>开始匹配，第三次匹配的时候<code>lastIndex</code>值为2，对应字符为<code>p</code>，所以匹配失败。</p>
<h5 id="i修饰符"><code>i</code>修饰符</h5>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符后表示忽略大小写。</p>
<pre><code class="language-javascript">/hillstone/.test('HillStone');//false
/hillstone/i.test('HillStone');//true
</code></pre>
<h5 id="m修饰符"><code>m</code>修饰符</h5>
<p>默认情况下，字符串无论是否换行都只有一个开始<code>^</code>和结尾<code>$</code>，如果采用多行匹配，那么每一行都有一个开始<code>^</code>和结尾<code>$</code>。</p>
<pre><code class="language-javascript">// 只有一个开始和结尾
/^network/.test('hillstone\nnetwork');//false
/network$/.test('hillstone network\n');//false

// 多个开始和结尾
/^network/m.test('hillstone\nnetwork');//true
/network$/m.test('hillstone network\n');//true
</code></pre>
<h4 id="组匹配">组匹配</h4>
<h5 id="概述">概述</h5>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容：</p>
<pre><code class="language-javascript">/end+/.test('endd');//true
/(end)+/.test('endend');//true
</code></pre>
<p>上述代码中，第一个模式没有括号，所以<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，所以<code>+</code>表示重复单词<code>end</code>。</p>
<p>下面是另外两个分组捕获的例子：</p>
<pre><code class="language-javascript">// 例子1
/(.)b(.)/.match('abcabc');//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// 例子2
/(.)b(.)/g.match('abcabc');//[&quot;abc&quot;, &quot;abc&quot;]
</code></pre>
<p>上述代码的两个例子仅仅相差一个<code>g</code>修饰符，<code>match</code>方法的结果却有很大差异：一个捕获了匹配整个表达式的部分和所有分组，一个捕获了匹配整个表达式的所有子串。所以这里有一点需要注意：<strong>使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容</strong>。</p>
<p>如果一定需要将<code>组匹配</code>和<code>g</code>修饰符结合起来使用，可以用正则对象的<code>exec</code>方法搭配循环来实现：</p>
<pre><code class="language-javascript">var regex = /(.)b(.)/g;
var str = 'abcabc';
while(true) {
    var result = regex.exec(str);
    if(!result) break;
    else console.log(result);
}
//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
</code></pre>
<p>正则表达式内部还可以用<code>\n</code>来引用组匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的组匹配的内容：</p>
<pre><code class="language-javascript">/(.)b(.)\1b\2/.exec('abcabc');//[&quot;abcabc&quot;, &quot;a&quot;, &quot;c&quot;]
/(.)b(.)\2b\1/.exec('abccba')[0];//[&quot;abccba&quot;, &quot;a&quot;, &quot;c&quot;]
</code></pre>
<p>上述代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>括号还支持嵌套：</p>
<pre><code class="language-javascript">/((ab)\2)\1/.exec('ababababc');//[&quot;abababab&quot;, &quot;abab&quot;, &quot;ab&quot;]
</code></pre>
<p>上述代码中，<code>\1</code>表示外层括号，<code>\2</code>表示内层括号。在存在组嵌套的表达式中，<code>\n</code>是类似于深度优先的方式来进行标号，如下图所示：</p>
<pre><code class="language-javascript">/(a(b))(c)(d)\1\2\3\4/.test('abcdabbcd');
 | |   |  |___  \4
 | |   |______  \3
 | |__________  \2
 |____________  \1
</code></pre>
<p>组匹配非常有用，下面是一个匹配网页标签的例子：</p>
<pre><code class="language-javascript">var result = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;);
var htmlFragment = result[0];
var tagName = result[1];
console.log(htmlFragment);//&quot;&lt;b&gt;bold&lt;/b&gt;&quot;
console.log(tagName);//&quot;b&quot;
</code></pre>
<p>上述代码中的正则表达式，应该是本文学到现在见过的最复杂的正则，我们来梳理一下：</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602727276949.png" alt="匹配网页标签正则解析" loading="lazy"></figure>
<p>拆解之后，我们很容易看出该表达式是用来匹配类似<code>&lt;span&gt;hillstone&lt;/span&gt;</code>这样的字符串，也就是匹配网页标签。</p>
<p>将上述代码稍作修改，就能匹配带属性的标签：</p>
<pre><code class="language-javascript">var result = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/.exec('&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;');
console.log(result[1]);//b
console.log(result[2]);// class=&quot;hello&quot;
console.log(result[3]);//Hello
</code></pre>
<h5 id="非捕获组">非捕获组</h5>
<p><code>(?:x)</code>称为非捕获组，表示匹配结果中不包含该组匹配的内容：</p>
<pre><code class="language-javascript">// 正常组匹配
'abc'.match(/(.)b(.)/);//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// 非捕获组匹配
'abc'.match(/(?:.)b(.)/);//[&quot;abc&quot;, &quot;c&quot;]
</code></pre>
<p>上述第二个例子中，第一个组采用了<code>非捕获组</code>匹配，所以最终返回的结果没有第一个括号，只有第二个括号的内容。</p>
<p>再来看一个分解网址的正则表达式：</p>
<pre><code class="language-javascript">// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]
</code></pre>
<p>上述代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<h5 id="先行断言">先行断言</h5>
<p><code>x(?=y)</code>称为<code>先行断言</code>，意思是<code>x</code>必须在<code>y</code>之前才匹配，<code>y</code>不会被记入返回结果：</p>
<pre><code class="language-javascript">var regex = /\d+(?=%)/;//匹配后面跟着'%'的数字
'97%'.match(regex);//[&quot;97&quot;]
</code></pre>
<p>上述代码使用了<code>先行断言</code>，括号内的<code>%</code>不会作为结果返回。</p>
<h5 id="先行否定断言">先行否定断言</h5>
<p><code>x(?!y)</code>称为<code>先行否定断言</code>，<code>x</code>只有不在<code>y</code>之前才匹配，<code>y</code>不会被记入返回结果：</p>
<pre><code class="language-javascript">var regex1 = /\d+(?!%)/;//匹配后面不是跟着'%'的数字
'97%'.match(regex1);//['9']
'97c'.match(regex1);//['97']

var regex2 = /\d+(?!\.)/;//匹配后面不是跟着'.'的数字
'3.14'.match(regex2);//['14']
'1234'.match(regex2);//['1234']
</code></pre>
<p>上述代码使用了<code>先行否定断言</code>，括号内对应的<code>%</code>、<code>.</code>等都不会作为结果返回。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何绘制一个带飞线动效的旋转3D地球]]></title>
        <id>https://xiewangmei.github.io/post/3d-earth/</id>
        <link href="https://xiewangmei.github.io/post/3d-earth/">
        </link>
        <updated>2020-10-15T01:42:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="期望效果图">期望效果图</h2>
<p><img src="https://xiewangmei.github.io/post-images/1602726769537.gif" alt="期望效果" loading="lazy"><br>
从效果图中，我们提炼出几个需要实现的关键点：</p>
<ul>
<li>绘制一个立体地球</li>
<li>实现地球颜色渐变（左上角稍亮，右下角稍暗）</li>
<li>实现地球上的点，点的连线，连线上的飞点</li>
<li>实现地球自转</li>
<li>实现根据鼠标的移入移出切换地球的自动旋转</li>
<li>实现中国地图鼠标悬浮高亮效果</li>
<li>实现拖拽</li>
</ul>
<h2 id="确定地球的dom结构">确定地球的DOM结构</h2>
<p>我们按照<code>海洋→陆地→球面点→连线→飞点</code>这样的顺序来分层绘制地球，所以其DOM结构如下：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h2 id="绘制一个基础地球">绘制一个基础地球</h2>
<p>地球由<strong>海洋</strong>和<strong>陆地</strong>组成，我们在实现时也按照这两个部分分步绘制。</p>
<h3 id="绘制海洋">绘制海洋</h3>
<p>这部分最为简单，在画布中心绘制一个直径稍小于画布宽高的圆即可，为其填充蓝色</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<pre><code class="language-javascript">const oceanCanvas = document.getElementById(&quot;#oceanCanvas&quot;);
const { width, height } = oceanCanvas;
const cx = width/2;
const cy = height/2;
const oceanCanvasContext = oceanCanvas.getContext(&quot;2d&quot;);
const oceanRadius = Math.min(width, height) * 0.8;
oceanCanvasContext.fillStyle = &quot;blue&quot;;
oceanCanvasContext.arc(cx, cy, oceanRadius, 0, Math.PI);
oceanCanvasContext.fill();
</code></pre>
<h3 id="绘制陆地">绘制陆地</h3>
<p>准备好一份标准的<code>worldmap.json</code>，用作陆地数据。</p>
<p>我们在海洋画布上方罩一个同尺寸的画布，用于绘制陆地。</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;landCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>有了数据，怎么把数据转换成一个个图呢？这里我们引入<code>d3</code>库，它提供了一套完备的API可供绘制地图。</p>
<pre><code class="language-javascript">// 创建投影
const projection = d3.geoOrthographic().clipAngle(90).scale(oceanRadius).translate([cx, cy]).rotate([90, 0, 0]);
// 依据投影创建路径生成器
const path = d3.geoPath(projection);
landCanvasContext.fillStyle = &quot;skyblue&quot;;
landCanvasContext.strokeStyle = &quot;skyblue&quot;;
// 提取陆地数据中的features
const features = worldmap.features;
features.forEach(f =&gt; {
    landCanvasContext.beginPath();
    path.context(landCanvasContext)(f);
    landCanvasContext.closePath();
    landCanvasContext.stroke();
    landCanvasContext.fill();
});
</code></pre>
<p>到这一步，我们应该能画出一个静止的地球了。</p>
<h2 id="实现地球的颜色渐变">实现地球的颜色渐变</h2>
<p>由于陆地是由成百上千个路径组成，对其填充色做渐变处理会十分麻烦。而由于海洋是一个简单圆形，实现渐变会相对简单，故我们将渐变色填充给海洋，陆地则填充一个带有透明度的色值，这样效果能比较接近。</p>
<pre><code class="language-javascript">const highlightCenterX = cx - oceanRadius/2;
const highlightCenterY = cy - oceanRadius/2;
const grd = context.createRadialGradient(highlightCenterX, highlightCenterY, r/8, highlightCenterX, highlightCenterY, 1.25 * oceanRadius);
grd.addColorStop(0, &quot;#0d4484&quot;);
grd.addColorStop(1, &quot;#041e3c&quot;);
context.fillStyle = grd;
context.arc(cx, cy, r, 0, Math.PI);
context.fill();
...
landCanvasContext.fillStyle = &quot;rgba(0, 80, 192, 0.4)&quot;;// 陆地修改为带透明度的色值
...
</code></pre>
<p>到这一步，地球已经加上了渐变效果。</p>
<h2 id="绘制球面上的点">绘制球面上的点</h2>
<p>球面上的点实际上是一个个的经纬度坐标，而要将这些经纬度坐标转成屏幕坐标仍旧需要借助<code>d3</code>的API</p>
<pre><code class="language-javascript">const geoPath = d3.geoPath(projection);// 依据投影创建一个路径生成器
const enterFn = enter =&gt; {
    const g = enter.append(&quot;g&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;full&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;circle&quot;);
};
const updateFn = update =&gt; {
    update.each(function(d) {
        const circle = d3.geoCircle().center(d.geometry.coordinates);// 根据投影创建圆生成器
        const color = d.color;
        const g = d3.select(this);
        g.select(&quot;path.full&quot;).attr(&quot;fill&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(1.5)()));
        g.select(&quot;path.circle&quot;).attr(&quot;stroke&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(2)()));
    });
};
svg.selectAll(&quot;g&quot;).data(points).join(enterFn, updateFn);
</code></pre>
<p>到这一步，球面上的点绘制完成</p>
<h2 id="绘制点之间的连线">绘制点之间的连线</h2>
<p>绘制连线可以采用插值器的方式实现，具体可以参考<code>d3</code>官网的<a href="http://bl.ocks.org/dwtkns/4973620">例子</a>，但是我们要实现的效果跟官网有些许区别：官网示例中，当其中一个点转到地球背面时，整条线都不可见；而我们是尽可能多地展示连线可见部分。所以得另辟蹊径。</p>
<p><img src="https://xiewangmei.github.io/post-images/1602726832506.png" alt="地球连线示意图" loading="lazy"><br>
如上图所示，地球外层画了一系列圆圈，这些圆圈可以理解为地球外侧的一系列轨道，我们可以在轨道上取一系列的点，将这些点用短线段进行连接，最终形成一个完整的从起点到终点的连线。上图中的连线看起来不平滑，所以我们实际操作时可以<strong>适当减小轨道间距，增加轨道数，以增加平滑度</strong>。</p>
<p><strong>注：为何不采用二次贝塞尔曲线？二次贝塞尔曲线需要根据轨道上每个点的二维坐标计算控制点，随着地球的旋转，坐标一直在发生变化，控制点也会随之改变，这样绘制出的曲线就会有在地球表面&quot;拖动&quot;的效果</strong></p>
<h3 id="选取连线上的点">选取连线上的点</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602726866367.png" alt="地球连线示意图2" loading="lazy"></figure>
<p>任何两点之间的连线，我们都可以通过旋转地球达到上图所示的效果，所以我们简化问题，以此视角进行分析：</p>
<p>前面提到过，地球外层的一系列圆圈可以理解为轨道，那么这些轨道上的点一定可以投影到地球表面，找到对应的地理坐标。反之，我们找到这些地球表面上的点，就能根据轨道投影找到轨道上对应位置的点。观察上图中点与点之间间距变化发现：左右对称，并且从起点到最外层轨道间距是逐渐增大（貌似在暗示我们用<code>d3.scalePow()</code>）。</p>
<p>我们目前的已知项只有起终点坐标，而借助<code>d3.geoInterpolate(start, end)(ratio)</code>可以得出<strong>两点间指定比例(ratio：0~1)的点的经纬度坐标</strong>，有了这一系列的经纬度坐标，投影上的位置相应也能够得出。所以，问题又简化成如何计算出**类似[ 0, 0.0625, 0.125, 0.25, 0.5, 0.75, 0.875, 0.7375, 1 ]**的<code>ratios数组</code>。</p>
<p>前面我们讲到，连线左右对称，且左半部分间距逐渐增大，可以用<code>d3.scalePow()</code>来实现：</p>
<pre><code class="language-javascript">// size：轨道数量(地球表面算第0个轨道)
// 计算左半边弧线的比率
const calcRatios = size =&gt; {
  const scale = d3
    .scalePow()
    .exponent(2)
    .domain([0, size - 1])
    .range([0, 0.5]);
  let i = 0;
  const result = [];
  while (i &lt; size) result.push(scale(i++));
  // 拼接出弧线上的所有比率
  return [
    ...result,
    ...result
      .slice(0, result.length - 1)
      .map(v =&gt; 1 - v)
      .reverse()
  ];
};
</code></pre>
<p>现在有了<code>ratios数组</code>，再通过公式<code>d3.geoInterpolate(start, end)(ratio)</code>可以计算出对应比例的经纬度坐标，有了经纬度坐标，就能通过各自对应的投影得到这些点在屏幕上的位置：</p>
<pre><code class="language-javascript">// 此处略过创建projections的代码
const ratios = calcRatios(projections.length);
const interpolate = d3.geoInterpolate(start, end);
const infos = ratios.map((ratio, i) =&gt; {
    const geoLocation = interpolate(ratio);
    const projection = 
          i &lt; projections.length 
          ? projection[i] 
          : projections[(projections.length - 1) * 2 - i];
    const screenLocation = projection(geoLocation);
    // 这里返回了比例、经纬度、投影、屏幕坐标,备用
    return { ratio, geoLocation, projection, screenLocation };
});
</code></pre>
<p>前文中为了方便讲解投影，比例等概念，将地球旋转到了一个完美角度，这个时候线上所有点均可见。但在地球不断旋转的过程中，经常会有线的一段甚至整段处于地球背面的情况，所以需要对这些点进行过滤处理：</p>
<ul>
<li>起终点均可见——不过滤</li>
<li>起点可见终点不可见——找到最后一个可见的点</li>
<li>起点不可见终点可见——找到第一个可见的点</li>
</ul>
<p>我们以可视半球的正投影中心（圆心）为参考点，可视半球上的任意一点到参考点的弧度差范围在<code>0 ~ π/2</code>之间，不可视半球上的点到参考点的弧度差在<code>π/2 ~ π</code>之间，<code>d3.geoDistance(coordinate1, coordinate2)</code>可用来计算球面上两个经纬度之间的弧度差，根据差值即可判定出该点是落在可视半球还是非可视半球上。</p>
<pre><code class="language-javascript">const { start, end } = link;// 假定link是众多线中的其中一条的数据
const center = projections[0].invert([w/2, h/2]);// 得到正投影圆心的经纬度
const distBetweenStartCenter = d3.geoDistance(center, start);
const distBetweenEndCenter = d3.geoDistance(center, end);
if(distBetweenStartCenter &gt;= 1.57 &amp;&amp; distBetweenEndCenter &gt;= 1.57) {
   return [];
}else {
    if(distBetweenStartCenter &gt;= 1.57) {// 起点不可见
       const firstVisiblePointIndex = infos.findIndex(
           info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
           1.57 + Math.acos(projections[0].scale() / info.projection.scale())
       );
       return infos.slice(firstVisible);
    } else if(distBetweenEndCenter &gt;= 1.57) { // 终点不可见
       const lastVisiblePointIndex = [...infos]
           .reverse()
           .findIndex(
               info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
               1.57 + Math.acos(projections[0].scale() / info.projection.scale())
           );
        return infos.slice(0, infos.length - lastVisiblePointIndex);
    } else {// 起终点均可见
        return infos;
    }
}
</code></pre>
<h3 id="以点成线">以点成线</h3>
<p>到这里，我们就能够循环遍历infos绘制出所有连线了。不过在此之前，我们需要将上一步最后的代码包到函数里方便调用：</p>
<pre><code class="language-javascript">const calcLinkPoints = (start, end, projection, w, h) =&gt; {
    // 计算infos
    return infos;
};
</code></pre>
<p>画线：</p>
<pre><code class="language-javascript">linkCanvasContext.lineWidth = 0.5;
linkCanvasContext.strokeStyle = &quot;rgba(146, 191, 243, 0.8)&quot;;
links.forEach(data =&gt; {
    data.points = calcLinkPoints(data.source, data.target, projections, width, height);
    if(data.points.length) {
        d3.line().context(linkCanvasContext)(
            data.points.map(info =&gt; info.screenLocation)
        );
    }
});
</code></pre>
<h2 id="绘制线上的飞点">绘制线上的飞点</h2>
<p>我们看到的线上的飞点是由一个个圆心连续，半径逐渐变小且颜色逐渐变淡的圆组合而成。<br>
<img src="https://xiewangmei.github.io/post-images/1602726899299.png" alt="地球连线示意图3" loading="lazy"></p>
<p>点与点之间的位置及比例关系：<br>
<img src="https://xiewangmei.github.io/post-images/1602726916062.png" alt="地球连线示意图4" loading="lazy"></p>
<pre><code class="language-javascript">const getRadius = d3
  .scaleLinear()
  .domain([0, 30])
  .range([1.5, 0]);
const colorInterpolate = d3.interpolate([&quot;#FFFFFF&quot;, &quot;#92BFF3&quot;]);
const scaleColor = d3
  .scaleLinear()
  .domain([0,30])
  .range([0,1]);
const getGradientCircleRadiusAndFill = index =&gt; ({
  r: getRadius(index),
  fill: getColor(index)
});

const drawFlyPoint = (context, links) =&gt; {
    links.forEach(data =&gt; {
        // curRatio:飞点当前位置占线总长的百分比
        const curRatio = data.ratio;
        // 找到第一个比飞点当前位置大的百分比(轨道上的比率)
        const firstBiggerIndex = data.points.findIndex(p =&gt; p.ratio &gt; curRatio);
        if(firstBiggerIndex &lt;= 0) {
        } else {
            const p1 = data.points[firstBiggerIndex - 1];
            const p3 = data.points[firstBiggerIndex];
            const r = (curRatio - p1.ratio) / (p3.ratio - p1.ratio);
            const p2X = 
                  p1.screenLocation[0] + 
                  r * (p3.screenLocation[0] - p1.screenLocation[0]);
            const p2Y = 
                  p1.screenLocation[1] + 
                  r * (p3.screenLocation[1] - p1.screenLocation[1]);
            const points = [
                [p2X, p2Y],
                ...data.points
                  .slice(0, firstBiggerIndex)
                  .reverse()
                  .map(p =&gt; p.screenLocation)
            ];
            
            const centers = getCirclesCenter(points);
            centers.forEach((c, index) =&gt; {
                const { r, fill } = getGradientCircleRadiusAndFill(index);
                context.fillStyle = fill;
                context.beginPath();
                context.arc(c[0], c[1], r, 0, Math.PI * 2);
                context.closePath();
                context.fill();
            });
        }
    });
};
</code></pre>
<p>这样我们就能根据每次的数据绘制出对应位置的飞点</p>
<h2 id="实现地球自转">实现地球自转</h2>
<p>地球自转实际上对应的是各个投影轨道的角度翻转(rotate)，所以比较简单：</p>
<pre><code class="language-javascript">const rotate = rotation =&gt; projections.forEach(p =&gt; p.rotate(rotation));
const animate = () =&gt; {
  links.forEach(l =&gt; {
    l.ratio = l.stepRatio + l.ratio;
    if(l.ratio &gt;= 1) l.ratio = 0;//飞点到达终点后重新开始飞点
  });
  if(autoRotate) {
    rotate(peojections[0].rotate().map((v, i) =&gt; (i === 0 ? v + 0.2 :v)));
  }
  ...
  //重新绘制地球以及点、线等
  ...
  window.requestAnimationFrame(animate);
};
</code></pre>
<h2 id="实现鼠标移入停转移出开转">实现鼠标移入停转移出开转</h2>
<p>注意到地球自转代码里有一个标志位<code>autoRotate</code>，用来决定球体是否自动旋转，那只需要对<code>mousemove</code>做个监听就行了：</p>
<pre><code class="language-javascript">d3.select(document.body)
  .on(
    &quot;mousemove&quot;,
    () =&gt; 
      (autoRotate = 
        getDistance(
          [d3.event.clientX, d3.event.clientY],
          [width / 2, height / 2]
        ) &gt; earthRadius)
  );
</code></pre>
<h2 id="实现中国地图悬浮高亮效果">实现中国地图悬浮高亮效果</h2>
<p>在前面绘制陆地部分，我们已经将所有的国家都绘制在canvas上，而在canvas上做交互会比较麻烦，所以我们将中国数据单独提取出来，绘制到svg上，这样可以对中国版图添加hover样式。</p>
<p>修改dom结构：</p>
<pre><code class="language-jsx">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;chinaSvg&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p>单独绘制中国地图部分:</p>
<pre><code class="language-javascript">const chinaFeature = features.filter(isInChina);
d3.select(chinaSvg)
  .selectAll(&quot;g.land&quot;)
  .data(chinaFeature)
  .join(
    enter =&gt;
      enter
        .append(&quot;g&quot;)
        .classed(&quot;china&quot;, true)
        .append(&quot;path&quot;)
        .attr(&quot;fill&quot;, &quot;skyblue&quot;)
        .attr(&quot;stroke&quot;, &quot;skyblue&quot;),
      update =&gt; update.select(&quot;path&quot;).attr(&quot;d&quot;, d3.geoPath(projections[0]))
  );
</code></pre>
<p>CSS：</p>
<pre><code class="language-scss">.china:hover path {
    fill: rgba(255, 200, 0, 0.8)
}
</code></pre>
<h2 id="实现拖拽">实现拖拽</h2>
<p>拖拽也是添加监听即可</p>
<pre><code class="language-javascript">const addRotateListeners = (selection, projection, rotateHander) =&gt; {
  let m0, o0;
  const body = d3.select(document.body);

  const startDrag = () =&gt; {
    m0 = [d3.event.pageX, d3.event.pageY];
    o0 = projection.rotate();
    body.on(&quot;mousemove.forRotate&quot;, drag);
    body.on(&quot;mouseup.forRotate&quot;, stopDrag);
  };
  const drag = () =&gt; {
    const m1 = [d3.event.pageX, d3.event.pageY];
    const o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
    o1[1] = o1[1] &gt; 30 ? 30 : o1[1] &lt; -30 ? -30 : o1[1];
    rotateHander(o1);
  };
  const stopDrag = () =&gt; {
    body.on(&quot;mousemove.forRotate&quot;, null);
    body.on(&quot;mouseup.forRotate&quot;, null);
  };

  selection.on(&quot;mousedown&quot;, startDrag);
};
addRotateListeners(pointSvg, projections[0], rotate);
</code></pre>
<h2 id="小结">小结</h2>
<p>至此，效果图我们已经实现完成，功能点较多，依赖于<code>d3</code>库的<code>projection</code>，还掺杂有一些数学几何知识，需要花一些时间去思考。后续可以将其封装成<code>React</code>组件或者<code>Vue</code>组件，以备不时之需</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Diff]]></title>
        <id>https://xiewangmei.github.io/post/react-diff/</id>
        <link href="https://xiewangmei.github.io/post/react-diff/">
        </link>
        <updated>2020-09-29T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="虚拟dom">虚拟DOM</h2>
<p>虚拟DOM是和真实DOM相对应的。真实DOM也就是平时我们所说的DOM，它是对结构化文本的抽象表达。在web环境中，其实就是对HTML文本的一种抽象表述，每一个HTML元素对应一个DOM节点，HTML元素的层级关系也会体现在DOM节点的层级上，所有的这些DOM节点构成一棵DOM树。</p>
<p>在传统前端开发中，通过浏览器提供的一组API直接对DOM执行增删改查操作，例如<code>getElementById</code>，<code>insertBefore</code>等。这些操作看似只执行一条<code>JavaScript</code>语句，但它们的执行效率要比执行一条普通的<code>JavaScript</code>语句慢得多，尤其是对DOM进行增删改操作，每一次对DOM的修改都会引起浏览器对页面的重新布局和重新渲染，这个过程是很耗时的。所以前端性能优化里面有一条原则：<strong>尽量减少DOM操作</strong>。</p>
<p>既然直接操作DOM效率低下，那么有什么办法可以解决这个问题呢？在软件开发中，有这么一句话，<strong>软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决</strong>。DOM效率低下的这个问题同样可以通过增加一层抽象解决，<code>虚拟DOM</code>就是对真实DOM的抽象。这里需要注意，虚拟DOM并非React独有，它是一个独立的技术，只不过React使用了这项技术来提高自身的性能。</p>
<p>虚拟DOM使用<code>普通的JavaScript对象</code>来描述DOM元素，对象的结构和<code>React.CreateElement()</code>参数类似。例如，我们有下面这样的一个DOM结构：</p>
<pre><code class="language-html">&lt;div class = 'foo'&gt;
    &lt;h1&gt;
        Hello React
    &lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>相对应的虚拟DOM就可以用下面这样的对象来描述：</p>
<pre><code class="language-javascript">const virtualDom = {
    type: 'div',
    props: {
        className: 'foo',
        children: [{
            type: 'h1',
            props: {
                children: ['Hello React']    
            }
        }]    
    },
    
};
</code></pre>
<p>有了虚拟DOM这层抽象，当我们需要操作真实DOM时，就可以操作虚拟DOM这个<code>JavaScript对象</code>，速度当然要比操作真实DOM快得多。</p>
<h2 id="diff算法">Diff算法</h2>
<p>React采用声明式的API描述UI结构(JSX)，每次组件的状态或属性更新，组件的<code>render</code>方法都会返回一个新的虚拟DOM对象用来描述新的UI结构。如果每次都直接使用新的虚拟DOM结构来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响程序执行效率。事实上，React会通过比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高执行效率。这一过程就是React的调和过程<code>(Reconciliation)</code>，其中的关键就是<code>diff算法</code>。</p>
<h3 id="react-diff算法的三大策略">React-diff算法的三大策略</h3>
<h4 id="1-tree-diff-web-ui中dom节点跨层级的移动操作特别少可以忽略不计"><strong>1. Tree Diff —— Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计</strong></h4>
<p>React把树按照层级分解，在对新旧虚拟DOM进行比较时，只会对同层进行比较（节点类型，属性）。这是React-diff算法的关键点（<strong>因为组件是树形结构，需要基于该策略做diff</strong>）。</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358709820.png" alt="同层比较" loading="lazy"></figure>
<p>如图所示，React只会相互比较相同颜色框内的节点，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。由此一来，最直接的提升就是复杂度变为线型增长而不是原先的指数增长。</p>
<p>前面我们提到了同层比较，那当我们的节点发生跨层级移动，diff算法会是什么表现呢？</p>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1601358737506.png" alt="跨层级操作" loading="lazy"></figure>
<p>B节点连同它的子节点一起移动到A节点之下，直观的考虑DOM Diff应该是</p>
<pre><code class="language-jsx">R.remove(B); 
A.append(B);
</code></pre>
<p>但是，实际上<code>React</code>只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有<code>创建</code>和<code>删除</code>操作，所以当根节点发现B节点消失了，就会删除B节点及其子节点，当A发现多了一个子节点B，就会创建新的B作为其子节点，这样DOM Diff就变成：</p>
<pre><code class="language-javascript">B.destroy();
C = new C();
D = new D();
B = new B();
B.append(C);
B.append(D);
A.append(B);
</code></pre>
<p>换句话说，这里进行了较多的DOM操作，因此，我们在开发组件时，尽量保持DOM结构稳定是一种不错的选择。</p>
<h4 id="2-componnet-diff-相同类型的组件会生成相似的树形结构不同类型的两个组件将会生成不同的树形结构"><strong>2. Componnet Diff —— 相同类型的组件会生成相似的树形结构，不同类型的两个组件将会生成不同的树形结构</strong></h4>
<ul>
<li>
<p><strong>同类型组件</strong>：按照前面所说的<code>Tree Diff策略</code>继续比较虚拟DOM。需要注意的是，在这种情况下，如果用户能确定新旧虚拟DOM之间没有任何变化，React给了我们一个<code>shouldComponentUpdate()</code>方法，通过设置返回值<code>true</code>和<code>false</code>可以决定组件是否进行diff操作，用得好的话， 可以节省大量的 diff 运算时间。</p>
</li>
<li>
<p><strong>不同类型组件</strong>：该组件判定为<code>dirty componnet</code>，替换掉整个组件包括其子节点</p>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 的这种直接删除再重新创建的机制会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://xiewangmei.github.io/post-images/1601358776690.png" alt="相似组件" loading="lazy"></figure>
<h4 id="3-对于同一层级的一组兄弟节点可以通过唯一的key值来进行区分"><strong>3. 对于同一层级的一组兄弟节点，可以通过唯一的Key值来进行区分</strong></h4>
<p>当一个节点有多个子节点时，默认情况下，React只会按照顺序逐一比较两棵树上的对应子节点，一旦新旧虚拟DOM相同位置的节点对应不上，就会进行修改操作。</p>
<p>乍一看貌似没什么问题？看个栗子：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
    &lt;li&gt;javascript&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这里我们在列表最后添加一个<code>javascript</code>，对比的时候,<code>php</code>，<code>java</code>都能匹配上，然后在最后新增<code>javascript</code>，一切顺利。那我们把<code>javascript</code>加到列表首项，像这样：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li&gt;javascript&lt;/li&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这时候的结果就是：<code>php</code>更新为<code>javascript</code>，<code>java</code>更新为<code>php</code>，最后新增<code>java</code>项，<strong>每一个节点</strong>都发生了修改。</p>
<p>为了解决这种低效的更新方式，React提供了一个Key属性，用来匹配新旧虚拟DOM的子节点，在每次渲染之后，只要子节点的Key值没有变化，React就会认为这是同一个节点。上面的例子我们这样改：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li key='javascript'&gt;javascript&lt;/li&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这样React就能判断出<code>&lt;li key='javascript'&gt;javascript&lt;/li&gt;</code>节点是新增节点，其他两个节点没有发生变化，最终只需要进行一次新增节点操作即可。</p>
<p><strong>注意</strong>：有时候我们会通过数组的map方法将每个数组成员映射到一个列表元素，这里应该尽量避免用数组的index来作为Key值。因为数组中的成员顺序一旦发生改变，可能会导致大量的Key值失效，进而引起大量的修改操作。</p>
<p>避免这种写法：</p>
<pre><code class="language-jsx">&lt;ul&gt;
    (list.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;))
&lt;/ul&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>1.开发组件时，尽量保持DOM结构的稳定，有助于提升性能。例如，可以通过设置样式来控制元素的显示隐藏，而不是真正移除或添加DOM节点。</p>
<p>2.用好<code>shouldComponentUpdate()</code>方法，减少不必要的diff计算。</p>
<p>3.在一组兄弟节点中，设置合适的Key值来帮助React识别相同节点，减少不必要的DOM操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React小知识]]></title>
        <id>https://xiewangmei.github.io/post/react-knowledge/</id>
        <link href="https://xiewangmei.github.io/post/react-knowledge/">
        </link>
        <updated>2020-09-29T05:47:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react的程序流程">React的程序流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358552129.png" alt="React程序流程" loading="lazy"></figure>
<ul>
<li>在React中无论发生何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心。</li>
</ul>
<h3 id="virtual-dom">Virtual DOM</h3>
<ul>
<li>
<p>既然DOM树是对HTML的抽象，那<code>Virtual DOM</code>就是对DOM的抽象。<code>Virtual DOM</code>不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的<code>Virtual DOM</code>和上一次渲染的<code>Virtual DOM</code>，对比就会发现差别，然后修改真正的DOM树时就只要触及差别中的部分就行了。</p>
<ul>
<li>
<p>以ClickCouter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这次重新渲染，React通过<code>Virtual DOM</code>的对比发现其实只是id为clickCount的span元素中内容从0变成了1而已：</p>
<pre><code class="language-javascript">&lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;
</code></pre>
<p>React发现这次渲染要做的事情只是更换这个span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句就可以完成任务了：</p>
<pre><code class="language-javascript">document.getElementById(&quot;clickCount&quot;).innerHTML = &quot;1&quot;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="prop和state的对比">prop和state的对比</h3>
<ul>
<li><code>prop</code>用于定义外部接口，<code>state</code>用于记录内部状态</li>
<li><code>prop</code>的赋值在外部世界使用组件时，<code>state</code>的赋值在组件内部</li>
<li>组件不应该改变<code>prop</code>的值，而<code>state</code>存在的目的就是让组件来改变的</li>
</ul>
<h3 id="refrefs">ref&amp;refs</h3>
<ul>
<li>
<p><code>React</code>支持一种非常特殊的属性<font color='red'><code>ref</code></font>，可以用来绑定到render()输出的任何组件上</p>
<ul>
<li><code>ref</code>：绑定属性</li>
<li><code>refs</code>：调用的时候使用</li>
</ul>
</li>
<li>
<p>通过<code>refs</code>访问父组件方法</p>
<pre><code class="language-jsx">this.refs.subcomponents.subHandleClick();
</code></pre>
</li>
<li>
<p>为了获取真实DOM节点，html元素必须有一个<code>ref属性</code>，然后**<code>this.refs.[refName]</code>**就会返回这个真实的DOM节点。</p>
<blockquote>
<p><strong>注意</strong>：由于**this.refs.[refName]**属性获取的是真实DOM，所以必须等到虚拟DOM插入文档后，才能使用这个属性，否则获取不到。</p>
</blockquote>
</li>
</ul>
<h3 id="组件生命周期">组件生命周期</h3>
<ul>
<li>
<p><strong><code>constructor</code></strong>：构造函数是初始化状态的合适位置。若不初始化状态且不绑定方法，那就不需要为React组件定义一个构造函数。</p>
</li>
<li>
<p><strong><code>render</code></strong>：该方法是必须的，当被调用时，其应该检查<code>this.props</code>和<code>this.state</code>，并返回以下类型中的一个：</p>
<ul>
<li>
<p><strong>React元素</strong>：通常由JSX创建，该元素可能是一个原生DOM组件的表示，如<code>&lt;div/&gt;</code>，或者是一个自定义的合成组件。</p>
</li>
<li>
<p><strong>字符串或数字</strong>：这些将被渲染为DOM中的Text Node</p>
</li>
<li>
<p><strong><a href="https://segmentfault.com/a/1190000012325351">Portals</a></strong>：由<strong>ReactDOM.createPortal</strong>创建，可以将React子节点的DOM结构，渲染到React父节点之外的DOM中， portal 也一直存在于React 树上，无论它位于 DOM 树中的什么位置。</p>
<pre><code class="language-react">ReactDOM.createPortal(child, container)
</code></pre>
</li>
<li>
<p><strong>null</strong>：什么都不渲染</p>
</li>
<li>
<p><strong>布尔值</strong>：什么都不渲染，（通常存在于<code>return test &amp;&amp; &lt;child /&gt;</code>写法，其中<code>test</code>是布尔值。</p>
<p>当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong><code>componentWillMount</code></strong>：紧贴着自己组件的<code>render</code>函数之前被调用</p>
</li>
<li>
<p><strong><code>componentDidMount</code></strong>：不是紧跟着<code>render</code>之后调用，当所有的组件都调用完了，所有组件的<code>componentDidMount</code>才会一起被调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个<strong>适合实现网络请求的地方</strong>。在该方法里设置状态将<strong>会触发重渲</strong>。</p>
<blockquote>
<p>原因：<code>render</code>函数本身并不往DOM树上渲染或者装载内容，它只是返回一个<font color='blue'><code>JSX表示的对象</code></font>，然后由React库来根据返回对象决定如何渲染</p>
</blockquote>
</li>
</ul>
<h3 id="jsx">JSX</h3>
<ul>
<li>
<p>和原生HTML定义事件的唯一区别就是<code>JSX</code>采用<strong>驼峰</strong>写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，<strong>返回一个事件处理函数</strong>。React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在<strong>根节点document</strong>上为每种事件添加唯一的Listener，然后通过事件的<strong>target找到真实的触发元素</strong>。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React<strong>模拟事件系统</strong>。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。</p>
</li>
<li>
<p>在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，<strong>属性值不能是字符串而必须为对象</strong>。</p>
<pre><code class="language-jsx">&lt;div style={{color: '#ff0000', fontSize: 14}}&gt;Hello World.&lt;/div&gt;

{/*或者（注释要这么写）*/}  

var style = {
  color: '#ff0000',
  fontSize: 14
};

var node = &lt;div style={style}&gt;HelloWorld.&lt;/div&gt;;
</code></pre>
</li>
</ul>
<blockquote>
<p>**注意：**原生HTML元素名以小写字母开头，而自定义的React类名以<font color='red'><strong>大写字母</strong></font>开头，比如HelloMessage不能写成helloMessage，除此之外还需要注意组件类只能包含<font color='red'><strong>一个顶层标签</strong></font>，否则也会报错。</p>
</blockquote>
<h3 id="受控组件">受控组件</h3>
<h4 id="input标签">input标签</h4>
<ul>
<li>在React中，<code>&lt;input&gt;</code>会用<strong>value属性</strong>来代替子节点，value属性的值总是和文本输入框的最新内容一致，如果想要指定默认值，可以使用<strong>defaultValue属性</strong>。</li>
</ul>
<h4 id="textarea标签">textarea标签</h4>
<ul>
<li>在React中，<code>&lt;textarea&gt;</code>会用<strong>value属性</strong>来替代子节点。这样的话，表单中的<code>&lt;textarea&gt;</code>非常类似于使用单行输入的表单。</li>
</ul>
<h4 id="select标签">select标签</h4>
<ul>
<li>
<p>在React中，并不适用之前的<code>selected</code>属性，而是在根<code>select</code>标签上用<strong>value属性</strong>来表示选中的项。这在受控组件中更为方便。例如：</p>
<pre><code class="language-jsx">&lt;select value={this.state.value} onChange={this.handleChange}&gt;
    &lt;option value='grapefruit'&gt;Grapefruit&lt;/option&gt;
    &lt;option value='lime'&gt;Lime&lt;/option&gt;
    &lt;option value='coconut'&gt;Coconut&lt;/option&gt;
    &lt;option value='mango'&gt;Mango&lt;/option&gt;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>总结：</strong><code>&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;select&gt;</code>都十分类似——他们都通过传入一个<font color='red'><strong>value属性</strong></font>来实现对组件的控制。</p>
<h4 id="typescript中使用usedispatch">TypeScript中使用useDispatch</h4>
<pre><code class="language-javascript"> Promise.resolve(
    dispatch(
     	submitRegistryConfig(REGISTRY_DRAWER_STATEID, values, mode === &quot;edit&quot; ? &quot;PUT&quot; : &quot;POST&quot;)
 	)
 ).then(() =&gt; {
 	closeDrawer();
 	callback();
 });
</code></pre>
]]></content>
    </entry>
</feed>