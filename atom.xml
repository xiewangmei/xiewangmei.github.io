<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiewangmei.github.io</id>
    <title>Blog-wmxie</title>
    <updated>2020-10-15T01:55:42.771Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiewangmei.github.io"/>
    <link rel="self" href="https://xiewangmei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响~</subtitle>
    <logo>https://xiewangmei.github.io/images/avatar.png</logo>
    <icon>https://xiewangmei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blog-wmxie</rights>
    <entry>
        <title type="html"><![CDATA[如何绘制一个带飞线动效的旋转3D地球]]></title>
        <id>https://xiewangmei.github.io/post/3d-earth/</id>
        <link href="https://xiewangmei.github.io/post/3d-earth/">
        </link>
        <updated>2020-10-15T01:42:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="期望效果图">期望效果图</h2>
<p><img src="https://xiewangmei.github.io/post-images/1602726769537.gif" alt="期望效果" loading="lazy"><br>
从效果图中，我们提炼出几个需要实现的关键点：</p>
<ul>
<li>绘制一个立体地球</li>
<li>实现地球颜色渐变（左上角稍亮，右下角稍暗）</li>
<li>实现地球上的点，点的连线，连线上的飞点</li>
<li>实现地球自转</li>
<li>实现根据鼠标的移入移出切换地球的自动旋转</li>
<li>实现中国地图鼠标悬浮高亮效果</li>
<li>实现拖拽</li>
</ul>
<h2 id="确定地球的dom结构">确定地球的DOM结构</h2>
<p>我们按照<code>海洋→陆地→球面点→连线→飞点</code>这样的顺序来分层绘制地球，所以其DOM结构如下：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h2 id="绘制一个基础地球">绘制一个基础地球</h2>
<p>地球由<strong>海洋</strong>和<strong>陆地</strong>组成，我们在实现时也按照这两个部分分步绘制。</p>
<h3 id="绘制海洋">绘制海洋</h3>
<p>这部分最为简单，在画布中心绘制一个直径稍小于画布宽高的圆即可，为其填充蓝色</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<pre><code class="language-javascript">const oceanCanvas = document.getElementById(&quot;#oceanCanvas&quot;);
const { width, height } = oceanCanvas;
const cx = width/2;
const cy = height/2;
const oceanCanvasContext = oceanCanvas.getContext(&quot;2d&quot;);
const oceanRadius = Math.min(width, height) * 0.8;
oceanCanvasContext.fillStyle = &quot;blue&quot;;
oceanCanvasContext.arc(cx, cy, oceanRadius, 0, Math.PI);
oceanCanvasContext.fill();
</code></pre>
<h3 id="绘制陆地">绘制陆地</h3>
<p>准备好一份标准的<code>worldmap.json</code>，用作陆地数据。</p>
<p>我们在海洋画布上方罩一个同尺寸的画布，用于绘制陆地。</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;landCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>有了数据，怎么把数据转换成一个个图呢？这里我们引入<code>d3</code>库，它提供了一套完备的API可供绘制地图。</p>
<pre><code class="language-javascript">// 创建投影
const projection = d3.geoOrthographic().clipAngle(90).scale(oceanRadius).translate([cx, cy]).rotate([90, 0, 0]);
// 依据投影创建路径生成器
const path = d3.geoPath(projection);
landCanvasContext.fillStyle = &quot;skyblue&quot;;
landCanvasContext.strokeStyle = &quot;skyblue&quot;;
// 提取陆地数据中的features
const features = worldmap.features;
features.forEach(f =&gt; {
    landCanvasContext.beginPath();
    path.context(landCanvasContext)(f);
    landCanvasContext.closePath();
    landCanvasContext.stroke();
    landCanvasContext.fill();
});
</code></pre>
<p>到这一步，我们应该能画出一个静止的地球了。</p>
<h2 id="实现地球的颜色渐变">实现地球的颜色渐变</h2>
<p>由于陆地是由成百上千个路径组成，对其填充色做渐变处理会十分麻烦。而由于海洋是一个简单圆形，实现渐变会相对简单，故我们将渐变色填充给海洋，陆地则填充一个带有透明度的色值，这样效果能比较接近。</p>
<pre><code class="language-javascript">const highlightCenterX = cx - oceanRadius/2;
const highlightCenterY = cy - oceanRadius/2;
const grd = context.createRadialGradient(highlightCenterX, highlightCenterY, r/8, highlightCenterX, highlightCenterY, 1.25 * oceanRadius);
grd.addColorStop(0, &quot;#0d4484&quot;);
grd.addColorStop(1, &quot;#041e3c&quot;);
context.fillStyle = grd;
context.arc(cx, cy, r, 0, Math.PI);
context.fill();
...
landCanvasContext.fillStyle = &quot;rgba(0, 80, 192, 0.4)&quot;;// 陆地修改为带透明度的色值
...
</code></pre>
<p>到这一步，地球已经加上了渐变效果。</p>
<h2 id="绘制球面上的点">绘制球面上的点</h2>
<p>球面上的点实际上是一个个的经纬度坐标，而要将这些经纬度坐标转成屏幕坐标仍旧需要借助<code>d3</code>的API</p>
<pre><code class="language-javascript">const geoPath = d3.geoPath(projection);// 依据投影创建一个路径生成器
const enterFn = enter =&gt; {
    const g = enter.append(&quot;g&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;full&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;circle&quot;);
};
const updateFn = update =&gt; {
    update.each(function(d) {
        const circle = d3.geoCircle().center(d.geometry.coordinates);// 根据投影创建圆生成器
        const color = d.color;
        const g = d3.select(this);
        g.select(&quot;path.full&quot;).attr(&quot;fill&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(1.5)()));
        g.select(&quot;path.circle&quot;).attr(&quot;stroke&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(2)()));
    });
};
svg.selectAll(&quot;g&quot;).data(points).join(enterFn, updateFn);
</code></pre>
<p>到这一步，球面上的点绘制完成</p>
<h2 id="绘制点之间的连线">绘制点之间的连线</h2>
<p>绘制连线可以采用插值器的方式实现，具体可以参考<code>d3</code>官网的<a href="http://bl.ocks.org/dwtkns/4973620">例子</a>，但是我们要实现的效果跟官网有些许区别：官网示例中，当其中一个点转到地球背面时，整条线都不可见；而我们是尽可能多地展示连线可见部分。所以得另辟蹊径。</p>
<p><img src="https://xiewangmei.github.io/post-images/1602726832506.png" alt="地球连线示意图" loading="lazy"><br>
如上图所示，地球外层画了一系列圆圈，这些圆圈可以理解为地球外侧的一系列轨道，我们可以在轨道上取一系列的点，将这些点用短线段进行连接，最终形成一个完整的从起点到终点的连线。上图中的连线看起来不平滑，所以我们实际操作时可以<strong>适当减小轨道间距，增加轨道数，以增加平滑度</strong>。</p>
<p><strong>注：为何不采用二次贝塞尔曲线？二次贝塞尔曲线需要根据轨道上每个点的二维坐标计算控制点，随着地球的旋转，坐标一直在发生变化，控制点也会随之改变，这样绘制出的曲线就会有在地球表面&quot;拖动&quot;的效果</strong></p>
<h3 id="选取连线上的点">选取连线上的点</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602726866367.png" alt="地球连线示意图2" loading="lazy"></figure>
<p>任何两点之间的连线，我们都可以通过旋转地球达到上图所示的效果，所以我们简化问题，以此视角进行分析：</p>
<p>前面提到过，地球外层的一系列圆圈可以理解为轨道，那么这些轨道上的点一定可以投影到地球表面，找到对应的地理坐标。反之，我们找到这些地球表面上的点，就能根据轨道投影找到轨道上对应位置的点。观察上图中点与点之间间距变化发现：左右对称，并且从起点到最外层轨道间距是逐渐增大（貌似在暗示我们用<code>d3.scalePow()</code>）。</p>
<p>我们目前的已知项只有起终点坐标，而借助<code>d3.geoInterpolate(start, end)(ratio)</code>可以得出<strong>两点间指定比例(ratio：0~1)的点的经纬度坐标</strong>，有了这一系列的经纬度坐标，投影上的位置相应也能够得出。所以，问题又简化成如何计算出**类似[ 0, 0.0625, 0.125, 0.25, 0.5, 0.75, 0.875, 0.7375, 1 ]**的<code>ratios数组</code>。</p>
<p>前面我们讲到，连线左右对称，且左半部分间距逐渐增大，可以用<code>d3.scalePow()</code>来实现：</p>
<pre><code class="language-javascript">// size：轨道数量(地球表面算第0个轨道)
// 计算左半边弧线的比率
const calcRatios = size =&gt; {
  const scale = d3
    .scalePow()
    .exponent(2)
    .domain([0, size - 1])
    .range([0, 0.5]);
  let i = 0;
  const result = [];
  while (i &lt; size) result.push(scale(i++));
  // 拼接出弧线上的所有比率
  return [
    ...result,
    ...result
      .slice(0, result.length - 1)
      .map(v =&gt; 1 - v)
      .reverse()
  ];
};
</code></pre>
<p>现在有了<code>ratios数组</code>，再通过公式<code>d3.geoInterpolate(start, end)(ratio)</code>可以计算出对应比例的经纬度坐标，有了经纬度坐标，就能通过各自对应的投影得到这些点在屏幕上的位置：</p>
<pre><code class="language-javascript">// 此处略过创建projections的代码
const ratios = calcRatios(projections.length);
const interpolate = d3.geoInterpolate(start, end);
const infos = ratios.map((ratio, i) =&gt; {
    const geoLocation = interpolate(ratio);
    const projection = 
          i &lt; projections.length 
          ? projection[i] 
          : projections[(projections.length - 1) * 2 - i];
    const screenLocation = projection(geoLocation);
    // 这里返回了比例、经纬度、投影、屏幕坐标,备用
    return { ratio, geoLocation, projection, screenLocation };
});
</code></pre>
<p>前文中为了方便讲解投影，比例等概念，将地球旋转到了一个完美角度，这个时候线上所有点均可见。但在地球不断旋转的过程中，经常会有线的一段甚至整段处于地球背面的情况，所以需要对这些点进行过滤处理：</p>
<ul>
<li>起终点均可见——不过滤</li>
<li>起点可见终点不可见——找到最后一个可见的点</li>
<li>起点不可见终点可见——找到第一个可见的点</li>
</ul>
<p>我们以可视半球的正投影中心（圆心）为参考点，可视半球上的任意一点到参考点的弧度差范围在<code>0 ~ π/2</code>之间，不可视半球上的点到参考点的弧度差在<code>π/2 ~ π</code>之间，<code>d3.geoDistance(coordinate1, coordinate2)</code>可用来计算球面上两个经纬度之间的弧度差，根据差值即可判定出该点是落在可视半球还是非可视半球上。</p>
<pre><code class="language-javascript">const { start, end } = link;// 假定link是众多线中的其中一条的数据
const center = projections[0].invert([w/2, h/2]);// 得到正投影圆心的经纬度
const distBetweenStartCenter = d3.geoDistance(center, start);
const distBetweenEndCenter = d3.geoDistance(center, end);
if(distBetweenStartCenter &gt;= 1.57 &amp;&amp; distBetweenEndCenter &gt;= 1.57) {
   return [];
}else {
    if(distBetweenStartCenter &gt;= 1.57) {// 起点不可见
       const firstVisiblePointIndex = infos.findIndex(
           info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
           1.57 + Math.acos(projections[0].scale() / info.projection.scale())
       );
       return infos.slice(firstVisible);
    } else if(distBetweenEndCenter &gt;= 1.57) { // 终点不可见
       const lastVisiblePointIndex = [...infos]
           .reverse()
           .findIndex(
               info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
               1.57 + Math.acos(projections[0].scale() / info.projection.scale())
           );
        return infos.slice(0, infos.length - lastVisiblePointIndex);
    } else {// 起终点均可见
        return infos;
    }
}
</code></pre>
<h3 id="以点成线">以点成线</h3>
<p>到这里，我们就能够循环遍历infos绘制出所有连线了。不过在此之前，我们需要将上一步最后的代码包到函数里方便调用：</p>
<pre><code class="language-javascript">const calcLinkPoints = (start, end, projection, w, h) =&gt; {
    // 计算infos
    return infos;
};
</code></pre>
<p>画线：</p>
<pre><code class="language-javascript">linkCanvasContext.lineWidth = 0.5;
linkCanvasContext.strokeStyle = &quot;rgba(146, 191, 243, 0.8)&quot;;
links.forEach(data =&gt; {
    data.points = calcLinkPoints(data.source, data.target, projections, width, height);
    if(data.points.length) {
        d3.line().context(linkCanvasContext)(
            data.points.map(info =&gt; info.screenLocation)
        );
    }
});
</code></pre>
<h2 id="绘制线上的飞点">绘制线上的飞点</h2>
<p>我们看到的线上的飞点是由一个个圆心连续，半径逐渐变小且颜色逐渐变淡的圆组合而成。<br>
<img src="https://xiewangmei.github.io/post-images/1602726899299.png" alt="地球连线示意图3" loading="lazy"></p>
<p>点与点之间的位置及比例关系：<br>
<img src="https://xiewangmei.github.io/post-images/1602726916062.png" alt="地球连线示意图4" loading="lazy"></p>
<pre><code class="language-javascript">const getRadius = d3
  .scaleLinear()
  .domain([0, 30])
  .range([1.5, 0]);
const colorInterpolate = d3.interpolate([&quot;#FFFFFF&quot;, &quot;#92BFF3&quot;]);
const scaleColor = d3
  .scaleLinear()
  .domain([0,30])
  .range([0,1]);
const getGradientCircleRadiusAndFill = index =&gt; ({
  r: getRadius(index),
  fill: getColor(index)
});

const drawFlyPoint = (context, links) =&gt; {
    links.forEach(data =&gt; {
        // curRatio:飞点当前位置占线总长的百分比
        const curRatio = data.ratio;
        // 找到第一个比飞点当前位置大的百分比(轨道上的比率)
        const firstBiggerIndex = data.points.findIndex(p =&gt; p.ratio &gt; curRatio);
        if(firstBiggerIndex &lt;= 0) {
        } else {
            const p1 = data.points[firstBiggerIndex - 1];
            const p3 = data.points[firstBiggerIndex];
            const r = (curRatio - p1.ratio) / (p3.ratio - p1.ratio);
            const p2X = 
                  p1.screenLocation[0] + 
                  r * (p3.screenLocation[0] - p1.screenLocation[0]);
            const p2Y = 
                  p1.screenLocation[1] + 
                  r * (p3.screenLocation[1] - p1.screenLocation[1]);
            const points = [
                [p2X, p2Y],
                ...data.points
                  .slice(0, firstBiggerIndex)
                  .reverse()
                  .map(p =&gt; p.screenLocation)
            ];
            
            const centers = getCirclesCenter(points);
            centers.forEach((c, index) =&gt; {
                const { r, fill } = getGradientCircleRadiusAndFill(index);
                context.fillStyle = fill;
                context.beginPath();
                context.arc(c[0], c[1], r, 0, Math.PI * 2);
                context.closePath();
                context.fill();
            });
        }
    });
};
</code></pre>
<p>这样我们就能根据每次的数据绘制出对应位置的飞点</p>
<h2 id="实现地球自转">实现地球自转</h2>
<p>地球自转实际上对应的是各个投影轨道的角度翻转(rotate)，所以比较简单：</p>
<pre><code class="language-javascript">const rotate = rotation =&gt; projections.forEach(p =&gt; p.rotate(rotation));
const animate = () =&gt; {
  links.forEach(l =&gt; {
    l.ratio = l.stepRatio + l.ratio;
    if(l.ratio &gt;= 1) l.ratio = 0;//飞点到达终点后重新开始飞点
  });
  if(autoRotate) {
    rotate(peojections[0].rotate().map((v, i) =&gt; (i === 0 ? v + 0.2 :v)));
  }
  ...
  //重新绘制地球以及点、线等
  ...
  window.requestAnimationFrame(animate);
};
</code></pre>
<h2 id="实现鼠标移入停转移出开转">实现鼠标移入停转移出开转</h2>
<p>注意到地球自转代码里有一个标志位<code>autoRotate</code>，用来决定球体是否自动旋转，那只需要对<code>mousemove</code>做个监听就行了：</p>
<pre><code class="language-javascript">d3.select(document.body)
  .on(
    &quot;mousemove&quot;,
    () =&gt; 
      (autoRotate = 
        getDistance(
          [d3.event.clientX, d3.event.clientY],
          [width / 2, height / 2]
        ) &gt; earthRadius)
  );
</code></pre>
<h2 id="实现中国地图悬浮高亮效果">实现中国地图悬浮高亮效果</h2>
<p>在前面绘制陆地部分，我们已经将所有的国家都绘制在canvas上，而在canvas上做交互会比较麻烦，所以我们将中国数据单独提取出来，绘制到svg上，这样可以对中国版图添加hover样式。</p>
<p>修改dom结构：</p>
<pre><code class="language-jsx">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;chinaSvg&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p>单独绘制中国地图部分:</p>
<pre><code class="language-javascript">const chinaFeature = features.filter(isInChina);
d3.select(chinaSvg)
  .selectAll(&quot;g.land&quot;)
  .data(chinaFeature)
  .join(
    enter =&gt;
      enter
        .append(&quot;g&quot;)
        .classed(&quot;china&quot;, true)
        .append(&quot;path&quot;)
        .attr(&quot;fill&quot;, &quot;skyblue&quot;)
        .attr(&quot;stroke&quot;, &quot;skyblue&quot;),
      update =&gt; update.select(&quot;path&quot;).attr(&quot;d&quot;, d3.geoPath(projections[0]))
  );
</code></pre>
<p>CSS：</p>
<pre><code class="language-scss">.china:hover path {
    fill: rgba(255, 200, 0, 0.8)
}
</code></pre>
<h2 id="实现拖拽">实现拖拽</h2>
<p>拖拽也是添加监听即可</p>
<pre><code class="language-javascript">const addRotateListeners = (selection, projection, rotateHander) =&gt; {
  let m0, o0;
  const body = d3.select(document.body);

  const startDrag = () =&gt; {
    m0 = [d3.event.pageX, d3.event.pageY];
    o0 = projection.rotate();
    body.on(&quot;mousemove.forRotate&quot;, drag);
    body.on(&quot;mouseup.forRotate&quot;, stopDrag);
  };
  const drag = () =&gt; {
    const m1 = [d3.event.pageX, d3.event.pageY];
    const o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
    o1[1] = o1[1] &gt; 30 ? 30 : o1[1] &lt; -30 ? -30 : o1[1];
    rotateHander(o1);
  };
  const stopDrag = () =&gt; {
    body.on(&quot;mousemove.forRotate&quot;, null);
    body.on(&quot;mouseup.forRotate&quot;, null);
  };

  selection.on(&quot;mousedown&quot;, startDrag);
};
addRotateListeners(pointSvg, projections[0], rotate);
</code></pre>
<h2 id="小结">小结</h2>
<p>至此，效果图我们已经实现完成，功能点较多，依赖于<code>d3</code>库的<code>projection</code>，还掺杂有一些数学几何知识，需要花一些时间去思考。后续可以将其封装成<code>React</code>组件或者<code>Vue</code>组件，以备不时之需</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Diff]]></title>
        <id>https://xiewangmei.github.io/post/react-diff/</id>
        <link href="https://xiewangmei.github.io/post/react-diff/">
        </link>
        <updated>2020-09-29T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="虚拟dom">虚拟DOM</h2>
<p>虚拟DOM是和真实DOM相对应的。真实DOM也就是平时我们所说的DOM，它是对结构化文本的抽象表达。在web环境中，其实就是对HTML文本的一种抽象表述，每一个HTML元素对应一个DOM节点，HTML元素的层级关系也会体现在DOM节点的层级上，所有的这些DOM节点构成一棵DOM树。</p>
<p>在传统前端开发中，通过浏览器提供的一组API直接对DOM执行增删改查操作，例如<code>getElementById</code>，<code>insertBefore</code>等。这些操作看似只执行一条<code>JavaScript</code>语句，但它们的执行效率要比执行一条普通的<code>JavaScript</code>语句慢得多，尤其是对DOM进行增删改操作，每一次对DOM的修改都会引起浏览器对页面的重新布局和重新渲染，这个过程是很耗时的。所以前端性能优化里面有一条原则：<strong>尽量减少DOM操作</strong>。</p>
<p>既然直接操作DOM效率低下，那么有什么办法可以解决这个问题呢？在软件开发中，有这么一句话，<strong>软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决</strong>。DOM效率低下的这个问题同样可以通过增加一层抽象解决，<code>虚拟DOM</code>就是对真实DOM的抽象。这里需要注意，虚拟DOM并非React独有，它是一个独立的技术，只不过React使用了这项技术来提高自身的性能。</p>
<p>虚拟DOM使用<code>普通的JavaScript对象</code>来描述DOM元素，对象的结构和<code>React.CreateElement()</code>参数类似。例如，我们有下面这样的一个DOM结构：</p>
<pre><code class="language-html">&lt;div class = 'foo'&gt;
    &lt;h1&gt;
        Hello React
    &lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>相对应的虚拟DOM就可以用下面这样的对象来描述：</p>
<pre><code class="language-javascript">const virtualDom = {
    type: 'div',
    props: {
        className: 'foo',
        children: [{
            type: 'h1',
            props: {
                children: ['Hello React']    
            }
        }]    
    },
    
};
</code></pre>
<p>有了虚拟DOM这层抽象，当我们需要操作真实DOM时，就可以操作虚拟DOM这个<code>JavaScript对象</code>，速度当然要比操作真实DOM快得多。</p>
<h2 id="diff算法">Diff算法</h2>
<p>React采用声明式的API描述UI结构(JSX)，每次组件的状态或属性更新，组件的<code>render</code>方法都会返回一个新的虚拟DOM对象用来描述新的UI结构。如果每次都直接使用新的虚拟DOM结构来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响程序执行效率。事实上，React会通过比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高执行效率。这一过程就是React的调和过程<code>(Reconciliation)</code>，其中的关键就是<code>diff算法</code>。</p>
<h3 id="react-diff算法的三大策略">React-diff算法的三大策略</h3>
<h4 id="1-tree-diff-web-ui中dom节点跨层级的移动操作特别少可以忽略不计"><strong>1. Tree Diff —— Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计</strong></h4>
<p>React把树按照层级分解，在对新旧虚拟DOM进行比较时，只会对同层进行比较（节点类型，属性）。这是React-diff算法的关键点（<strong>因为组件是树形结构，需要基于该策略做diff</strong>）。</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358709820.png" alt="同层比较" loading="lazy"></figure>
<p>如图所示，React只会相互比较相同颜色框内的节点，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。由此一来，最直接的提升就是复杂度变为线型增长而不是原先的指数增长。</p>
<p>前面我们提到了同层比较，那当我们的节点发生跨层级移动，diff算法会是什么表现呢？</p>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1601358737506.png" alt="跨层级操作" loading="lazy"></figure>
<p>B节点连同它的子节点一起移动到A节点之下，直观的考虑DOM Diff应该是</p>
<pre><code class="language-jsx">R.remove(B); 
A.append(B);
</code></pre>
<p>但是，实际上<code>React</code>只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有<code>创建</code>和<code>删除</code>操作，所以当根节点发现B节点消失了，就会删除B节点及其子节点，当A发现多了一个子节点B，就会创建新的B作为其子节点，这样DOM Diff就变成：</p>
<pre><code class="language-javascript">B.destroy();
C = new C();
D = new D();
B = new B();
B.append(C);
B.append(D);
A.append(B);
</code></pre>
<p>换句话说，这里进行了较多的DOM操作，因此，我们在开发组件时，尽量保持DOM结构稳定是一种不错的选择。</p>
<h4 id="2-componnet-diff-相同类型的组件会生成相似的树形结构不同类型的两个组件将会生成不同的树形结构"><strong>2. Componnet Diff —— 相同类型的组件会生成相似的树形结构，不同类型的两个组件将会生成不同的树形结构</strong></h4>
<ul>
<li>
<p><strong>同类型组件</strong>：按照前面所说的<code>Tree Diff策略</code>继续比较虚拟DOM。需要注意的是，在这种情况下，如果用户能确定新旧虚拟DOM之间没有任何变化，React给了我们一个<code>shouldComponentUpdate()</code>方法，通过设置返回值<code>true</code>和<code>false</code>可以决定组件是否进行diff操作，用得好的话， 可以节省大量的 diff 运算时间。</p>
</li>
<li>
<p><strong>不同类型组件</strong>：该组件判定为<code>dirty componnet</code>，替换掉整个组件包括其子节点</p>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 的这种直接删除再重新创建的机制会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://xiewangmei.github.io/post-images/1601358776690.png" alt="相似组件" loading="lazy"></figure>
<h4 id="3-对于同一层级的一组兄弟节点可以通过唯一的key值来进行区分"><strong>3. 对于同一层级的一组兄弟节点，可以通过唯一的Key值来进行区分</strong></h4>
<p>当一个节点有多个子节点时，默认情况下，React只会按照顺序逐一比较两棵树上的对应子节点，一旦新旧虚拟DOM相同位置的节点对应不上，就会进行修改操作。</p>
<p>乍一看貌似没什么问题？看个栗子：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
    &lt;li&gt;javascript&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这里我们在列表最后添加一个<code>javascript</code>，对比的时候,<code>php</code>，<code>java</code>都能匹配上，然后在最后新增<code>javascript</code>，一切顺利。那我们把<code>javascript</code>加到列表首项，像这样：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li&gt;javascript&lt;/li&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这时候的结果就是：<code>php</code>更新为<code>javascript</code>，<code>java</code>更新为<code>php</code>，最后新增<code>java</code>项，<strong>每一个节点</strong>都发生了修改。</p>
<p>为了解决这种低效的更新方式，React提供了一个Key属性，用来匹配新旧虚拟DOM的子节点，在每次渲染之后，只要子节点的Key值没有变化，React就会认为这是同一个节点。上面的例子我们这样改：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li key='javascript'&gt;javascript&lt;/li&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这样React就能判断出<code>&lt;li key='javascript'&gt;javascript&lt;/li&gt;</code>节点是新增节点，其他两个节点没有发生变化，最终只需要进行一次新增节点操作即可。</p>
<p><strong>注意</strong>：有时候我们会通过数组的map方法将每个数组成员映射到一个列表元素，这里应该尽量避免用数组的index来作为Key值。因为数组中的成员顺序一旦发生改变，可能会导致大量的Key值失效，进而引起大量的修改操作。</p>
<p>避免这种写法：</p>
<pre><code class="language-jsx">&lt;ul&gt;
    (list.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;))
&lt;/ul&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>1.开发组件时，尽量保持DOM结构的稳定，有助于提升性能。例如，可以通过设置样式来控制元素的显示隐藏，而不是真正移除或添加DOM节点。</p>
<p>2.用好<code>shouldComponentUpdate()</code>方法，减少不必要的diff计算。</p>
<p>3.在一组兄弟节点中，设置合适的Key值来帮助React识别相同节点，减少不必要的DOM操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React小知识]]></title>
        <id>https://xiewangmei.github.io/post/react-knowledge/</id>
        <link href="https://xiewangmei.github.io/post/react-knowledge/">
        </link>
        <updated>2020-09-29T05:47:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react的程序流程">React的程序流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358552129.png" alt="React程序流程" loading="lazy"></figure>
<ul>
<li>在React中无论发生何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心。</li>
</ul>
<h3 id="virtual-dom">Virtual DOM</h3>
<ul>
<li>
<p>既然DOM树是对HTML的抽象，那<code>Virtual DOM</code>就是对DOM的抽象。<code>Virtual DOM</code>不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的<code>Virtual DOM</code>和上一次渲染的<code>Virtual DOM</code>，对比就会发现差别，然后修改真正的DOM树时就只要触及差别中的部分就行了。</p>
<ul>
<li>
<p>以ClickCouter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这次重新渲染，React通过<code>Virtual DOM</code>的对比发现其实只是id为clickCount的span元素中内容从0变成了1而已：</p>
<pre><code class="language-javascript">&lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;
</code></pre>
<p>React发现这次渲染要做的事情只是更换这个span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句就可以完成任务了：</p>
<pre><code class="language-javascript">document.getElementById(&quot;clickCount&quot;).innerHTML = &quot;1&quot;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="prop和state的对比">prop和state的对比</h3>
<ul>
<li><code>prop</code>用于定义外部接口，<code>state</code>用于记录内部状态</li>
<li><code>prop</code>的赋值在外部世界使用组件时，<code>state</code>的赋值在组件内部</li>
<li>组件不应该改变<code>prop</code>的值，而<code>state</code>存在的目的就是让组件来改变的</li>
</ul>
<h3 id="refrefs">ref&amp;refs</h3>
<ul>
<li>
<p><code>React</code>支持一种非常特殊的属性<font color='red'><code>ref</code></font>，可以用来绑定到render()输出的任何组件上</p>
<ul>
<li><code>ref</code>：绑定属性</li>
<li><code>refs</code>：调用的时候使用</li>
</ul>
</li>
<li>
<p>通过<code>refs</code>访问父组件方法</p>
<pre><code class="language-jsx">this.refs.subcomponents.subHandleClick();
</code></pre>
</li>
<li>
<p>为了获取真实DOM节点，html元素必须有一个<code>ref属性</code>，然后**<code>this.refs.[refName]</code>**就会返回这个真实的DOM节点。</p>
<blockquote>
<p><strong>注意</strong>：由于**this.refs.[refName]**属性获取的是真实DOM，所以必须等到虚拟DOM插入文档后，才能使用这个属性，否则获取不到。</p>
</blockquote>
</li>
</ul>
<h3 id="组件生命周期">组件生命周期</h3>
<ul>
<li>
<p><strong><code>constructor</code></strong>：构造函数是初始化状态的合适位置。若不初始化状态且不绑定方法，那就不需要为React组件定义一个构造函数。</p>
</li>
<li>
<p><strong><code>render</code></strong>：该方法是必须的，当被调用时，其应该检查<code>this.props</code>和<code>this.state</code>，并返回以下类型中的一个：</p>
<ul>
<li>
<p><strong>React元素</strong>：通常由JSX创建，该元素可能是一个原生DOM组件的表示，如<code>&lt;div/&gt;</code>，或者是一个自定义的合成组件。</p>
</li>
<li>
<p><strong>字符串或数字</strong>：这些将被渲染为DOM中的Text Node</p>
</li>
<li>
<p><strong><a href="https://segmentfault.com/a/1190000012325351">Portals</a></strong>：由<strong>ReactDOM.createPortal</strong>创建，可以将React子节点的DOM结构，渲染到React父节点之外的DOM中， portal 也一直存在于React 树上，无论它位于 DOM 树中的什么位置。</p>
<pre><code class="language-react">ReactDOM.createPortal(child, container)
</code></pre>
</li>
<li>
<p><strong>null</strong>：什么都不渲染</p>
</li>
<li>
<p><strong>布尔值</strong>：什么都不渲染，（通常存在于<code>return test &amp;&amp; &lt;child /&gt;</code>写法，其中<code>test</code>是布尔值。</p>
<p>当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong><code>componentWillMount</code></strong>：紧贴着自己组件的<code>render</code>函数之前被调用</p>
</li>
<li>
<p><strong><code>componentDidMount</code></strong>：不是紧跟着<code>render</code>之后调用，当所有的组件都调用完了，所有组件的<code>componentDidMount</code>才会一起被调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个<strong>适合实现网络请求的地方</strong>。在该方法里设置状态将<strong>会触发重渲</strong>。</p>
<blockquote>
<p>原因：<code>render</code>函数本身并不往DOM树上渲染或者装载内容，它只是返回一个<font color='blue'><code>JSX表示的对象</code></font>，然后由React库来根据返回对象决定如何渲染</p>
</blockquote>
</li>
</ul>
<h3 id="jsx">JSX</h3>
<ul>
<li>
<p>和原生HTML定义事件的唯一区别就是<code>JSX</code>采用<strong>驼峰</strong>写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，<strong>返回一个事件处理函数</strong>。React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在<strong>根节点document</strong>上为每种事件添加唯一的Listener，然后通过事件的<strong>target找到真实的触发元素</strong>。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React<strong>模拟事件系统</strong>。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。</p>
</li>
<li>
<p>在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，<strong>属性值不能是字符串而必须为对象</strong>。</p>
<pre><code class="language-jsx">&lt;div style={{color: '#ff0000', fontSize: 14}}&gt;Hello World.&lt;/div&gt;

{/*或者（注释要这么写）*/}  

var style = {
  color: '#ff0000',
  fontSize: 14
};

var node = &lt;div style={style}&gt;HelloWorld.&lt;/div&gt;;
</code></pre>
</li>
</ul>
<blockquote>
<p>**注意：**原生HTML元素名以小写字母开头，而自定义的React类名以<font color='red'><strong>大写字母</strong></font>开头，比如HelloMessage不能写成helloMessage，除此之外还需要注意组件类只能包含<font color='red'><strong>一个顶层标签</strong></font>，否则也会报错。</p>
</blockquote>
<h3 id="受控组件">受控组件</h3>
<h4 id="input标签">input标签</h4>
<ul>
<li>在React中，<code>&lt;input&gt;</code>会用<strong>value属性</strong>来代替子节点，value属性的值总是和文本输入框的最新内容一致，如果想要指定默认值，可以使用<strong>defaultValue属性</strong>。</li>
</ul>
<h4 id="textarea标签">textarea标签</h4>
<ul>
<li>在React中，<code>&lt;textarea&gt;</code>会用<strong>value属性</strong>来替代子节点。这样的话，表单中的<code>&lt;textarea&gt;</code>非常类似于使用单行输入的表单。</li>
</ul>
<h4 id="select标签">select标签</h4>
<ul>
<li>
<p>在React中，并不适用之前的<code>selected</code>属性，而是在根<code>select</code>标签上用<strong>value属性</strong>来表示选中的项。这在受控组件中更为方便。例如：</p>
<pre><code class="language-jsx">&lt;select value={this.state.value} onChange={this.handleChange}&gt;
    &lt;option value='grapefruit'&gt;Grapefruit&lt;/option&gt;
    &lt;option value='lime'&gt;Lime&lt;/option&gt;
    &lt;option value='coconut'&gt;Coconut&lt;/option&gt;
    &lt;option value='mango'&gt;Mango&lt;/option&gt;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>总结：</strong><code>&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;select&gt;</code>都十分类似——他们都通过传入一个<font color='red'><strong>value属性</strong></font>来实现对组件的控制。</p>
<h4 id="typescript中使用usedispatch">TypeScript中使用useDispatch</h4>
<pre><code class="language-javascript"> Promise.resolve(
    dispatch(
     	submitRegistryConfig(REGISTRY_DRAWER_STATEID, values, mode === &quot;edit&quot; ? &quot;PUT&quot; : &quot;POST&quot;)
 	)
 ).then(() =&gt; {
 	closeDrawer();
 	callback();
 });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React & Antd]]></title>
        <id>https://xiewangmei.github.io/post/react-and-antd/</id>
        <link href="https://xiewangmei.github.io/post/react-and-antd/">
        </link>
        <updated>2020-09-29T05:45:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>可以通过React.createContext中的Provider实现夸层级传递属性，避免繁琐的一层层传递</p>
<pre><code class="language-react">const { Provider } = React.createContext();
{......}
</code></pre>
</li>
<li>
<p>tab点击想要触发重新渲染，可以设置state里的数据发生变化，但是该state必须要使用，才会触发，不然就不会触发，可以将原本的对象返回一个新对象，比如</p>
<pre><code class="language-javascript">record={…record}
component: props =&gt; {
 return &lt;filterRoute.component {...props} /&gt;;
}
</code></pre>
</li>
<li>
<p>一行一个标签对应多个输入组件，这个需求很常见但在官方例子没看到合适的，因为官方建议：</p>
<blockquote>
<p>注意：一个 Form.Item 建议只放一个被 getFieldDecorator 装饰过的 child，当有多个被装饰过的 child 时，help required validateStatus 无法自动生成。</p>
</blockquote>
<p>所以可以通过在FormItem组件中再包一层FormItem，通过flex布局调整其布局，,这样校验的位置也是正确的，校验提示也能自动生成。</p>
<pre><code class="language-react">&lt;FormItem {...formItemLayout} label=&quot;IP地址段&quot;&gt;
     &lt;div style={{ display: &quot;flex&quot; }}&gt;
     	&lt;FormItem&gt;
        {getFieldDecorator(&quot;start&quot;, {
            rules: [{ required: true, message: &quot;该项为必填项&quot; }]
         })(
             &lt;Input style={{ width: 220 }}placeholder=&quot;请输入起始IP&quot;/&gt;
         )}
         &lt;/FormItem&gt;
		&lt;div className={styles[&quot;ip-range-div&quot;]}&gt;-&lt;/div&gt;
		&lt;FormItem&gt;
    	{getFieldDecorator(&quot;end&quot;, {
           	rules: [{ required: true, message: &quot;该项为必填项&quot; }]
   		 })(
        &lt;Input style={{ width: 220 }} placeholder=&quot;请输入结束IP&quot;/&gt;
        )}
        &lt;/FormItem&gt;
	&lt;/div&gt;
&lt;/FormItem&gt;
</code></pre>
</li>
<li>
<p>想要一个组件不被重新渲染，那么该组件的props都必须被校验为未修改才不会执行重渲染，函数执行返回的是一个新对象，比如说Drawer</p>
<pre><code class="language-React"> &lt;RegionManagerDrawer
     handleSubmitResult={this.handleSubmitResult}
     onClose={this.closeDrawer}
     // onClose={()=&gt;this.closeDrawer()}这种写法会触发重新渲染
     mode={mode}
     record={record}
     handleEdit={this.handleEdit}
 /&gt;
</code></pre>
<p>但是有一个问题：Modal 只要将destoryOnClose设置为true即可</p>
</li>
<li>
<p>antd的table控制是否展开，expandedRowKeys数组存放对应展开行的数据key，控制是否单独单元格放置展开图标<code>expandIconAsCell = {false}</code>，number设置展开图标所在的单元格索引，取一个不存在的索引可达到去掉预设图标的效果<code>expandIconColumnIndex = {-1}</code></p>
</li>
<li>
<p>table固定列的宽度，超出部分用<code>…</code>代替（针对普通table和antd）</p>
<ul>
<li>
<p>让溢出内容变成…，需要如下样式</p>
<pre><code class="language-css">overflow: hidden; //超出部分隐藏
text-overflow:ellipsis; //显示省略符来代表被修剪的文本
white-space: nowrap; //强制不换行
</code></pre>
<p>table的宽度我们并不能控制，内容会自动撑大表格列表宽度，需要给<code>table</code>加上一个样式：</p>
<pre><code class="language-css">table-layout:fixed;
</code></pre>
</li>
</ul>
</li>
<li>
<p>经过 <code>getFieldDecorator</code> 包装的控件，表单控件会自动添加 <code>value</code>，switch这种实际值不是value什么的，在form表单中可能设置不上值，需要通过<code>valuePropName</code>指定子节点的值的属性，如 Switch 的是 'checked'</p>
</li>
<li>
<p>在form中如果已经设置了initialValue:value，避免在componentDidMount（useEffect）等生命周期函数中使用this.props.form.setFieldsValue，否则会产生<code>Warning: You cannot set a form field before rendering a field associated with the value</code>，单一使用即可</p>
</li>
<li>
<p>form item的validator中必须要返回callback().，否则<code>validateFields（validateFieldsAndScroll ）</code>方法不生效</p>
<pre><code class="language-react">handleConfirmPassword = (rule, value, callback) =&gt; {
        const { getFieldValue } = this.props.form
        if (value &amp;&amp; value !== getFieldValue('newPassword')) {
            callback('两次输入不一致！')
        }

        // Note: 必须总是返回一个 callback，否则 validateFieldsAndScroll 无法响应
        callback()
 }
</code></pre>
</li>
<li>
<p>setState支持回调，可以在render之前进行dom focus系列的操作，hooks中的setXXX不支持回调，转变为在useEffect中进行操作，同时监听XXXstate，即可实现同样的效果</p>
</li>
<li>
<p>通过setFieldsValue的属性设置值时，该元素必须是紧接着FormItem的，不然没法设置成功，不能嵌套div之类的其他元素</p>
</li>
<li>
<p>create-react-app 报错 babel插件与实际安装的present-env版本不一致，是因为代理的问题，尝试去掉<code>用户\wmxie</code>下面的<code>.npmrc</code>文件，再重新执行，若不报错，则是代理的问题，尝试替换代理或不使用代理</p>
</li>
<li>
<p>Icon可以设置rotate来控制图标旋转的角度   <code>transform: rotate(45deg);</code></p>
</li>
<li>
<p>JavaScript之forEach循环遍历方法用于调用数组的每个元素，并将元素传递给回调数组，<code>forEach</code>是Array下的一个方法。</p>
<blockquote>
<p>注意：无法使用break等语句跳出遍历，直到所有元素都传递给调用的函数，但是可以抛出异常，提前终止循环。类似的还有map</p>
</blockquote>
</li>
<li>
<p>react-redux升级之后基本都变成了function组件，比如connect由class组件变成了function组件，需要传递ref</p>
<pre><code class="language-javascript">1. 组件是class，使用connect进行包裹
	connect(mapStateToProps,mapDispatchToProps,null,{forwardRef:true})
2. 组件是function，未使用connect
	 (1).使用forwardRef包裹组件
3. 组件是function，同时使用connect进行包裹
	 (1).使用forwardRef包裹function组件，同时connect中需要按照情况1的写法写
     (2).使用forwardRef包裹组件，使用useSelector，useDispatch，不使用connect
</code></pre>
</li>
<li>
<p>antd的FormItem在创建的时候会给组件传递ref，所以就会有15中的问题存在，需按照15中的方法执行</p>
</li>
<li>
<p>ref={ref} 这种形式 括号里的ref是React.createRef出来的 最终会被放到ref.current里</p>
<p>ref={function} 这种形式 不需要React.createRef</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native]]></title>
        <id>https://xiewangmei.github.io/post/react-native/</id>
        <link href="https://xiewangmei.github.io/post/react-native/">
        </link>
        <updated>2020-09-29T05:29:57.000Z</updated>
        <content type="html"><![CDATA[<center><h2>React Native</h2></center>
<h3 id="developer-menu">Developer Menu</h3>
<p>Andriod模拟器：可以通过Ctrl+M快键键快速打开</p>
<p>IOS模拟器：可以通过Ctrl+D快捷键快速打开</p>
<h3 id="flatlist">FlatList</h3>
<ul>
<li>FlatList会安排视图的渲染，只显示当前在屏幕上的那些元素。而那些已经渲染好了的但移动到了屏幕之外的元素，则会从原生视图结构中移除（以提高性能）</li>
</ul>
<h3 id="platform模块">Platform模块</h3>
<ul>
<li>
<p>Platform.OS上会返回<code>ios</code>，而在Android设备或模拟器上则会返回<code>android</code></p>
</li>
<li>
<p>有个实用的方法是Platform.select()，它可以以Platform.OS为key，从传入的对象中返回对应平台的值</p>
<pre><code class="language-react">import { Platform, StyleSheet } from &quot;react-native&quot;;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: &quot;red&quot;
      },
      android: {
        backgroundColor: &quot;blue&quot;
      }
    })
  }
});
</code></pre>
<p>该方法可以接受任何合法类型的参数，也可以直接用它针对不同平台返回不同的组件，</p>
<pre><code class="language-react">const Component = Platform.select({
	ios: () =&gt; require(&quot;ComponentIOS&quot;),
	android: () =&gt; require(&quot;CompnentAndroid&quot;)
})();
&lt;Component/&gt;
</code></pre>
</li>
<li>
<p>检测Android版本，在Android上，<code>Version</code>属性是一个数字，表示Android的api level：</p>
<pre><code class="language-react">import {Platform} from 'react-native';
if(Platform.Version === 25){
	console.log(&quot;Running on Nougat&quot;);
}
</code></pre>
</li>
<li>
<p>检测iOS版本，在iOS上<code>Version</code>属性是<code>-[UIDevice systemVersion]</code>的返回值，具体形式为一个表示当前系统版本的字符串，比如可能是“10.3”</p>
<pre><code class="language-react">import { Platform } from &quot;react-native&quot;;
const majorVersionIOS = parseInt(Platform.Version, 10);
if(majorVersionIOS &lt;= 9) {
	console.log(&quot;Work around a change in behavior&quot;);
}
</code></pre>
</li>
</ul>
<h3 id="特定平台扩展名">特定平台扩展名</h3>
<ul>
<li>
<p>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native会检测某个文件是否具有<code>.ios.</code>或.<code>android.</code>的扩展名，然后根据当前运行的平台自动加载正确对应的文件。比如可以创建这种组件，然后去掉平台扩展名直接引用：</p>
<pre><code class="language-javascript">BigButton.ios.js
BigButton.android.js

import BigButton from './BigButton'
</code></pre>
<p>React Native会根据运行平台的不同自动引入正确对应的组件。</p>
</li>
<li>
<p>如果希望在web端复用React Native的代码，那么还可以使用<code>.native.js</code>的扩展名。此时iOS和Android会使用<code>BigButton.native.js</code>文件，而web端会使用<code>BigButton.js</code></p>
</li>
</ul>
<h3 id="图片">图片</h3>
<h4 id="静态图片资源">静态图片资源</h4>
<ul>
<li>
<p>可以使用<code>@2x</code>，<code>@3x</code>这样的文件名后缀，来为不同的屏幕精度提供图片。比如说，iPhone7会使用check@2x.png，而iPhone 7 plus或是Nexus 5上则会使用check@3x.png。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片</p>
<p><em>注意：如果添加图片的时候packager正在运行，则可能需要重启packager以便能正确引入新添加的图片</em></p>
</li>
</ul>
<h3 id="textinput">TextInput</h3>
<ul>
<li>
<p>placeholderTextColor 设置占位文字字体颜色</p>
<pre><code class="language-jsx">&lt;TextInput placeholderTextColor=&quot;#a5a5a5&quot; /&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日积月累]]></title>
        <id>https://xiewangmei.github.io/post/日积月累/</id>
        <link href="https://xiewangmei.github.io/post/日积月累/">
        </link>
        <updated>2020-09-29T05:23:55.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>接口请求Status(blocked:other)，出现这种情况是被浏览器插件（如AdBlock插件）当广告拦截了</p>
</li>
<li>
<p>jquery 解决favicon.ico 404找不到的问题，可以在html头部添加&lt;link <em>rel</em>=&quot;shortcut icon&quot; <em>href</em>=&quot;#&quot;/&gt;</p>
</li>
<li>
<p>for..of ES6提供可以直接遍历值而不是数组下标</p>
<pre><code class="language-javascript">var myArray = [1,2,3];
for(var v of myArray){
    console.log(v);
}
//1
//2
//3
</code></pre>
<p>for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值</p>
</li>
<li>
<p>K8s kubelet &amp; kubeadm &amp; kubectl 介绍</p>
<ul>
<li>kubelet: 运行在cluster所有节点上，负责启动POD和容器</li>
<li>kubeadm: 用于初始化cluster</li>
<li>kubectl: kubenetes命令行工作，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</li>
</ul>
</li>
<li>
<p>npx create-react-app 报网络错误时，可以尝试将之前安装的npm create-react-app删掉（<code>npm uninstall -g create-react-app</code>），同时修改registry为淘宝镜像</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode常用快捷键]]></title>
        <id>https://xiewangmei.github.io/post/vscode/</id>
        <link href="https://xiewangmei.github.io/post/vscode/">
        </link>
        <updated>2020-09-29T03:33:22.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ctrl+Alt+I  插入作者注释</li>
<li>F1  打开命令面板</li>
<li>Ctrl+Shift+D 切换到调试视图</li>
<li>Ctrl+~ 打开终端调试窗口</li>
<li>F1 打开命令行</li>
</ul>
]]></content>
    </entry>
</feed>