<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiewangmei.github.io</id>
    <title>Blog-wmxie</title>
    <updated>2020-10-15T02:03:10.277Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiewangmei.github.io"/>
    <link rel="self" href="https://xiewangmei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响~</subtitle>
    <logo>https://xiewangmei.github.io/images/avatar.png</logo>
    <icon>https://xiewangmei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blog-wmxie</rights>
    <entry>
        <title type="html"><![CDATA[学会写正则]]></title>
        <id>https://xiewangmei.github.io/post/learn-regexp/</id>
        <link href="https://xiewangmei.github.io/post/learn-regexp/">
        </link>
        <updated>2020-10-15T02:01:44.000Z</updated>
        <content type="html"><![CDATA[<p>1.正则表达式<code>/\d{3}-\d{8}|\d{4}-\d{7,8}/</code>代表什么含义：</p>
<p>首先观察到表达式中有一个选择符<code>|</code>，而选择符的两边没有圆括号成对出现，那么可以推断出该表达式是匹配<code>\d{3}-\d{8}</code>或<code>\d{4}-\{7,8}</code>两种模式。</p>
<p>模式<code>\d{3}-\d{8}</code>：三位数字和八位数字，中间以<code>-</code>连接，例：010-88888888</p>
<p>模式<code>\d{4}-\d{7,8}</code>：四位数字和七(八)位数字，中间以<code>-</code>连接，例：0512-88888888</p>
<p>到现在应该可以看出，这个正则是匹配座机号码。</p>
<p>但是，中国的座机号是按一定的规律组成，上面的表达式不完全正确。例如：000-00000000 明显不是一个合法的座机号。<strong>思考如何改进</strong>？</p>
<p>2.正则表达式<code>/(?=.{8,31})(?=.*\d.*\d.*)(?=.*[a-z].*[a-z].*)(?=.*[A-Z].*[A-Z].*)(?=.*[^a-zA-Z0-9].*[^a-zA-Z0-9].*)/</code>代表什么含义（拷贝自智源项目）：</p>
<p>观察正则表达式的结构，发现其是由五个<code>先行断言</code>组成。<code>(?=正则)</code>表示在这个位置之后的字符串必须符合<code>?=</code>之后的正则。而我们知道先行断言有一个特点：不消耗字符串。那么也就是说在这之后的正则还是从同一位置开始匹配。</p>
<p><code>(?=.{8,31})</code>：字符串长度为 8-31</p>
<p><code>(?=.*\d.*\d.*)</code>：必须包含两个数字</p>
<p><code>(?=.*[a-z].*[a-z].*)</code>：必须包含两个小写字母</p>
<p><code>(?=.*[A-Z].*[A-Z].*)</code>：必须包含两个大写字母</p>
<p><code>(?=.*[^a-zA-Z0-9].*[^a-zA-Z0-9].*)</code>必须包含两个特殊字符</p>
<p>显而易见，这是用来校验密码强度的正则。</p>
<p><strong>小结：</strong></p>
<p>我们拿到一个正则表达式，不管它有多复杂，千万不要被吓到，需要一步步地将其分解为多个子表达式，然后分析每个子表达式匹配的是何种模式，必要时尝试着举几个例子来验证自己的想法是否正确，最终纵观整体一般都能理解正则表达式的含义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RegExp 对象]]></title>
        <id>https://xiewangmei.github.io/post/regexp/</id>
        <link href="https://xiewangmei.github.io/post/regexp/">
        </link>
        <updated>2020-10-15T01:58:30.000Z</updated>
        <content type="html"><![CDATA[<p><code>RegExp</code>对象提供正则表示式的功能。</p>
<h2 id="概述">概述</h2>
<p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<pre><code class="language-javascript">var regex = /xyz/;
</code></pre>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<pre><code class="language-javascript">var regex = new RegExp('xyz');
</code></pre>
<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<pre><code class="language-javascript">var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
</code></pre>
<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h2 id="实例属性">实例属性</h2>
<p>正则对象的实例属性分成两类。</p>
<p>一类是修饰符相关，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>上面四个属性都是只读的。</p>
<pre><code class="language-javascript">var r = /abc/igm;

r.ignoreCase // true
r.global // true
r.multiline // true
r.flags // 'gim'
</code></pre>
<p>另一类是与修饰符无关的属性，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<pre><code class="language-javascript">var r = /abc/igm;

r.lastIndex // 0
r.source // &quot;abc&quot;
</code></pre>
<h2 id="实例方法">实例方法</h2>
<h3 id="regexpprototypetest">RegExp.prototype.test()</h3>
<p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<pre><code class="language-javascript">/cat/.test('cats and dogs') // true
</code></pre>
<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
<pre><code class="language-javascript">var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
</code></pre>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<pre><code class="language-javascript">var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false

r.lastIndex // 0
r.test(s)
</code></pre>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>。</p>
<p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
<pre><code class="language-javascript">var r = /bb/g;
r.test('bb') // true
r.test('-bb-') // false
</code></pre>
<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。</p>
<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>
<pre><code class="language-javascript">var count = 0;
while (/a/g.test('babaa')) count++;
</code></pre>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<pre><code class="language-javascript">new RegExp('').test('abc')
// true
</code></pre>
<h3 id="regexpprototypeexec">RegExp.prototype.exec()</h3>
<p>正则实例对象的<code>exec</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // [&quot;x&quot;]
r2.exec(s) // null
</code></pre>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r = /_(x)/;

r.exec(s) // [&quot;_x&quot;, &quot;x&quot;]
</code></pre>
<p>上面代码的<code>exec</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</p>
<p><code>exec</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：整个模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<pre><code class="language-javascript">var r = /a(b+)a/;
var arr = r.exec('_abbba_aba_');

arr // [&quot;abbba&quot;, &quot;bbb&quot;]

arr.index // 1
arr.input // &quot;_abbba_aba_&quot;
</code></pre>
<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<pre><code class="language-javascript">var reg = /a/g;
var str = 'abc_abc_abc'

var r1 = reg.exec(str);
r1 // [&quot;a&quot;]
r1.index // 0
reg.lastIndex // 1

var r2 = reg.exec(str);
r2 // [&quot;a&quot;]
r2.index // 4
reg.lastIndex // 5

var r3 = reg.exec(str);
r3 // [&quot;a&quot;]
r3.index // 8
reg.lastIndex // 9

var r4 = reg.exec(str);
r4 // null
reg.lastIndex // 0
</code></pre>
<p>上面代码连续用了四次<code>exec</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<pre><code class="language-javascript">var reg = /a/g;
var str = 'abc_abc_abc'

while(true) {
  var match = reg.exec(str);
  if (!match) break;
  console.log('#' + match.index + ':' + match[0]);
}
// #0:a
// #4:a
// #8:a
</code></pre>
<p>上面代码中，只要<code>exec</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>
<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>
<h2 id="字符串的实例方法">字符串的实例方法</h2>
<p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="stringprototypematch">String.prototype.match()</h3>
<p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<pre><code class="language-javascript">var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

s.match(r1) // [&quot;x&quot;]
s.match(r2) // null

</code></pre>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<pre><code class="language-javascript">var s = 'abba';
var r = /a/g;

s.match(r) // [&quot;a&quot;, &quot;a&quot;]
r.exec(s) // [&quot;a&quot;]

</code></pre>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>
<pre><code class="language-javascript">var r = /a|b/g;
r.lastIndex = 7;
'xaxb'.match(r) // ['a', 'b']
r.lastIndex // 0

</code></pre>
<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h3 id="stringprototypesearch">String.prototype.search()</h3>
<p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>
<pre><code class="language-javascript">'_x_x'.search(/x/)
// 1

</code></pre>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h3 id="stringprototypereplace">String.prototype.replace()</h3>
<p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<pre><code class="language-javascript">str.replace(search, replacement)

</code></pre>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<pre><code class="language-javascript">'aaa'.replace('a', 'b') // &quot;baa&quot;
'aaa'.replace(/a/, 'b') // &quot;baa&quot;
'aaa'.replace(/a/g, 'b') // &quot;bbb&quot;

</code></pre>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>b</code>都被替换掉了。</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<pre><code class="language-javascript">var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')
// &quot;#id div.class&quot;

</code></pre>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$`</code>：匹配结果前面的文本。</li>
<li><code>$'</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<pre><code class="language-javascript">'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// &quot;world hello&quot;

'abc'.replace('b', '[$`-$&amp;-$\']')
// &quot;a[a-b-c]c&quot;

</code></pre>
<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<pre><code class="language-javascript">'3 and 5'.replace(/[0-9]+/g, function (match) {
  return 2 * match;
})
// &quot;6 and 10&quot;

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.

</code></pre>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<pre><code class="language-javascript">var prices = {
  'p1': '$1.99',
  'p2': '$9.99',
  'p3': '$5.00'
};

var template = '&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;';

template.replace(
  /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);
// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot;

</code></pre>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h3 id="stringprototypesplit">String.prototype.split()</h3>
<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<pre><code class="language-javascript">str.split(separator, [limit])

</code></pre>
<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<pre><code class="language-javascript">// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]

</code></pre>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<pre><code class="language-javascript">// 例一
'aaa*a*'.split(/a*/)
// [ '', '*', '*' ]

// 例二
'aaa**a*'.split(/a*/)
// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]

</code></pre>
<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<pre><code class="language-javascript">'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]

</code></pre>
<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>
<h2 id="匹配规则">匹配规则</h2>
<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符">字面量字符和元字符</h3>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<pre><code class="language-javascript">/dog/.test('old dog') // true

</code></pre>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<p><strong>（1）点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code class="language-javascript">/c.t/

</code></pre>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<p><strong>（2）位置字符</strong></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<pre><code class="language-javascript">// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false

</code></pre>
<p><strong>（3）选择符（<code>|</code>）</strong></p>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<pre><code class="language-javascript">/11|22/.test('911') // true

</code></pre>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<pre><code class="language-javascript">// 匹配fred、barney、betty之中的一个
/fred|barney|betty/

</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<pre><code class="language-javascript">/a( |\t)b/.test('a\tb') // true

</code></pre>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<h3 id="转义符">转义符</h3>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="language-javascript">/1+1/.test('1+1')
// false

/1\+1/.test('1+1')
// true

</code></pre>
<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<pre><code class="language-javascript">(new RegExp('1\+1')).test('1+1')
// false

(new RegExp('1\\+1')).test('1+1')
// true

</code></pre>
<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h3 id="特殊字符">特殊字符</h3>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h3 id="字符类">字符类</h3>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<pre><code class="language-javascript">/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true

</code></pre>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<p><strong>（1）脱字符（^）</strong></p>
<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<pre><code class="language-javascript">/[^abc]/.test('hello world') // true
/[^abc]/.test('bbc') // false

</code></pre>
<p>上面代码中，字符串<code>hello world</code>不包含字母<code>a</code>、<code>b</code>、<code>c</code>中的任一个，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的字母，所以返回<code>false</code>。</p>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<pre><code class="language-javascript">var s = 'Please yes\nmake my day!';

s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']

</code></pre>
<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<p><strong>（2）连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<pre><code class="language-javascript">/a-z/.test('b') // false
/[a-z]/.test('b') // true

</code></pre>
<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<pre><code class="language-javascript">[0-9.,]
[0-9a-fA-F]
[a-zA-Z0-9-]
[1-31]

</code></pre>
<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<pre><code class="language-javascript">var str = &quot;\u0130\u0131\u0132&quot;;
/[\u0128-\uFFFF]/.test(str)
// true

</code></pre>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<pre><code class="language-javascript">/[A-z]/.test('\\') // true

</code></pre>
<p>上面代码中，由于反斜杠（'\'）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h3 id="预定义模式">预定义模式</h3>
<p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<p>下面是一些例子。</p>
<pre><code class="language-javascript">// \s 的例子
/\s\w*/.exec('hello world') // [&quot; world&quot;]

// \b 的例子
/\bworld/.test('hello world') // true
/\bworld/.test('hello-world') // true
/\bworld/.test('helloworld') // false

// \B 的例子
/\Bworld/.test('hello-world') // false
/\Bworld/.test('helloworld') // true

</code></pre>
<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<pre><code class="language-javascript">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;

/.*/.exec(html)[0]
// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;

</code></pre>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<pre><code class="language-javascript">var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;;

/[\S\s]*/.exec(html)[0]
// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;

</code></pre>
<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h3 id="重复类">重复类</h3>
<p>模式的精确匹配次数，使用大括号（<code>{}</code>）表示。<code>{n}</code>表示恰好重复<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<pre><code class="language-javascript">/lo{2}k/.test('look') // true
/lo{2,5}k/.test('looook') // true

</code></pre>
<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h3 id="量词符">量词符</h3>
<p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</li>
</ul>
<pre><code class="language-javascript">// t 出现0次或1次
/t?est/.test('test') // true
/t?est/.test('est') // true

// t 出现1次或多次
/t+est/.test('test') // true
/t+est/.test('ttest') // true
/t+est/.test('est') // false

// t 出现0次或多次
/t*est/.test('test') // true
/t*est/.test('ttest') // true
/t*est/.test('tttest') // true
/t*est/.test('est') // true

</code></pre>
<h3 id="贪婪模式">贪婪模式</h3>
<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<pre><code class="language-javascript">var s = 'aaa';
s.match(/a+/) // [&quot;aaa&quot;]

</code></pre>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<pre><code class="language-javascript">var s = 'aaa';
s.match(/a+?/) // [&quot;a&quot;]

</code></pre>
<p>上面代码中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。</p>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）和非贪婪模式的问号（<code>?</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<pre><code class="language-javascript">'abb'.match(/ab*b/) // [&quot;abb&quot;]
'abb'.match(/ab*?b/) // [&quot;ab&quot;]

'abb'.match(/ab?b/) // [&quot;abb&quot;]
'abb'.match(/ab??b/) // [&quot;ab&quot;]

</code></pre>
<h3 id="修饰符">修饰符</h3>
<p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<pre><code class="language-javascript">// 单个修饰符
var regex = /test/i;

// 多个修饰符
var regex = /test/ig;

</code></pre>
<p><strong>（1）g 修饰符</strong></p>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<pre><code class="language-javascript">var regex = /b/;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // true

</code></pre>
<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<pre><code class="language-javascript">var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false

</code></pre>
<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<p><strong>（2）i 修饰符</strong></p>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<pre><code class="language-javascript">/abc/.test('ABC') // false
/abc/i.test('ABC') // true

</code></pre>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<p><strong>（3）m 修饰符</strong></p>
<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<pre><code class="language-javascript">/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true

</code></pre>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<pre><code class="language-javascript">/^b/m.test('a\nb') // true

</code></pre>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>b</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h3 id="组匹配">组匹配</h3>
<p><strong>（1）概述</strong></p>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<pre><code class="language-javascript">/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true

</code></pre>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<pre><code class="language-javascript">var m = 'abcabc'.match(/(.)b(.)/);
m
// ['abc', 'a', 'c']

</code></pre>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<pre><code class="language-javascript">var m = 'abcabc'.match(/(.)b(.)/g);
m // ['abc', 'abc']

</code></pre>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<pre><code class="language-javascript">var str = 'abcabc';
var reg = /(.)b(.)/g;
while (true) {
  var result = reg.exec(str);
  if (!result) break;
  console.log(result);
}
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]

</code></pre>
<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<pre><code class="language-javascript">/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)
// true

</code></pre>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<pre><code class="language-javascript">/y(..)(.)\2\1/.test('yabccab') // true

</code></pre>
<p>括号还可以嵌套。</p>
<pre><code class="language-javascript">/y((..)\2)\1/.test('yabababab') // true

</code></pre>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<pre><code class="language-javascript">var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;

tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]
// 'b'

</code></pre>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<pre><code class="language-javascript">var html = '&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;';
var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;

var match = tag.exec(html);

match[1] // &quot;b&quot;
match[2] // &quot; class=&quot;hello&quot;&quot;
match[3] // &quot;Hello&quot;

match = tag.exec(html);

match[1] // &quot;i&quot;
match[2] // &quot;&quot;
match[3] // &quot;world&quot;

</code></pre>
<p><strong>（2）非捕获组</strong></p>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo){1, 2}/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo){1, 2}/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<pre><code class="language-javascript">var m = 'abc'.match(/(?:.)b(.)/);
m // [&quot;abc&quot;, &quot;c&quot;]

</code></pre>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<pre><code class="language-javascript">// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]

</code></pre>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>（3）先行断言</strong></p>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-javascript">var m = 'abc'.match(/b(?=c)/);
m // [&quot;b&quot;]

</code></pre>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<p><strong>（4）先行否定断言</strong></p>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<pre><code class="language-javascript">/\d+(?!\.)/.exec('3.14')
// [&quot;14&quot;]

</code></pre>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-javascript">var m = 'abd'.match(/b(?!c)/);
m // ['b']

</code></pre>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式基础]]></title>
        <id>https://xiewangmei.github.io/post/regular-expression-base/</id>
        <link href="https://xiewangmei.github.io/post/regular-expression-base/">
        </link>
        <updated>2020-10-15T01:56:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="正则表达式真香">正则表达式“真香”</h2>
<p>开始学习正则表达式之前，我们先看一个简单的编程题：</p>
<p>已知一个字符串'bfb2134rqf5676gur35bgbqd544oihf'，要求提取出字符串中的所有连续数字段，即输出[2134, 5676, 35, 544]。</p>
<p>传统思路：</p>
<pre><code class="language-javascript">function findNumBlock(str) {
    var temp = '';
    var result = [];
    for (var i = 0; i &lt; str.length; i++) {
        var currentChar = str.charAt(i);
        if (str.charAt(i) &lt;= '9' &amp;&amp; str.charAt(i) &gt;= '0') {
            temp += currentChar;
        } else {
            if (temp) {
                result.push(temp);
                temp = '';
            }
        }
    }
    return result;
}
var str = 'bfb2134rqf5676gur35bgbqd544oihf';
findNumBlock(str);
</code></pre>
<p><strong>思考：这段代码有没有什么问题？</strong></p>
<p>正则思路：</p>
<pre><code class="language-javascript">var reg = /\d+/g;
var str = 'bfb2134rqf5676gur35bgbqd544oihf';
str.match(reg)
</code></pre>
<p>显而易见，有时候在处理字符串的问题上，利用好正则会方便很多。</p>
<h2 id="正则表达式的基本概念">正则表达式的基本概念</h2>
<h3 id="定义">定义</h3>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<h3 id="作用">作用</h3>
<p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p>
<ul>
<li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）</li>
<li>可以通过正则表达式，从字符串中获取我们想要的特定部分</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>灵活性、逻辑性和功能性非常的强；</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>
<li>对于刚接触的人来说，比较晦涩难懂。</li>
</ul>
<p><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark><mark>分割线</mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></mark></p>
<h2 id="正则表达式的创建">正则表达式的创建</h2>
<p>新建正则表达式有两种方式：</p>
<ul>
<li>使用<code>字面量</code>，以斜杠表示开始和结束</li>
</ul>
<pre><code class="language-javascript">var regex = /abc/;
</code></pre>
<ul>
<li>使用<code>RegExp</code>构造函数</li>
</ul>
<pre><code class="language-javascript">var regex = new RegExp('abc');
</code></pre>
<p>这两种方式是等价的，都新建了一个内容为<code>\d+</code>的正则表达式对象。<br>
**主要区别：**第一种方法在引擎编译代码时就会新建正则表达式，第二种则在运行时才去新建，所以比较下来前者的效率比较高。此外，第一种方法也比较便利和直观，实际使用中，基本上都是采用第一种方式。</p>
<p><code>RegExp</code>构造函数还可以接收第二个参数，用于表示<code>修饰符</code>：</p>
<pre><code class="language-javascript">var regex = /abc/i;
// 等价于
var regex = new RegExp('abc', 'i');
</code></pre>
<p>有些正则表达式用构造函数形式需要<code>转义</code>，例如文首的程序题中的正则表达式替换后：</p>
<pre><code class="language-javascript">var regex = new RegExp('\\d+', 'g');
</code></pre>
<p>这里再次验证了通过字面量创建正则表达式的便利性。</p>
<h2 id="正则对象的实例属性">正则对象的实例属性</h2>
<p>正则对象的实例属性分为两类。</p>
<p>一类是<code>修饰符</code>相关，用于了解设置了什么<code>修饰符</code>：</p>
<ul>
<li><code>RegExp.prototype.global</code>： 返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.protptype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>以上四个属性都是只读的</p>
<pre><code class="language-javascript">var regex = /abc/gim;
console.log(regex.global);//true
console.log(regex.ignoreCase);//true
console.log(regex.multiline);//true
console.log(regex.flags);//&quot;gim&quot;
</code></pre>
<p>另一类是与<code>修饰符无关</code>的属性，主要是下面两种：</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示<strong>下一次开始搜索的位置</strong>。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<pre><code class="language-javascript">var regex = /abc/gim;
console.log(regex.lastIndex);//0
console.log(regex.source);//abc
</code></pre>
<h2 id="正则对象的实例方法">正则对象的实例方法</h2>
<h3 id="regexpprototypetest">RegExp.prototype.test()</h3>
<p>正则对象的<code>test</code>方法返回一个布尔值，表示当前字符串能否匹配参数字符串。</p>
<pre><code class="language-javascript">// 验证参数字符串中是否包含&quot;hillstone&quot;，结果为true
/hillstone/.test('hillstone network');
</code></pre>
<p>如果正则表达式带有<code>g</code>修饰符，那么每一次<code>test</code>方法都从上次结束的位置开始向后匹配。</p>
<pre><code class="language-javascript">// 匹配字符串中是否包含字母'n'
var regex = /n/g;
var str = 'hillstone network';

console.log(regex.lastIndex);//0
console.log(regex.test(str));//第一次test结果：true

console.log(regex.lastIndex);//8
console.log(regex.test(str));//第二次test结果：true

console.log(regex.lastIndex);//11
console.log(regex.test(str));//第三次test结果：false
</code></pre>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是<code>全局搜索</code>，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是<code>上一次匹配的后一个位置</code>。</p>
<p>前面在介绍<code>lastIndex</code>属性时有提到过，该属性是可读写的，因此带有<code>g</code>修饰符的正则对象，可以通过<code>lastIndex</code>属性指定开始搜索的位置。</p>
<pre><code class="language-javascript">// 匹配字符串中是否包含字母'i'
var regex = /i/g;
var str = 'hillstone network';
regex.lastIndex = 2;//从index:2的位置开始匹配
console.log(regex.test(str));//第一次test结果：false
console.log(regex.test(str));//第二次test结果：true
</code></pre>
<p>观察上面连续两次的匹配结果发现：第一次匹配失败，第二次却成功了？</p>
<p>这是因为正则表达式在匹配失败后，会将<code>lastIndex</code>重置为0，这样第二次匹配时从0开始就可以匹配到字母'i'了。</p>
<p><strong>注意</strong>：带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性值，这时<strong>不应该替换带匹配的字符串</strong>，否则会出现一些难以察觉的错误。</p>
<pre><code class="language-javascript">var regex = /aa/g;
console.log(regex.test('aa'));//第一次test结果：true
console.log(regex.lastIndex);//lastIndex置为2
console.log(regex.test('-aa-'));//第二次test结果：false
</code></pre>
<p><code>lastIndex</code>只对同一个正则表达式有效：</p>
<pre><code class="language-javascript">var count = 0 ;
while(/a/g.test('bab')) {
    count++;
}
console.log(count);
</code></pre>
<p>这段代码看起来意图&quot;很明显&quot;：循环调用正则表达式<code>/a/g</code>的<code>test</code>方法来匹配一个字符串，直到匹配结果为false，退出循环，输出匹配到的个数。但是实际情况是，这里形成了一个<strong>死循环</strong>。原因是<code>while</code>循环的每次匹配条件都是一个<strong>新的正则对象实例</strong>，导致<code>lastIndex</code>属性始终为0。</p>
<p>用<code>构造函数</code>改写一下就能很容易看出问题所在：</p>
<pre><code class="language-javascript">var count = 0 ;
while(new RegExp('a', 'g').test('bab')) {//每次都是一个新的正则对象
    count++;
}
console.log(count);
</code></pre>
<p>如果正则模式是一个空字符串，则匹配所有的字符串：</p>
<pre><code class="language-javascript">var regex = new RegExp('');
console.log(regex.test('a'));//true
console.log(regex.test('b'));//true
</code></pre>
<h3 id="regexpprototypeexec">RegExp.prototype.exec()</h3>
<p>正则对象的<code>exec</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则，返回<code>null</code>。</p>
<pre><code class="language-javascript">var str = 'hillstone';
var regex1 = /hillstone/;
var regex2 = /network/;
console.log(regex1.exec(str));//['hillstone']
console.log(regex2.exec(str));//null
</code></pre>
<p>上述代码中，<code>regex1</code>匹配成功，返回一个数组，成员是匹配结果；<code>regex2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表达式包含圆括号（包含“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<pre><code class="language-javascript">var str = '_x_x';
var regex = /_(x)_/;
console.log(regex.exec(s));//匹配结果：['_x_', 'x']
</code></pre>
<p>结果数组的第一个成员为整个匹配的结果，第二个成员为组匹配的结果。</p>
<p><code>exec</code>方法的返回数组中还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个待匹配字符串。</li>
<li><code>index</code>：整个正则匹配成功的开始位置（从0开始计数）。</li>
</ul>
<pre><code class="language-javascript">var regex = /a(b+)a/;
var arr = r.exec('_abbba_aba_');
console.log(arr);//['abbbx', 'bbb']
console.log(arr.index);//1
console.log(arr.input);//'_abbba_aba_'
</code></pre>
<p>上述代码中<code>index</code>值为1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec</code>方法，下一次搜索的位置<strong>从上一次匹配成功结束的位置开始</strong>：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abc_abc_abc';

var firstMatch = regex.exec(str);
console.log(firstMatch);//['a']
console.log(firstMatch.index);//0
console.log(regex.lastIndex);//1

var secondMatch = regex.exec(str);
console.log(secondMatch);//['a']
console.log(secondMatch.index);//4
console.log(regex.lastIndex);//5

var thirdMatch = regex.exec(str);
console.log(thirdMatch);//['a']
console.log(thirdMatch.index);//8
console.log(regex.lastIndex);//9

var forthMatch = regex.exec(str);
console.log(forthMatch);//null
console.log(regex.lastIndex);//0
</code></pre>
<p>上述代码连续调用四次<code>exec</code>方法，前三次匹配成功，找出了字符串中所有字母'a'，第四次匹配失败，正则表达式的<code>lastIndex</code>重置为0，这时候我们调用<code>exec</code>则再次匹配成功。</p>
<p>考虑到<code>g</code>修饰符允许多次匹配的特点，我们对上述代码进行改造，即可实现循环找出所有匹配项：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abc_abc_abc';
while(true) {
    var result = regex.exec(str);
    if(!result) break;
    console.log('Current matched index is: ' + result.index);
}
</code></pre>
<p>此外，指定正则对象的<code>lastIndex</code>属性在这里同样适用，<code>exec</code>方法会从指定的<code>lastIndex</code>开始向后匹配。</p>
<h2 id="字符串的实例方法">字符串的实例方法</h2>
<p>字符串的实例方法，有四种与正则表达式有关：</p>
<ul>
<li>String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</li>
<li>String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li>String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li>String.prototype.split()：按照给定的正则表达式进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="stringprototypematch">String.prototype.match()</h3>
<p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<pre><code class="language-javascript">var str = 'hillstone network';
var regex1 = /n/;
var regex2 = /a/;
console.log(str.match(regex1));//['n']
console.log(str.match(regex2));//null
</code></pre>
<p>从上述代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式包含<code>g</code>修饰符，则<code>match</code>方法与正则对象的<code>exec</code>方法行为有所区别：<strong>会一次性返回包含所有匹配结果的数组</strong>：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abcabc';
console.log(regex.exec(str));//['a']
console.log(str.match(regex));//['a', 'a']
</code></pre>
<p>设置正则对象的<code>lastIndex</code>属性，对<code>match</code>方法<strong>无效</strong>，匹配总是从字符串的第一个字符开始：</p>
<pre><code class="language-javascript">var regex = /a/g;
var str = 'abcabc';
regex.lastIndex = 4;
console.log(str.match(regex));//['a', 'a']
console.log(regex.lastIndex);//0
</code></pre>
<h3 id="stringprototypesearch">String.prototype.search()</h3>
<p>字符串实例对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置，如果没有任何匹配，则返回<code>-1</code>。</p>
<pre><code class="language-javascript">var regex1 = /a/;
var regex2 = /b/;
var str = 'account';
console.log(str.search(regex1));//字符串index=0的位置匹配到'a',返回0
console.log(str.search(regex2));//字符串匹配不到'b'，返回-1
</code></pre>
<h3 id="stringprototypereplace">String.prototype.replace()</h3>
<p>字符串实例对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式；第二个是是替换的内容。</p>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值：</p>
<pre><code class="language-javascript">console.log('aaa'.replace('a', 'b'));//'baa'
console.log('aaa'.replace(/a/, 'b'));//'baa'
console.log('aaa'.replace(/a/g, 'b'));//'bbb'
</code></pre>
<p>最后一个表达式中，带了<code>g</code>修饰符，故字符串中的'a'全部替换为'b'。</p>
<p><code>replace</code>方法的一个应用就是消除字符串首尾空格：</p>
<pre><code class="language-javascript">var str = '  #id div.class  ';
console.log(str.replace(/^\s+|\s+$/g, ''));//'#id div.class'
</code></pre>
<p><strong>思考：上面的正则不带<code>g</code>修饰符会是什么结果？</strong></p>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容：</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$`</code>：匹配结果前面的文本。</li>
<li><code>$'</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<pre><code class="language-javascript">var str = 'How to use Regex Expression in the replace method.';
// 结果为How to use &quot;Regex Expression&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$&amp;&quot;'));
// 结果为How to use &quot;How to use&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$`&quot;'));
// 结果为How to use &quot; in the replace method.&quot; in the replace method.
console.log(str.replace(/Regex Expression/, '&quot;$\'&quot;'));
// 结果为How to use replace method in the Regex Expression.
console.log(str.replace(/(Regex Expression) in the (replace method)/, '$2 in the $1'))；
// 结果为How to use $ in the Regex Expression.
console.log(str.replace(/Regex Expression/, '$$'))；
</code></pre>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换成函数的返回值：</p>
<pre><code class="language-javascript">// 字符串中的整数乘以2
'1 and 12 and 123'.replace(/\d+/g, function(match) {
    return match * 2;
});
// 字符串中的单词首字母大写
'hillstone network'.replace(/\b\w|\s\w/g, function(match) {
    return match.toUpperCase();
});
</code></pre>
<p>作为<code>replace</code>方法第二个参数的函数，可以接受多个参数。其中，第一个参数是匹配到的内容，第二个参数是匹配到的组（有多少个匹配到的组，就有多少个对应的参数）。此外，最后还能有两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。下面是一个网页模板替换的例子：</p>
<pre><code class="language-javascript">const prices = {
    p1: '$1.99',
    p2: '$9.99',
    p3: '$3.68'
};
const template = `&lt;div&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;
&lt;/div&gt;`;
template.replace(/(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g, function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
});
</code></pre>
<p>结果如下：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
  &lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h3 id="stringprototypesplit">String.prototype.split()</h3>
<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各部分组成的数组。该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数（可选）是返回数组的最大成员数。</p>
<pre><code class="language-javascript">var str = 'a, b,c, d';

// 非正则分割
console.log(str.split(','));
// [ 'a', '  b', 'c', ' d' ]

// 正则分割，去除多余空格
console.log(str.split(/, */));
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
console.log(str.split(/, */, 2));
// [ 'a', 'b' ]
</code></pre>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<pre><code class="language-javascript">// 例一
console.log('aaa*a*'.split(/a*/));//['', '*', '*']
// 例二
console.log('aaa**a'.split(/a*/));//['', '*', '*', '']
</code></pre>
<p>上述代码的分割规则是：<strong>0次或多次的a</strong>，由于正则默认是<code>贪婪匹配</code>，所以例一中有两个分隔符：<code>aaa</code>和<code>a</code>，例二中有三个分隔符：<code>aaa</code>和<code>''</code>和<code>a</code>。</p>
<p>另外，如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回：</p>
<pre><code class="language-javascript">console.log('aaa*a*'.split(/(a*)/));//['', 'aaa', '*', 'a', '*']
</code></pre>
<p>上述代码中，最终返回数组的第二项<code>'aaa'</code>和第四项<code>'a'</code>就是组匹配的结果。</p>
<h2 id="匹配规则">匹配规则</h2>
<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符">字面量字符和元字符</h3>
<h4 id="字面量字符">字面量字符</h4>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”。</p>
<pre><code class="language-javascript">/dog/.test('dog and cat');//true
</code></pre>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起，所以测试字符串匹配成功。</p>
<h4 id="元字符">元字符</h4>
<p>除了字面量字符，还有一部分字符有特殊含义，不代表字面的意思。它们叫做<code>元字符</code>，主要有以下几个：</p>
<h5 id="1-点字符">(1) 点字符<code>.</code></h5>
<p>点字符<code>.</code>匹配除回车<code>\r</code>、换行<code>\n</code>、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code class="language-javascript">/b.g/.test('bag');//true
/b.g/.test('bug');//true
/b.g/.test('b g');//true
/b.g/.test('b.g');//true
/b.g/.test('buug');//false
</code></pre>
<h5 id="2-位置字符和">(2) 位置字符<code>^</code>和<code>$</code></h5>
<p>位置字符用来提示字符所处的位置，主要有两个字符：</p>
<ul>
<li><code>^</code>：字符串的开始位置。</li>
<li><code>$</code>：字符串的结束位置。</li>
</ul>
<pre><code class="language-javascript">/^hillstone/.test('hillstone network');//true
/hillstone$/.test('suzhou hillstone');//true
/^hillstone$/.test('hillstone network');//false
/^hillstone$/.test('hillstone');//true
</code></pre>
<h5 id="3-选择符">(3) 选择符<code>|</code></h5>
<p>竖线符号<code>|</code>在正则中表示“或”关系，例如<code>suzhou|beijing</code>匹配<code>suzhou</code>或<code>beijing</code>。</p>
<pre><code class="language-javascript">/suzhou|beijing/.test('suzhou hillstone');//true
/suzhou|beijing/.test('beijing hillstone');//true
</code></pre>
<p>多个选择符可以联合使用：</p>
<pre><code class="language-javascript">var regex = /apple|banana|orange/;//匹配&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;的任意一项
</code></pre>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号：</p>
<pre><code class="language-javascript">/a( |\t)b/.test('a\tb');//true
/a( |\t)b/.test('a b');//true
</code></pre>
<p>上述代码表示<code>a</code>和<code>b</code>之间有一个空格或一个制表符。</p>
<h5 id="4-其它元字符">(4) 其它元字符</h5>
<p>另外还有一些元字符，如：<code>\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文介绍。</p>
<h4 id="转义符">转义符</h4>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面加上反斜杠<code>\</code>。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="language-javascript">/1+1/.test('1+1');//false
/1\+1/.test('1+1');//true
</code></pre>
<p>上述第一个表达式中，<code>+</code>是元字符，所以在正则中不代表其字面含义，需要匹配<code>+</code>本身时，需要对其进行一次转义，所以第二个表达式匹配成功。</p>
<p>正则表达式中，需要反斜杠<code>\</code>转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\</code>。需要特别注意的是，<strong>如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠</strong>，因为字符串内部会先转义一次。</p>
<pre><code class="language-javascript">new RegExp('1\+1').test('1+1');//false
new RegExp('1\\+1').test('1+1');//true
</code></pre>
<p>上述代码中，通过<code>RegExp</code>构造函数创建一个正则对象，而构造函数的参数是一个字符串。而在字符串内部，反斜杠<code>\</code>也是转义字符，所以<code>+</code>会被字符串转义一次，然后再被正则转义一次，最终才创建出正确的正则对象。</p>
<p>在Chrome的Console中分别输入<code>'1\+1'</code>和<code>'1\\+1'</code>，看看最终得到的字符串是什么？</p>
<h4 id="特殊字符">特殊字符</h4>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h4 id="字符类">字符类</h4>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[abc]</code>表示<code>a</code>、<code>b</code>、<code>c</code>中任选一个匹配：</p>
<pre><code class="language-javascript">/[abc]/.test('bug');//true
/[abc]/.test('egg');//false
</code></pre>
<p>有两个字符在字符类中有特殊含义：脱字符<code>^</code>和连字符<code>-</code>。</p>
<h5 id="脱字符">脱字符<code>^</code></h5>
<p>如果方括号内的第一个字符是<code>^</code>，则表示匹配<strong>至少包含</strong>一个<strong>不在字符类中的字符</strong>的字符串。换句话说，如果方括号内通过脱字符<code>^</code>指定了一堆字符，那么这些字符以外的其它字符都可以匹配。</p>
<pre><code class="language-javascript">/[^a]/.test('a');//false：不包含a以外的字符
/[^a]/.test('b');//true：包含a以外的字符
/[^ab]/.test('a');//false：不包含a、b以外的字符
/[^ab]/.test('ac');//true：包含a、b以外的字符c
/[^ab]/.test('c');//true：包含a、b以外的字符c
</code></pre>
<p>如果方括号内没有其他字符，即<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，上文中介绍的点字符<code>.</code>是不包括换行符的。</p>
<pre><code class="language-javascript">/hillstone[^]network/.test('hillstone network');//true
/hillstone[^]network/.test('hillstone.network');//true
/hillstone[^]network/.test('hillstone\rnetwork');//true
/hillstone.network/.test('hillstone network');//true
/hillstone.network/.test('hillstone.network');//true
/hillstone.network/.test('hillstone\rnetwork');//false
</code></pre>
<blockquote>
<p>注意，脱字符只有在<strong>字符类的第一个位置</strong>才有特殊含义，否则就是字面含义。</p>
</blockquote>
<h5 id="连字符-">连字符<code>-</code></h5>
<p>某些情况下，对于连续序列的字符，连字符<code>-</code>用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以简写成<code>[a-c]</code>，<code>[0123456789]</code>可以简写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母</p>
<pre><code class="language-javascript">/a-z/.test('b');//false
/[a-z]/.test('b');//true
</code></pre>
<p>上述代码中，第一个例子匹配失败，原因是连字符<code>-</code>若不是出现在方括号<code>[]</code>中，则不具备简写的作用，只代表字面意义，所以只匹配包含<code>a-z</code>这三个字符的字符串。只有当连字符用在方括号中，才表示连续的字符序列。</p>
<p>常见的字符类简写形式有：<code>/[0-9]/</code>、<code>/[a-z]/</code>、<code>/[A-Z]/</code>、<code>/[0-9a-zA-Z]/</code>。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则有可能会匹配到一些意料之外的字符。例如：<code>/[A-z]/</code>可能第一眼会认为匹配大写的<code>A</code>到小写的<code>z</code>这52个字母，但是由于在ASCII编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果：</p>
<pre><code class="language-javascript">// 反斜杠&quot;\&quot;的ASCII码在大写字母和小写字母之间
/[A-z]/.test('\\');//true
// 改写方案一：
/[A-Za-z]/.test('\\');//false
// 改写方案二：
/[A-Z]/i.test('\\');//false
</code></pre>
<h4 id="预定义模式">预定义模式</h4>
<p>预定义模式指的是某些常见模式的简写方式：</p>
<ul>
<li><code>\d</code>：匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code>：匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code>：匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]。</code></li>
<li><code>\W</code>：匹配除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code>：匹配空格（包括换行符、制表符、空格符等），相当于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code>：匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code>：匹配单词的边界字符。</li>
<li><code>\B</code>：匹配单词的非边界字符。</li>
</ul>
<p>下面是一些例子：</p>
<pre><code class="language-javascript">// \s的例子
'hillstone network'.match('\\s\\w+');//[&quot; network&quot;]

// \b的例子
'hillstone network'.match('\\bnetwork');//[&quot;network&quot;]
'hillstone-network'.match('\\bnetwork');//[&quot;network&quot;]
'hillstonenetwork'.match('\\bnetwork');//null

// \B 的例子
'hillstone-network'.match('\\Bnetwork');//null
'hillstonenetwork'.match('\\Bnetwork');//network
</code></pre>
<p>通常，正则表达式遇到换行符<code>\n</code>就会停止匹配：</p>
<pre><code class="language-javascript">//匹配结果为：“&lt;b&gt;hillstone&lt;/b&gt;&quot;
/.*/.exec('&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;')[0];
</code></pre>
<p>上述代码中，字符串中包含一个换行符<code>\n</code>，导致点字符<code>.</code>无法匹配整个字符串。利用<code>\s</code>和<code>\S</code>这两个预定义模式进行改写，就能完全匹配：</p>
<pre><code class="language-javascript">//匹配结果为：&quot;&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;&quot;
/[\s\S]*/.exec('&lt;b&gt;hillstone&lt;/b&gt;\n&lt;i&gt;network&lt;/i&gt;')[0];
</code></pre>
<p>上述代码中，<code>[\s\S]</code>指代一切字符。</p>
<p>至此，我们已经知道有两种方式可以用来匹配一切字符：<code>[^]</code>和<code>[\s\S]</code>。</p>
<h4 id="重复类">重复类</h4>
<p>模式的精确匹配次数，使用大括号<code>{}</code>表示，<code>{n}</code>表示恰好出现<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复次数不少于<code>n</code>次且不多于<code>m</code>次：</p>
<pre><code class="language-javascript">/lo{2}k/.test('look');//true
/lo{2,}k/.test('look');//true
/lo{2,}k/.test('loook');//true
/lo{2,4}k/.test('loook');//true
/lo{2,4}k/.test('loooook');//false
/lo{2,4}/.test('loooook');//true：这里为什么是true？
</code></pre>
<h4 id="量词符">量词符</h4>
<p>量词符用来表示某个模式出现的次数：</p>
<ul>
<li><code>?</code>：表示某个模式出现0次或1次，等价于<code>{0,1}</code>。</li>
<li><code>*</code>：表示某个模式出现0次或多次，等价于<code>{0,}</code>。</li>
<li><code>+</code>：表示某个模式出现1次或多次，等价于<code>{1,}</code>。</li>
</ul>
<pre><code class="language-javascript">// ?：出现0次或1次
/go?d/.test('gd');//true
/go?d/.test('god');//true
/go?d/.test('goooood');//false

// *：出现0次或多次
/go*d/.test('gd');//true
/go*d/.test('god');//true
/go*d/.test('goooood');//true

// +：出现1次或多次
/go+d/.test('gd');//false
/go+d/.test('god');//true
/go+d/.test('goooood');//true
</code></pre>
<h4 id="贪婪模式">贪婪模式</h4>
<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这种模式叫做<code>贪婪模式</code>。</p>
<pre><code class="language-javascript">/o?/.exec('oooooo')[0];//'o'
/o*/.exec('oooooo')[0];//'oooooo'
/o+/.exec('oooooo')[0];//'oooooo'
</code></pre>
<p>上面的正则表示匹配<code>至少1个o</code>形式的字符串，由于正则默认是<code>贪婪匹配</code>，那么会一直匹配到不出现<code>o</code>为止。</p>
<p>如果要改为<code>非贪婪模式</code>，在量词符后加上一个<code>?</code>即可，这样一旦条件满足就不再往下匹配：</p>
<pre><code class="language-javascript">/o??/.exec('oooooo')[0];//''
/o*?/.exec('oooooo')[0];//''
/o+?/.exec('oooooo')[0];//'o'
</code></pre>
<h4 id="修饰符">修饰符</h4>
<p><code>修饰符</code>表示模式的附加规则，放在正则模式的最尾部，总共有三种：</p>
<ul>
<li><code>g</code>修饰符：表示全局匹配。</li>
<li><code>i</code>修饰符：表示忽略大小写。</li>
<li><code>m</code>修饰符：表示匹配多行。</li>
</ul>
<p>这些修饰符可以单独使用，也可以多个一起使用：</p>
<pre><code class="language-javascript">'Hillstone'.match(/hillstone/i);//['Hillstone']
'Hillstone hillstone'.match(/hillstone/gi);//['Hillstone', 'hillstone']
</code></pre>
<h5 id="g修饰符"><code>g</code>修饰符</h5>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配，加上它之后，正则对象将匹配全部符合条件的结果，主要用于<strong>搜索</strong>和<strong>替换</strong>。</p>
<pre><code class="language-javascript">var regex1 = /o/;
var regex2 = /o/g;
var str = 'oop';

// 不加g修饰符
regex1.test(str);//true
regex1.test(str);//true
regex1.test(str);//true

// 加g修饰符
regex2.test(str);//true
regex2.test(str);//true
regex2.test(str);//false
</code></pre>
<p>上述代码中连续执行三次<code>regex1.test(str)</code>和<code>regex2.test(str)</code>。前者三次都匹配成功，是因为每次都是从字符串的开始位置开始匹配；后者前两次匹配成功，最后一次失败，是因为每次匹配都是从<code>lastIndex</code>开始匹配，第三次匹配的时候<code>lastIndex</code>值为2，对应字符为<code>p</code>，所以匹配失败。</p>
<h5 id="i修饰符"><code>i</code>修饰符</h5>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符后表示忽略大小写。</p>
<pre><code class="language-javascript">/hillstone/.test('HillStone');//false
/hillstone/i.test('HillStone');//true
</code></pre>
<h5 id="m修饰符"><code>m</code>修饰符</h5>
<p>默认情况下，字符串无论是否换行都只有一个开始<code>^</code>和结尾<code>$</code>，如果采用多行匹配，那么每一行都有一个开始<code>^</code>和结尾<code>$</code>。</p>
<pre><code class="language-javascript">// 只有一个开始和结尾
/^network/.test('hillstone\nnetwork');//false
/network$/.test('hillstone network\n');//false

// 多个开始和结尾
/^network/m.test('hillstone\nnetwork');//true
/network$/m.test('hillstone network\n');//true
</code></pre>
<h4 id="组匹配">组匹配</h4>
<h5 id="概述">概述</h5>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容：</p>
<pre><code class="language-javascript">/end+/.test('endd');//true
/(end)+/.test('endend');//true
</code></pre>
<p>上述代码中，第一个模式没有括号，所以<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，所以<code>+</code>表示重复单词<code>end</code>。</p>
<p>下面是另外两个分组捕获的例子：</p>
<pre><code class="language-javascript">// 例子1
/(.)b(.)/.match('abcabc');//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// 例子2
/(.)b(.)/g.match('abcabc');//[&quot;abc&quot;, &quot;abc&quot;]
</code></pre>
<p>上述代码的两个例子仅仅相差一个<code>g</code>修饰符，<code>match</code>方法的结果却有很大差异：一个捕获了匹配整个表达式的部分和所有分组，一个捕获了匹配整个表达式的所有子串。所以这里有一点需要注意：<strong>使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容</strong>。</p>
<p>如果一定需要将<code>组匹配</code>和<code>g</code>修饰符结合起来使用，可以用正则对象的<code>exec</code>方法搭配循环来实现：</p>
<pre><code class="language-javascript">var regex = /(.)b(.)/g;
var str = 'abcabc';
while(true) {
    var result = regex.exec(str);
    if(!result) break;
    else console.log(result);
}
//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
</code></pre>
<p>正则表达式内部还可以用<code>\n</code>来引用组匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的组匹配的内容：</p>
<pre><code class="language-javascript">/(.)b(.)\1b\2/.exec('abcabc');//[&quot;abcabc&quot;, &quot;a&quot;, &quot;c&quot;]
/(.)b(.)\2b\1/.exec('abccba')[0];//[&quot;abccba&quot;, &quot;a&quot;, &quot;c&quot;]
</code></pre>
<p>上述代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>括号还支持嵌套：</p>
<pre><code class="language-javascript">/((ab)\2)\1/.exec('ababababc');//[&quot;abababab&quot;, &quot;abab&quot;, &quot;ab&quot;]
</code></pre>
<p>上述代码中，<code>\1</code>表示外层括号，<code>\2</code>表示内层括号。在存在组嵌套的表达式中，<code>\n</code>是类似于深度优先的方式来进行标号，如下图所示：</p>
<pre><code class="language-javascript">/(a(b))(c)(d)\1\2\3\4/.test('abcdabbcd');
 | |   |  |___  \4
 | |   |______  \3
 | |__________  \2
 |____________  \1
</code></pre>
<p>组匹配非常有用，下面是一个匹配网页标签的例子：</p>
<pre><code class="language-javascript">var result = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;);
var htmlFragment = result[0];
var tagName = result[1];
console.log(htmlFragment);//&quot;&lt;b&gt;bold&lt;/b&gt;&quot;
console.log(tagName);//&quot;b&quot;
</code></pre>
<p>上述代码中的正则表达式，应该是本文学到现在见过的最复杂的正则，我们来梳理一下：</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602727276949.png" alt="匹配网页标签正则解析" loading="lazy"></figure>
<p>拆解之后，我们很容易看出该表达式是用来匹配类似<code>&lt;span&gt;hillstone&lt;/span&gt;</code>这样的字符串，也就是匹配网页标签。</p>
<p>将上述代码稍作修改，就能匹配带属性的标签：</p>
<pre><code class="language-javascript">var result = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/.exec('&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;');
console.log(result[1]);//b
console.log(result[2]);// class=&quot;hello&quot;
console.log(result[3]);//Hello
</code></pre>
<h5 id="非捕获组">非捕获组</h5>
<p><code>(?:x)</code>称为非捕获组，表示匹配结果中不包含该组匹配的内容：</p>
<pre><code class="language-javascript">// 正常组匹配
'abc'.match(/(.)b(.)/);//[&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// 非捕获组匹配
'abc'.match(/(?:.)b(.)/);//[&quot;abc&quot;, &quot;c&quot;]
</code></pre>
<p>上述第二个例子中，第一个组采用了<code>非捕获组</code>匹配，所以最终返回的结果没有第一个括号，只有第二个括号的内容。</p>
<p>再来看一个分解网址的正则表达式：</p>
<pre><code class="language-javascript">// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec('http://google.com/');
// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]
</code></pre>
<p>上述代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<h5 id="先行断言">先行断言</h5>
<p><code>x(?=y)</code>称为<code>先行断言</code>，意思是<code>x</code>必须在<code>y</code>之前才匹配，<code>y</code>不会被记入返回结果：</p>
<pre><code class="language-javascript">var regex = /\d+(?=%)/;//匹配后面跟着'%'的数字
'97%'.match(regex);//[&quot;97&quot;]
</code></pre>
<p>上述代码使用了<code>先行断言</code>，括号内的<code>%</code>不会作为结果返回。</p>
<h5 id="先行否定断言">先行否定断言</h5>
<p><code>x(?!y)</code>称为<code>先行否定断言</code>，<code>x</code>只有不在<code>y</code>之前才匹配，<code>y</code>不会被记入返回结果：</p>
<pre><code class="language-javascript">var regex1 = /\d+(?!%)/;//匹配后面不是跟着'%'的数字
'97%'.match(regex1);//['9']
'97c'.match(regex1);//['97']

var regex2 = /\d+(?!\.)/;//匹配后面不是跟着'.'的数字
'3.14'.match(regex2);//['14']
'1234'.match(regex2);//['1234']
</code></pre>
<p>上述代码使用了<code>先行否定断言</code>，括号内对应的<code>%</code>、<code>.</code>等都不会作为结果返回。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何绘制一个带飞线动效的旋转3D地球]]></title>
        <id>https://xiewangmei.github.io/post/3d-earth/</id>
        <link href="https://xiewangmei.github.io/post/3d-earth/">
        </link>
        <updated>2020-10-15T01:42:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="期望效果图">期望效果图</h2>
<p><img src="https://xiewangmei.github.io/post-images/1602726769537.gif" alt="期望效果" loading="lazy"><br>
从效果图中，我们提炼出几个需要实现的关键点：</p>
<ul>
<li>绘制一个立体地球</li>
<li>实现地球颜色渐变（左上角稍亮，右下角稍暗）</li>
<li>实现地球上的点，点的连线，连线上的飞点</li>
<li>实现地球自转</li>
<li>实现根据鼠标的移入移出切换地球的自动旋转</li>
<li>实现中国地图鼠标悬浮高亮效果</li>
<li>实现拖拽</li>
</ul>
<h2 id="确定地球的dom结构">确定地球的DOM结构</h2>
<p>我们按照<code>海洋→陆地→球面点→连线→飞点</code>这样的顺序来分层绘制地球，所以其DOM结构如下：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h2 id="绘制一个基础地球">绘制一个基础地球</h2>
<p>地球由<strong>海洋</strong>和<strong>陆地</strong>组成，我们在实现时也按照这两个部分分步绘制。</p>
<h3 id="绘制海洋">绘制海洋</h3>
<p>这部分最为简单，在画布中心绘制一个直径稍小于画布宽高的圆即可，为其填充蓝色</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<pre><code class="language-javascript">const oceanCanvas = document.getElementById(&quot;#oceanCanvas&quot;);
const { width, height } = oceanCanvas;
const cx = width/2;
const cy = height/2;
const oceanCanvasContext = oceanCanvas.getContext(&quot;2d&quot;);
const oceanRadius = Math.min(width, height) * 0.8;
oceanCanvasContext.fillStyle = &quot;blue&quot;;
oceanCanvasContext.arc(cx, cy, oceanRadius, 0, Math.PI);
oceanCanvasContext.fill();
</code></pre>
<h3 id="绘制陆地">绘制陆地</h3>
<p>准备好一份标准的<code>worldmap.json</code>，用作陆地数据。</p>
<p>我们在海洋画布上方罩一个同尺寸的画布，用于绘制陆地。</p>
<pre><code class="language-html">&lt;canvas id=&quot;oceanCanvas&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;landCanvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>有了数据，怎么把数据转换成一个个图呢？这里我们引入<code>d3</code>库，它提供了一套完备的API可供绘制地图。</p>
<pre><code class="language-javascript">// 创建投影
const projection = d3.geoOrthographic().clipAngle(90).scale(oceanRadius).translate([cx, cy]).rotate([90, 0, 0]);
// 依据投影创建路径生成器
const path = d3.geoPath(projection);
landCanvasContext.fillStyle = &quot;skyblue&quot;;
landCanvasContext.strokeStyle = &quot;skyblue&quot;;
// 提取陆地数据中的features
const features = worldmap.features;
features.forEach(f =&gt; {
    landCanvasContext.beginPath();
    path.context(landCanvasContext)(f);
    landCanvasContext.closePath();
    landCanvasContext.stroke();
    landCanvasContext.fill();
});
</code></pre>
<p>到这一步，我们应该能画出一个静止的地球了。</p>
<h2 id="实现地球的颜色渐变">实现地球的颜色渐变</h2>
<p>由于陆地是由成百上千个路径组成，对其填充色做渐变处理会十分麻烦。而由于海洋是一个简单圆形，实现渐变会相对简单，故我们将渐变色填充给海洋，陆地则填充一个带有透明度的色值，这样效果能比较接近。</p>
<pre><code class="language-javascript">const highlightCenterX = cx - oceanRadius/2;
const highlightCenterY = cy - oceanRadius/2;
const grd = context.createRadialGradient(highlightCenterX, highlightCenterY, r/8, highlightCenterX, highlightCenterY, 1.25 * oceanRadius);
grd.addColorStop(0, &quot;#0d4484&quot;);
grd.addColorStop(1, &quot;#041e3c&quot;);
context.fillStyle = grd;
context.arc(cx, cy, r, 0, Math.PI);
context.fill();
...
landCanvasContext.fillStyle = &quot;rgba(0, 80, 192, 0.4)&quot;;// 陆地修改为带透明度的色值
...
</code></pre>
<p>到这一步，地球已经加上了渐变效果。</p>
<h2 id="绘制球面上的点">绘制球面上的点</h2>
<p>球面上的点实际上是一个个的经纬度坐标，而要将这些经纬度坐标转成屏幕坐标仍旧需要借助<code>d3</code>的API</p>
<pre><code class="language-javascript">const geoPath = d3.geoPath(projection);// 依据投影创建一个路径生成器
const enterFn = enter =&gt; {
    const g = enter.append(&quot;g&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;full&quot;);
    g.append(&quot;path&quot;).attr(&quot;class&quot;, &quot;circle&quot;);
};
const updateFn = update =&gt; {
    update.each(function(d) {
        const circle = d3.geoCircle().center(d.geometry.coordinates);// 根据投影创建圆生成器
        const color = d.color;
        const g = d3.select(this);
        g.select(&quot;path.full&quot;).attr(&quot;fill&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(1.5)()));
        g.select(&quot;path.circle&quot;).attr(&quot;stroke&quot;, color).attr(&quot;d&quot;, geoPath(circle.radius(2)()));
    });
};
svg.selectAll(&quot;g&quot;).data(points).join(enterFn, updateFn);
</code></pre>
<p>到这一步，球面上的点绘制完成</p>
<h2 id="绘制点之间的连线">绘制点之间的连线</h2>
<p>绘制连线可以采用插值器的方式实现，具体可以参考<code>d3</code>官网的<a href="http://bl.ocks.org/dwtkns/4973620">例子</a>，但是我们要实现的效果跟官网有些许区别：官网示例中，当其中一个点转到地球背面时，整条线都不可见；而我们是尽可能多地展示连线可见部分。所以得另辟蹊径。</p>
<p><img src="https://xiewangmei.github.io/post-images/1602726832506.png" alt="地球连线示意图" loading="lazy"><br>
如上图所示，地球外层画了一系列圆圈，这些圆圈可以理解为地球外侧的一系列轨道，我们可以在轨道上取一系列的点，将这些点用短线段进行连接，最终形成一个完整的从起点到终点的连线。上图中的连线看起来不平滑，所以我们实际操作时可以<strong>适当减小轨道间距，增加轨道数，以增加平滑度</strong>。</p>
<p><strong>注：为何不采用二次贝塞尔曲线？二次贝塞尔曲线需要根据轨道上每个点的二维坐标计算控制点，随着地球的旋转，坐标一直在发生变化，控制点也会随之改变，这样绘制出的曲线就会有在地球表面&quot;拖动&quot;的效果</strong></p>
<h3 id="选取连线上的点">选取连线上的点</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1602726866367.png" alt="地球连线示意图2" loading="lazy"></figure>
<p>任何两点之间的连线，我们都可以通过旋转地球达到上图所示的效果，所以我们简化问题，以此视角进行分析：</p>
<p>前面提到过，地球外层的一系列圆圈可以理解为轨道，那么这些轨道上的点一定可以投影到地球表面，找到对应的地理坐标。反之，我们找到这些地球表面上的点，就能根据轨道投影找到轨道上对应位置的点。观察上图中点与点之间间距变化发现：左右对称，并且从起点到最外层轨道间距是逐渐增大（貌似在暗示我们用<code>d3.scalePow()</code>）。</p>
<p>我们目前的已知项只有起终点坐标，而借助<code>d3.geoInterpolate(start, end)(ratio)</code>可以得出<strong>两点间指定比例(ratio：0~1)的点的经纬度坐标</strong>，有了这一系列的经纬度坐标，投影上的位置相应也能够得出。所以，问题又简化成如何计算出**类似[ 0, 0.0625, 0.125, 0.25, 0.5, 0.75, 0.875, 0.7375, 1 ]**的<code>ratios数组</code>。</p>
<p>前面我们讲到，连线左右对称，且左半部分间距逐渐增大，可以用<code>d3.scalePow()</code>来实现：</p>
<pre><code class="language-javascript">// size：轨道数量(地球表面算第0个轨道)
// 计算左半边弧线的比率
const calcRatios = size =&gt; {
  const scale = d3
    .scalePow()
    .exponent(2)
    .domain([0, size - 1])
    .range([0, 0.5]);
  let i = 0;
  const result = [];
  while (i &lt; size) result.push(scale(i++));
  // 拼接出弧线上的所有比率
  return [
    ...result,
    ...result
      .slice(0, result.length - 1)
      .map(v =&gt; 1 - v)
      .reverse()
  ];
};
</code></pre>
<p>现在有了<code>ratios数组</code>，再通过公式<code>d3.geoInterpolate(start, end)(ratio)</code>可以计算出对应比例的经纬度坐标，有了经纬度坐标，就能通过各自对应的投影得到这些点在屏幕上的位置：</p>
<pre><code class="language-javascript">// 此处略过创建projections的代码
const ratios = calcRatios(projections.length);
const interpolate = d3.geoInterpolate(start, end);
const infos = ratios.map((ratio, i) =&gt; {
    const geoLocation = interpolate(ratio);
    const projection = 
          i &lt; projections.length 
          ? projection[i] 
          : projections[(projections.length - 1) * 2 - i];
    const screenLocation = projection(geoLocation);
    // 这里返回了比例、经纬度、投影、屏幕坐标,备用
    return { ratio, geoLocation, projection, screenLocation };
});
</code></pre>
<p>前文中为了方便讲解投影，比例等概念，将地球旋转到了一个完美角度，这个时候线上所有点均可见。但在地球不断旋转的过程中，经常会有线的一段甚至整段处于地球背面的情况，所以需要对这些点进行过滤处理：</p>
<ul>
<li>起终点均可见——不过滤</li>
<li>起点可见终点不可见——找到最后一个可见的点</li>
<li>起点不可见终点可见——找到第一个可见的点</li>
</ul>
<p>我们以可视半球的正投影中心（圆心）为参考点，可视半球上的任意一点到参考点的弧度差范围在<code>0 ~ π/2</code>之间，不可视半球上的点到参考点的弧度差在<code>π/2 ~ π</code>之间，<code>d3.geoDistance(coordinate1, coordinate2)</code>可用来计算球面上两个经纬度之间的弧度差，根据差值即可判定出该点是落在可视半球还是非可视半球上。</p>
<pre><code class="language-javascript">const { start, end } = link;// 假定link是众多线中的其中一条的数据
const center = projections[0].invert([w/2, h/2]);// 得到正投影圆心的经纬度
const distBetweenStartCenter = d3.geoDistance(center, start);
const distBetweenEndCenter = d3.geoDistance(center, end);
if(distBetweenStartCenter &gt;= 1.57 &amp;&amp; distBetweenEndCenter &gt;= 1.57) {
   return [];
}else {
    if(distBetweenStartCenter &gt;= 1.57) {// 起点不可见
       const firstVisiblePointIndex = infos.findIndex(
           info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
           1.57 + Math.acos(projections[0].scale() / info.projection.scale())
       );
       return infos.slice(firstVisible);
    } else if(distBetweenEndCenter &gt;= 1.57) { // 终点不可见
       const lastVisiblePointIndex = [...infos]
           .reverse()
           .findIndex(
               info =&gt; d3.geoDistance(center, info.geoLocation) &lt;
               1.57 + Math.acos(projections[0].scale() / info.projection.scale())
           );
        return infos.slice(0, infos.length - lastVisiblePointIndex);
    } else {// 起终点均可见
        return infos;
    }
}
</code></pre>
<h3 id="以点成线">以点成线</h3>
<p>到这里，我们就能够循环遍历infos绘制出所有连线了。不过在此之前，我们需要将上一步最后的代码包到函数里方便调用：</p>
<pre><code class="language-javascript">const calcLinkPoints = (start, end, projection, w, h) =&gt; {
    // 计算infos
    return infos;
};
</code></pre>
<p>画线：</p>
<pre><code class="language-javascript">linkCanvasContext.lineWidth = 0.5;
linkCanvasContext.strokeStyle = &quot;rgba(146, 191, 243, 0.8)&quot;;
links.forEach(data =&gt; {
    data.points = calcLinkPoints(data.source, data.target, projections, width, height);
    if(data.points.length) {
        d3.line().context(linkCanvasContext)(
            data.points.map(info =&gt; info.screenLocation)
        );
    }
});
</code></pre>
<h2 id="绘制线上的飞点">绘制线上的飞点</h2>
<p>我们看到的线上的飞点是由一个个圆心连续，半径逐渐变小且颜色逐渐变淡的圆组合而成。<br>
<img src="https://xiewangmei.github.io/post-images/1602726899299.png" alt="地球连线示意图3" loading="lazy"></p>
<p>点与点之间的位置及比例关系：<br>
<img src="https://xiewangmei.github.io/post-images/1602726916062.png" alt="地球连线示意图4" loading="lazy"></p>
<pre><code class="language-javascript">const getRadius = d3
  .scaleLinear()
  .domain([0, 30])
  .range([1.5, 0]);
const colorInterpolate = d3.interpolate([&quot;#FFFFFF&quot;, &quot;#92BFF3&quot;]);
const scaleColor = d3
  .scaleLinear()
  .domain([0,30])
  .range([0,1]);
const getGradientCircleRadiusAndFill = index =&gt; ({
  r: getRadius(index),
  fill: getColor(index)
});

const drawFlyPoint = (context, links) =&gt; {
    links.forEach(data =&gt; {
        // curRatio:飞点当前位置占线总长的百分比
        const curRatio = data.ratio;
        // 找到第一个比飞点当前位置大的百分比(轨道上的比率)
        const firstBiggerIndex = data.points.findIndex(p =&gt; p.ratio &gt; curRatio);
        if(firstBiggerIndex &lt;= 0) {
        } else {
            const p1 = data.points[firstBiggerIndex - 1];
            const p3 = data.points[firstBiggerIndex];
            const r = (curRatio - p1.ratio) / (p3.ratio - p1.ratio);
            const p2X = 
                  p1.screenLocation[0] + 
                  r * (p3.screenLocation[0] - p1.screenLocation[0]);
            const p2Y = 
                  p1.screenLocation[1] + 
                  r * (p3.screenLocation[1] - p1.screenLocation[1]);
            const points = [
                [p2X, p2Y],
                ...data.points
                  .slice(0, firstBiggerIndex)
                  .reverse()
                  .map(p =&gt; p.screenLocation)
            ];
            
            const centers = getCirclesCenter(points);
            centers.forEach((c, index) =&gt; {
                const { r, fill } = getGradientCircleRadiusAndFill(index);
                context.fillStyle = fill;
                context.beginPath();
                context.arc(c[0], c[1], r, 0, Math.PI * 2);
                context.closePath();
                context.fill();
            });
        }
    });
};
</code></pre>
<p>这样我们就能根据每次的数据绘制出对应位置的飞点</p>
<h2 id="实现地球自转">实现地球自转</h2>
<p>地球自转实际上对应的是各个投影轨道的角度翻转(rotate)，所以比较简单：</p>
<pre><code class="language-javascript">const rotate = rotation =&gt; projections.forEach(p =&gt; p.rotate(rotation));
const animate = () =&gt; {
  links.forEach(l =&gt; {
    l.ratio = l.stepRatio + l.ratio;
    if(l.ratio &gt;= 1) l.ratio = 0;//飞点到达终点后重新开始飞点
  });
  if(autoRotate) {
    rotate(peojections[0].rotate().map((v, i) =&gt; (i === 0 ? v + 0.2 :v)));
  }
  ...
  //重新绘制地球以及点、线等
  ...
  window.requestAnimationFrame(animate);
};
</code></pre>
<h2 id="实现鼠标移入停转移出开转">实现鼠标移入停转移出开转</h2>
<p>注意到地球自转代码里有一个标志位<code>autoRotate</code>，用来决定球体是否自动旋转，那只需要对<code>mousemove</code>做个监听就行了：</p>
<pre><code class="language-javascript">d3.select(document.body)
  .on(
    &quot;mousemove&quot;,
    () =&gt; 
      (autoRotate = 
        getDistance(
          [d3.event.clientX, d3.event.clientY],
          [width / 2, height / 2]
        ) &gt; earthRadius)
  );
</code></pre>
<h2 id="实现中国地图悬浮高亮效果">实现中国地图悬浮高亮效果</h2>
<p>在前面绘制陆地部分，我们已经将所有的国家都绘制在canvas上，而在canvas上做交互会比较麻烦，所以我们将中国数据单独提取出来，绘制到svg上，这样可以对中国版图添加hover样式。</p>
<p>修改dom结构：</p>
<pre><code class="language-jsx">&lt;div&gt;
  &lt;canvas id=&quot;oceanCanvas&quot; /&gt;
  &lt;canvas id=&quot;landCanvas&quot; /&gt;
  &lt;svg id=&quot;chinaSvg&quot; /&gt;
  &lt;svg id=&quot;pointSvg&quot; /&gt;
  &lt;canvas id=&quot;linkCanvas&quot; /&gt;
  &lt;canvas id=&quot;flyPointCanvas&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p>单独绘制中国地图部分:</p>
<pre><code class="language-javascript">const chinaFeature = features.filter(isInChina);
d3.select(chinaSvg)
  .selectAll(&quot;g.land&quot;)
  .data(chinaFeature)
  .join(
    enter =&gt;
      enter
        .append(&quot;g&quot;)
        .classed(&quot;china&quot;, true)
        .append(&quot;path&quot;)
        .attr(&quot;fill&quot;, &quot;skyblue&quot;)
        .attr(&quot;stroke&quot;, &quot;skyblue&quot;),
      update =&gt; update.select(&quot;path&quot;).attr(&quot;d&quot;, d3.geoPath(projections[0]))
  );
</code></pre>
<p>CSS：</p>
<pre><code class="language-scss">.china:hover path {
    fill: rgba(255, 200, 0, 0.8)
}
</code></pre>
<h2 id="实现拖拽">实现拖拽</h2>
<p>拖拽也是添加监听即可</p>
<pre><code class="language-javascript">const addRotateListeners = (selection, projection, rotateHander) =&gt; {
  let m0, o0;
  const body = d3.select(document.body);

  const startDrag = () =&gt; {
    m0 = [d3.event.pageX, d3.event.pageY];
    o0 = projection.rotate();
    body.on(&quot;mousemove.forRotate&quot;, drag);
    body.on(&quot;mouseup.forRotate&quot;, stopDrag);
  };
  const drag = () =&gt; {
    const m1 = [d3.event.pageX, d3.event.pageY];
    const o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
    o1[1] = o1[1] &gt; 30 ? 30 : o1[1] &lt; -30 ? -30 : o1[1];
    rotateHander(o1);
  };
  const stopDrag = () =&gt; {
    body.on(&quot;mousemove.forRotate&quot;, null);
    body.on(&quot;mouseup.forRotate&quot;, null);
  };

  selection.on(&quot;mousedown&quot;, startDrag);
};
addRotateListeners(pointSvg, projections[0], rotate);
</code></pre>
<h2 id="小结">小结</h2>
<p>至此，效果图我们已经实现完成，功能点较多，依赖于<code>d3</code>库的<code>projection</code>，还掺杂有一些数学几何知识，需要花一些时间去思考。后续可以将其封装成<code>React</code>组件或者<code>Vue</code>组件，以备不时之需</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Diff]]></title>
        <id>https://xiewangmei.github.io/post/react-diff/</id>
        <link href="https://xiewangmei.github.io/post/react-diff/">
        </link>
        <updated>2020-09-29T05:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="虚拟dom">虚拟DOM</h2>
<p>虚拟DOM是和真实DOM相对应的。真实DOM也就是平时我们所说的DOM，它是对结构化文本的抽象表达。在web环境中，其实就是对HTML文本的一种抽象表述，每一个HTML元素对应一个DOM节点，HTML元素的层级关系也会体现在DOM节点的层级上，所有的这些DOM节点构成一棵DOM树。</p>
<p>在传统前端开发中，通过浏览器提供的一组API直接对DOM执行增删改查操作，例如<code>getElementById</code>，<code>insertBefore</code>等。这些操作看似只执行一条<code>JavaScript</code>语句，但它们的执行效率要比执行一条普通的<code>JavaScript</code>语句慢得多，尤其是对DOM进行增删改操作，每一次对DOM的修改都会引起浏览器对页面的重新布局和重新渲染，这个过程是很耗时的。所以前端性能优化里面有一条原则：<strong>尽量减少DOM操作</strong>。</p>
<p>既然直接操作DOM效率低下，那么有什么办法可以解决这个问题呢？在软件开发中，有这么一句话，<strong>软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决</strong>。DOM效率低下的这个问题同样可以通过增加一层抽象解决，<code>虚拟DOM</code>就是对真实DOM的抽象。这里需要注意，虚拟DOM并非React独有，它是一个独立的技术，只不过React使用了这项技术来提高自身的性能。</p>
<p>虚拟DOM使用<code>普通的JavaScript对象</code>来描述DOM元素，对象的结构和<code>React.CreateElement()</code>参数类似。例如，我们有下面这样的一个DOM结构：</p>
<pre><code class="language-html">&lt;div class = 'foo'&gt;
    &lt;h1&gt;
        Hello React
    &lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>相对应的虚拟DOM就可以用下面这样的对象来描述：</p>
<pre><code class="language-javascript">const virtualDom = {
    type: 'div',
    props: {
        className: 'foo',
        children: [{
            type: 'h1',
            props: {
                children: ['Hello React']    
            }
        }]    
    },
    
};
</code></pre>
<p>有了虚拟DOM这层抽象，当我们需要操作真实DOM时，就可以操作虚拟DOM这个<code>JavaScript对象</code>，速度当然要比操作真实DOM快得多。</p>
<h2 id="diff算法">Diff算法</h2>
<p>React采用声明式的API描述UI结构(JSX)，每次组件的状态或属性更新，组件的<code>render</code>方法都会返回一个新的虚拟DOM对象用来描述新的UI结构。如果每次都直接使用新的虚拟DOM结构来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响程序执行效率。事实上，React会通过比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高执行效率。这一过程就是React的调和过程<code>(Reconciliation)</code>，其中的关键就是<code>diff算法</code>。</p>
<h3 id="react-diff算法的三大策略">React-diff算法的三大策略</h3>
<h4 id="1-tree-diff-web-ui中dom节点跨层级的移动操作特别少可以忽略不计"><strong>1. Tree Diff —— Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计</strong></h4>
<p>React把树按照层级分解，在对新旧虚拟DOM进行比较时，只会对同层进行比较（节点类型，属性）。这是React-diff算法的关键点（<strong>因为组件是树形结构，需要基于该策略做diff</strong>）。</p>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358709820.png" alt="同层比较" loading="lazy"></figure>
<p>如图所示，React只会相互比较相同颜色框内的节点，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。由此一来，最直接的提升就是复杂度变为线型增长而不是原先的指数增长。</p>
<p>前面我们提到了同层比较，那当我们的节点发生跨层级移动，diff算法会是什么表现呢？</p>
<figure data-type="image" tabindex="2"><img src="https://xiewangmei.github.io/post-images/1601358737506.png" alt="跨层级操作" loading="lazy"></figure>
<p>B节点连同它的子节点一起移动到A节点之下，直观的考虑DOM Diff应该是</p>
<pre><code class="language-jsx">R.remove(B); 
A.append(B);
</code></pre>
<p>但是，实际上<code>React</code>只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有<code>创建</code>和<code>删除</code>操作，所以当根节点发现B节点消失了，就会删除B节点及其子节点，当A发现多了一个子节点B，就会创建新的B作为其子节点，这样DOM Diff就变成：</p>
<pre><code class="language-javascript">B.destroy();
C = new C();
D = new D();
B = new B();
B.append(C);
B.append(D);
A.append(B);
</code></pre>
<p>换句话说，这里进行了较多的DOM操作，因此，我们在开发组件时，尽量保持DOM结构稳定是一种不错的选择。</p>
<h4 id="2-componnet-diff-相同类型的组件会生成相似的树形结构不同类型的两个组件将会生成不同的树形结构"><strong>2. Componnet Diff —— 相同类型的组件会生成相似的树形结构，不同类型的两个组件将会生成不同的树形结构</strong></h4>
<ul>
<li>
<p><strong>同类型组件</strong>：按照前面所说的<code>Tree Diff策略</code>继续比较虚拟DOM。需要注意的是，在这种情况下，如果用户能确定新旧虚拟DOM之间没有任何变化，React给了我们一个<code>shouldComponentUpdate()</code>方法，通过设置返回值<code>true</code>和<code>false</code>可以决定组件是否进行diff操作，用得好的话， 可以节省大量的 diff 运算时间。</p>
</li>
<li>
<p><strong>不同类型组件</strong>：该组件判定为<code>dirty componnet</code>，替换掉整个组件包括其子节点</p>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 的这种直接删除再重新创建的机制会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://xiewangmei.github.io/post-images/1601358776690.png" alt="相似组件" loading="lazy"></figure>
<h4 id="3-对于同一层级的一组兄弟节点可以通过唯一的key值来进行区分"><strong>3. 对于同一层级的一组兄弟节点，可以通过唯一的Key值来进行区分</strong></h4>
<p>当一个节点有多个子节点时，默认情况下，React只会按照顺序逐一比较两棵树上的对应子节点，一旦新旧虚拟DOM相同位置的节点对应不上，就会进行修改操作。</p>
<p>乍一看貌似没什么问题？看个栗子：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
    &lt;li&gt;javascript&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这里我们在列表最后添加一个<code>javascript</code>，对比的时候,<code>php</code>，<code>java</code>都能匹配上，然后在最后新增<code>javascript</code>，一切顺利。那我们把<code>javascript</code>加到列表首项，像这样：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li&gt;javascript&lt;/li&gt;
    &lt;li&gt;php&lt;/li&gt;
    &lt;li&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这时候的结果就是：<code>php</code>更新为<code>javascript</code>，<code>java</code>更新为<code>php</code>，最后新增<code>java</code>项，<strong>每一个节点</strong>都发生了修改。</p>
<p>为了解决这种低效的更新方式，React提供了一个Key属性，用来匹配新旧虚拟DOM的子节点，在每次渲染之后，只要子节点的Key值没有变化，React就会认为这是同一个节点。上面的例子我们这样改：</p>
<pre><code class="language-jsx">const oldList = &lt;ol&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
const newList = &lt;ol&gt;
    {/* 添加至首项 */}
    &lt;li key='javascript'&gt;javascript&lt;/li&gt;
    &lt;li key='php'&gt;php&lt;/li&gt;
    &lt;li key='java'&gt;java&lt;/li&gt;
&lt;/ol&gt;;
</code></pre>
<p>这样React就能判断出<code>&lt;li key='javascript'&gt;javascript&lt;/li&gt;</code>节点是新增节点，其他两个节点没有发生变化，最终只需要进行一次新增节点操作即可。</p>
<p><strong>注意</strong>：有时候我们会通过数组的map方法将每个数组成员映射到一个列表元素，这里应该尽量避免用数组的index来作为Key值。因为数组中的成员顺序一旦发生改变，可能会导致大量的Key值失效，进而引起大量的修改操作。</p>
<p>避免这种写法：</p>
<pre><code class="language-jsx">&lt;ul&gt;
    (list.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;))
&lt;/ul&gt;
</code></pre>
<h2 id="总结">总结</h2>
<p>1.开发组件时，尽量保持DOM结构的稳定，有助于提升性能。例如，可以通过设置样式来控制元素的显示隐藏，而不是真正移除或添加DOM节点。</p>
<p>2.用好<code>shouldComponentUpdate()</code>方法，减少不必要的diff计算。</p>
<p>3.在一组兄弟节点中，设置合适的Key值来帮助React识别相同节点，减少不必要的DOM操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React小知识]]></title>
        <id>https://xiewangmei.github.io/post/react-knowledge/</id>
        <link href="https://xiewangmei.github.io/post/react-knowledge/">
        </link>
        <updated>2020-09-29T05:47:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="react的程序流程">React的程序流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiewangmei.github.io/post-images/1601358552129.png" alt="React程序流程" loading="lazy"></figure>
<ul>
<li>在React中无论发生何种事件，引发的都是React组件的重新渲染，至于如何只修改必要的DOM部分，则完全交给React去操作，开发者并不需要关心。</li>
</ul>
<h3 id="virtual-dom">Virtual DOM</h3>
<ul>
<li>
<p>既然DOM树是对HTML的抽象，那<code>Virtual DOM</code>就是对DOM的抽象。<code>Virtual DOM</code>不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的<code>Virtual DOM</code>和上一次渲染的<code>Virtual DOM</code>，对比就会发现差别，然后修改真正的DOM树时就只要触及差别中的部分就行了。</p>
<ul>
<li>
<p>以ClickCouter为例，一开始点击计数为0，用户点击按钮让点击计数变成1，这次重新渲染，React通过<code>Virtual DOM</code>的对比发现其实只是id为clickCount的span元素中内容从0变成了1而已：</p>
<pre><code class="language-javascript">&lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;
</code></pre>
<p>React发现这次渲染要做的事情只是更换这个span元素的内容而已，其他DOM元素都不需要触及，于是执行类似下面的语句就可以完成任务了：</p>
<pre><code class="language-javascript">document.getElementById(&quot;clickCount&quot;).innerHTML = &quot;1&quot;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="prop和state的对比">prop和state的对比</h3>
<ul>
<li><code>prop</code>用于定义外部接口，<code>state</code>用于记录内部状态</li>
<li><code>prop</code>的赋值在外部世界使用组件时，<code>state</code>的赋值在组件内部</li>
<li>组件不应该改变<code>prop</code>的值，而<code>state</code>存在的目的就是让组件来改变的</li>
</ul>
<h3 id="refrefs">ref&amp;refs</h3>
<ul>
<li>
<p><code>React</code>支持一种非常特殊的属性<font color='red'><code>ref</code></font>，可以用来绑定到render()输出的任何组件上</p>
<ul>
<li><code>ref</code>：绑定属性</li>
<li><code>refs</code>：调用的时候使用</li>
</ul>
</li>
<li>
<p>通过<code>refs</code>访问父组件方法</p>
<pre><code class="language-jsx">this.refs.subcomponents.subHandleClick();
</code></pre>
</li>
<li>
<p>为了获取真实DOM节点，html元素必须有一个<code>ref属性</code>，然后**<code>this.refs.[refName]</code>**就会返回这个真实的DOM节点。</p>
<blockquote>
<p><strong>注意</strong>：由于**this.refs.[refName]**属性获取的是真实DOM，所以必须等到虚拟DOM插入文档后，才能使用这个属性，否则获取不到。</p>
</blockquote>
</li>
</ul>
<h3 id="组件生命周期">组件生命周期</h3>
<ul>
<li>
<p><strong><code>constructor</code></strong>：构造函数是初始化状态的合适位置。若不初始化状态且不绑定方法，那就不需要为React组件定义一个构造函数。</p>
</li>
<li>
<p><strong><code>render</code></strong>：该方法是必须的，当被调用时，其应该检查<code>this.props</code>和<code>this.state</code>，并返回以下类型中的一个：</p>
<ul>
<li>
<p><strong>React元素</strong>：通常由JSX创建，该元素可能是一个原生DOM组件的表示，如<code>&lt;div/&gt;</code>，或者是一个自定义的合成组件。</p>
</li>
<li>
<p><strong>字符串或数字</strong>：这些将被渲染为DOM中的Text Node</p>
</li>
<li>
<p><strong><a href="https://segmentfault.com/a/1190000012325351">Portals</a></strong>：由<strong>ReactDOM.createPortal</strong>创建，可以将React子节点的DOM结构，渲染到React父节点之外的DOM中， portal 也一直存在于React 树上，无论它位于 DOM 树中的什么位置。</p>
<pre><code class="language-react">ReactDOM.createPortal(child, container)
</code></pre>
</li>
<li>
<p><strong>null</strong>：什么都不渲染</p>
</li>
<li>
<p><strong>布尔值</strong>：什么都不渲染，（通常存在于<code>return test &amp;&amp; &lt;child /&gt;</code>写法，其中<code>test</code>是布尔值。</p>
<p>当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>）</p>
</li>
</ul>
</li>
<li>
<p><strong><code>componentWillMount</code></strong>：紧贴着自己组件的<code>render</code>函数之前被调用</p>
</li>
<li>
<p><strong><code>componentDidMount</code></strong>：不是紧跟着<code>render</code>之后调用，当所有的组件都调用完了，所有组件的<code>componentDidMount</code>才会一起被调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个<strong>适合实现网络请求的地方</strong>。在该方法里设置状态将<strong>会触发重渲</strong>。</p>
<blockquote>
<p>原因：<code>render</code>函数本身并不往DOM树上渲染或者装载内容，它只是返回一个<font color='blue'><code>JSX表示的对象</code></font>，然后由React库来根据返回对象决定如何渲染</p>
</blockquote>
</li>
</ul>
<h3 id="jsx">JSX</h3>
<ul>
<li>
<p>和原生HTML定义事件的唯一区别就是<code>JSX</code>采用<strong>驼峰</strong>写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，<strong>返回一个事件处理函数</strong>。React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在<strong>根节点document</strong>上为每种事件添加唯一的Listener，然后通过事件的<strong>target找到真实的触发元素</strong>。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React<strong>模拟事件系统</strong>。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。</p>
</li>
<li>
<p>在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，<strong>属性值不能是字符串而必须为对象</strong>。</p>
<pre><code class="language-jsx">&lt;div style={{color: '#ff0000', fontSize: 14}}&gt;Hello World.&lt;/div&gt;

{/*或者（注释要这么写）*/}  

var style = {
  color: '#ff0000',
  fontSize: 14
};

var node = &lt;div style={style}&gt;HelloWorld.&lt;/div&gt;;
</code></pre>
</li>
</ul>
<blockquote>
<p>**注意：**原生HTML元素名以小写字母开头，而自定义的React类名以<font color='red'><strong>大写字母</strong></font>开头，比如HelloMessage不能写成helloMessage，除此之外还需要注意组件类只能包含<font color='red'><strong>一个顶层标签</strong></font>，否则也会报错。</p>
</blockquote>
<h3 id="受控组件">受控组件</h3>
<h4 id="input标签">input标签</h4>
<ul>
<li>在React中，<code>&lt;input&gt;</code>会用<strong>value属性</strong>来代替子节点，value属性的值总是和文本输入框的最新内容一致，如果想要指定默认值，可以使用<strong>defaultValue属性</strong>。</li>
</ul>
<h4 id="textarea标签">textarea标签</h4>
<ul>
<li>在React中，<code>&lt;textarea&gt;</code>会用<strong>value属性</strong>来替代子节点。这样的话，表单中的<code>&lt;textarea&gt;</code>非常类似于使用单行输入的表单。</li>
</ul>
<h4 id="select标签">select标签</h4>
<ul>
<li>
<p>在React中，并不适用之前的<code>selected</code>属性，而是在根<code>select</code>标签上用<strong>value属性</strong>来表示选中的项。这在受控组件中更为方便。例如：</p>
<pre><code class="language-jsx">&lt;select value={this.state.value} onChange={this.handleChange}&gt;
    &lt;option value='grapefruit'&gt;Grapefruit&lt;/option&gt;
    &lt;option value='lime'&gt;Lime&lt;/option&gt;
    &lt;option value='coconut'&gt;Coconut&lt;/option&gt;
    &lt;option value='mango'&gt;Mango&lt;/option&gt;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>总结：</strong><code>&lt;input type=&quot;text&quot;&gt;、&lt;textarea&gt;和&lt;select&gt;</code>都十分类似——他们都通过传入一个<font color='red'><strong>value属性</strong></font>来实现对组件的控制。</p>
<h4 id="typescript中使用usedispatch">TypeScript中使用useDispatch</h4>
<pre><code class="language-javascript"> Promise.resolve(
    dispatch(
     	submitRegistryConfig(REGISTRY_DRAWER_STATEID, values, mode === &quot;edit&quot; ? &quot;PUT&quot; : &quot;POST&quot;)
 	)
 ).then(() =&gt; {
 	closeDrawer();
 	callback();
 });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React & Antd]]></title>
        <id>https://xiewangmei.github.io/post/react-and-antd/</id>
        <link href="https://xiewangmei.github.io/post/react-and-antd/">
        </link>
        <updated>2020-09-29T05:45:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>可以通过React.createContext中的Provider实现夸层级传递属性，避免繁琐的一层层传递</p>
<pre><code class="language-react">const { Provider } = React.createContext();
{......}
</code></pre>
</li>
<li>
<p>tab点击想要触发重新渲染，可以设置state里的数据发生变化，但是该state必须要使用，才会触发，不然就不会触发，可以将原本的对象返回一个新对象，比如</p>
<pre><code class="language-javascript">record={…record}
component: props =&gt; {
 return &lt;filterRoute.component {...props} /&gt;;
}
</code></pre>
</li>
<li>
<p>一行一个标签对应多个输入组件，这个需求很常见但在官方例子没看到合适的，因为官方建议：</p>
<blockquote>
<p>注意：一个 Form.Item 建议只放一个被 getFieldDecorator 装饰过的 child，当有多个被装饰过的 child 时，help required validateStatus 无法自动生成。</p>
</blockquote>
<p>所以可以通过在FormItem组件中再包一层FormItem，通过flex布局调整其布局，,这样校验的位置也是正确的，校验提示也能自动生成。</p>
<pre><code class="language-react">&lt;FormItem {...formItemLayout} label=&quot;IP地址段&quot;&gt;
     &lt;div style={{ display: &quot;flex&quot; }}&gt;
     	&lt;FormItem&gt;
        {getFieldDecorator(&quot;start&quot;, {
            rules: [{ required: true, message: &quot;该项为必填项&quot; }]
         })(
             &lt;Input style={{ width: 220 }}placeholder=&quot;请输入起始IP&quot;/&gt;
         )}
         &lt;/FormItem&gt;
		&lt;div className={styles[&quot;ip-range-div&quot;]}&gt;-&lt;/div&gt;
		&lt;FormItem&gt;
    	{getFieldDecorator(&quot;end&quot;, {
           	rules: [{ required: true, message: &quot;该项为必填项&quot; }]
   		 })(
        &lt;Input style={{ width: 220 }} placeholder=&quot;请输入结束IP&quot;/&gt;
        )}
        &lt;/FormItem&gt;
	&lt;/div&gt;
&lt;/FormItem&gt;
</code></pre>
</li>
<li>
<p>想要一个组件不被重新渲染，那么该组件的props都必须被校验为未修改才不会执行重渲染，函数执行返回的是一个新对象，比如说Drawer</p>
<pre><code class="language-React"> &lt;RegionManagerDrawer
     handleSubmitResult={this.handleSubmitResult}
     onClose={this.closeDrawer}
     // onClose={()=&gt;this.closeDrawer()}这种写法会触发重新渲染
     mode={mode}
     record={record}
     handleEdit={this.handleEdit}
 /&gt;
</code></pre>
<p>但是有一个问题：Modal 只要将destoryOnClose设置为true即可</p>
</li>
<li>
<p>antd的table控制是否展开，expandedRowKeys数组存放对应展开行的数据key，控制是否单独单元格放置展开图标<code>expandIconAsCell = {false}</code>，number设置展开图标所在的单元格索引，取一个不存在的索引可达到去掉预设图标的效果<code>expandIconColumnIndex = {-1}</code></p>
</li>
<li>
<p>table固定列的宽度，超出部分用<code>…</code>代替（针对普通table和antd）</p>
<ul>
<li>
<p>让溢出内容变成…，需要如下样式</p>
<pre><code class="language-css">overflow: hidden; //超出部分隐藏
text-overflow:ellipsis; //显示省略符来代表被修剪的文本
white-space: nowrap; //强制不换行
</code></pre>
<p>table的宽度我们并不能控制，内容会自动撑大表格列表宽度，需要给<code>table</code>加上一个样式：</p>
<pre><code class="language-css">table-layout:fixed;
</code></pre>
</li>
</ul>
</li>
<li>
<p>经过 <code>getFieldDecorator</code> 包装的控件，表单控件会自动添加 <code>value</code>，switch这种实际值不是value什么的，在form表单中可能设置不上值，需要通过<code>valuePropName</code>指定子节点的值的属性，如 Switch 的是 'checked'</p>
</li>
<li>
<p>在form中如果已经设置了initialValue:value，避免在componentDidMount（useEffect）等生命周期函数中使用this.props.form.setFieldsValue，否则会产生<code>Warning: You cannot set a form field before rendering a field associated with the value</code>，单一使用即可</p>
</li>
<li>
<p>form item的validator中必须要返回callback().，否则<code>validateFields（validateFieldsAndScroll ）</code>方法不生效</p>
<pre><code class="language-react">handleConfirmPassword = (rule, value, callback) =&gt; {
        const { getFieldValue } = this.props.form
        if (value &amp;&amp; value !== getFieldValue('newPassword')) {
            callback('两次输入不一致！')
        }

        // Note: 必须总是返回一个 callback，否则 validateFieldsAndScroll 无法响应
        callback()
 }
</code></pre>
</li>
<li>
<p>setState支持回调，可以在render之前进行dom focus系列的操作，hooks中的setXXX不支持回调，转变为在useEffect中进行操作，同时监听XXXstate，即可实现同样的效果</p>
</li>
<li>
<p>通过setFieldsValue的属性设置值时，该元素必须是紧接着FormItem的，不然没法设置成功，不能嵌套div之类的其他元素</p>
</li>
<li>
<p>create-react-app 报错 babel插件与实际安装的present-env版本不一致，是因为代理的问题，尝试去掉<code>用户\wmxie</code>下面的<code>.npmrc</code>文件，再重新执行，若不报错，则是代理的问题，尝试替换代理或不使用代理</p>
</li>
<li>
<p>Icon可以设置rotate来控制图标旋转的角度   <code>transform: rotate(45deg);</code></p>
</li>
<li>
<p>JavaScript之forEach循环遍历方法用于调用数组的每个元素，并将元素传递给回调数组，<code>forEach</code>是Array下的一个方法。</p>
<blockquote>
<p>注意：无法使用break等语句跳出遍历，直到所有元素都传递给调用的函数，但是可以抛出异常，提前终止循环。类似的还有map</p>
</blockquote>
</li>
<li>
<p>react-redux升级之后基本都变成了function组件，比如connect由class组件变成了function组件，需要传递ref</p>
<pre><code class="language-javascript">1. 组件是class，使用connect进行包裹
	connect(mapStateToProps,mapDispatchToProps,null,{forwardRef:true})
2. 组件是function，未使用connect
	 (1).使用forwardRef包裹组件
3. 组件是function，同时使用connect进行包裹
	 (1).使用forwardRef包裹function组件，同时connect中需要按照情况1的写法写
     (2).使用forwardRef包裹组件，使用useSelector，useDispatch，不使用connect
</code></pre>
</li>
<li>
<p>antd的FormItem在创建的时候会给组件传递ref，所以就会有15中的问题存在，需按照15中的方法执行</p>
</li>
<li>
<p>ref={ref} 这种形式 括号里的ref是React.createRef出来的 最终会被放到ref.current里</p>
<p>ref={function} 这种形式 不需要React.createRef</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native]]></title>
        <id>https://xiewangmei.github.io/post/react-native/</id>
        <link href="https://xiewangmei.github.io/post/react-native/">
        </link>
        <updated>2020-09-29T05:29:57.000Z</updated>
        <content type="html"><![CDATA[<center><h2>React Native</h2></center>
<h3 id="developer-menu">Developer Menu</h3>
<p>Andriod模拟器：可以通过Ctrl+M快键键快速打开</p>
<p>IOS模拟器：可以通过Ctrl+D快捷键快速打开</p>
<h3 id="flatlist">FlatList</h3>
<ul>
<li>FlatList会安排视图的渲染，只显示当前在屏幕上的那些元素。而那些已经渲染好了的但移动到了屏幕之外的元素，则会从原生视图结构中移除（以提高性能）</li>
</ul>
<h3 id="platform模块">Platform模块</h3>
<ul>
<li>
<p>Platform.OS上会返回<code>ios</code>，而在Android设备或模拟器上则会返回<code>android</code></p>
</li>
<li>
<p>有个实用的方法是Platform.select()，它可以以Platform.OS为key，从传入的对象中返回对应平台的值</p>
<pre><code class="language-react">import { Platform, StyleSheet } from &quot;react-native&quot;;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: &quot;red&quot;
      },
      android: {
        backgroundColor: &quot;blue&quot;
      }
    })
  }
});
</code></pre>
<p>该方法可以接受任何合法类型的参数，也可以直接用它针对不同平台返回不同的组件，</p>
<pre><code class="language-react">const Component = Platform.select({
	ios: () =&gt; require(&quot;ComponentIOS&quot;),
	android: () =&gt; require(&quot;CompnentAndroid&quot;)
})();
&lt;Component/&gt;
</code></pre>
</li>
<li>
<p>检测Android版本，在Android上，<code>Version</code>属性是一个数字，表示Android的api level：</p>
<pre><code class="language-react">import {Platform} from 'react-native';
if(Platform.Version === 25){
	console.log(&quot;Running on Nougat&quot;);
}
</code></pre>
</li>
<li>
<p>检测iOS版本，在iOS上<code>Version</code>属性是<code>-[UIDevice systemVersion]</code>的返回值，具体形式为一个表示当前系统版本的字符串，比如可能是“10.3”</p>
<pre><code class="language-react">import { Platform } from &quot;react-native&quot;;
const majorVersionIOS = parseInt(Platform.Version, 10);
if(majorVersionIOS &lt;= 9) {
	console.log(&quot;Work around a change in behavior&quot;);
}
</code></pre>
</li>
</ul>
<h3 id="特定平台扩展名">特定平台扩展名</h3>
<ul>
<li>
<p>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native会检测某个文件是否具有<code>.ios.</code>或.<code>android.</code>的扩展名，然后根据当前运行的平台自动加载正确对应的文件。比如可以创建这种组件，然后去掉平台扩展名直接引用：</p>
<pre><code class="language-javascript">BigButton.ios.js
BigButton.android.js

import BigButton from './BigButton'
</code></pre>
<p>React Native会根据运行平台的不同自动引入正确对应的组件。</p>
</li>
<li>
<p>如果希望在web端复用React Native的代码，那么还可以使用<code>.native.js</code>的扩展名。此时iOS和Android会使用<code>BigButton.native.js</code>文件，而web端会使用<code>BigButton.js</code></p>
</li>
</ul>
<h3 id="图片">图片</h3>
<h4 id="静态图片资源">静态图片资源</h4>
<ul>
<li>
<p>可以使用<code>@2x</code>，<code>@3x</code>这样的文件名后缀，来为不同的屏幕精度提供图片。比如说，iPhone7会使用check@2x.png，而iPhone 7 plus或是Nexus 5上则会使用check@3x.png。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片</p>
<p><em>注意：如果添加图片的时候packager正在运行，则可能需要重启packager以便能正确引入新添加的图片</em></p>
</li>
</ul>
<h3 id="textinput">TextInput</h3>
<ul>
<li>
<p>placeholderTextColor 设置占位文字字体颜色</p>
<pre><code class="language-jsx">&lt;TextInput placeholderTextColor=&quot;#a5a5a5&quot; /&gt;
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日积月累]]></title>
        <id>https://xiewangmei.github.io/post/日积月累/</id>
        <link href="https://xiewangmei.github.io/post/日积月累/">
        </link>
        <updated>2020-09-29T05:23:55.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>接口请求Status(blocked:other)，出现这种情况是被浏览器插件（如AdBlock插件）当广告拦截了</p>
</li>
<li>
<p>jquery 解决favicon.ico 404找不到的问题，可以在html头部添加&lt;link <em>rel</em>=&quot;shortcut icon&quot; <em>href</em>=&quot;#&quot;/&gt;</p>
</li>
<li>
<p>for..of ES6提供可以直接遍历值而不是数组下标</p>
<pre><code class="language-javascript">var myArray = [1,2,3];
for(var v of myArray){
    console.log(v);
}
//1
//2
//3
</code></pre>
<p>for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值</p>
</li>
<li>
<p>K8s kubelet &amp; kubeadm &amp; kubectl 介绍</p>
<ul>
<li>kubelet: 运行在cluster所有节点上，负责启动POD和容器</li>
<li>kubeadm: 用于初始化cluster</li>
<li>kubectl: kubenetes命令行工作，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</li>
</ul>
</li>
<li>
<p>npx create-react-app 报网络错误时，可以尝试将之前安装的npm create-react-app删掉（<code>npm uninstall -g create-react-app</code>），同时修改registry为淘宝镜像</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode常用快捷键]]></title>
        <id>https://xiewangmei.github.io/post/vscode/</id>
        <link href="https://xiewangmei.github.io/post/vscode/">
        </link>
        <updated>2020-09-29T03:33:22.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ctrl+Alt+I  插入作者注释</li>
<li>F1  打开命令面板</li>
<li>Ctrl+Shift+D 切换到调试视图</li>
<li>Ctrl+~ 打开终端调试窗口</li>
<li>F1 打开命令行</li>
</ul>
]]></content>
    </entry>
</feed>